{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/dev/throttle-and-debounce/","result":{"data":{"site":{"siteMetadata":{"title":"nukeguys blog","author":"nukeguys","google_ad_client":"ca-pub-3962171616803555"}},"markdownRemark":{"id":"a58a3bcd-e44a-51e2-88d4-77c5bd41e584","excerpt":"개발을 하다보면 자주 안쓰다보니 혹은 너무 당연하게 생각하다 가끔 헷갈리거나 쌩둥맞게 낯설게 다가오는 것들이 있다. debounce와 throttle…","html":"<p>개발을 하다보면 자주 안쓰다보니 혹은 너무 당연하게 생각하다 가끔 헷갈리거나 쌩둥맞게 낯설게 다가오는 것들이 있다. <code>debounce</code>와 <code>throttle</code>도 얼마 전에 뭐가 뭐였지 하고 다시 찾아봤던 것 중 하나다.\n다시 보지 않기 위해 기록한다던 누군가(베토벤이었나?)의 말을 빌려 다신 헷갈리지 않기 위해 정리를 해본다.</p>\n<p>일단 둘다 실행을 제어하기 위해, 좀 더 정확히는 빈번한 실행을 방지하기 위한 목적으로 사용한다.</p>\n<h3>Debounce</h3>\n<p>마지막 호출 이후 특정 시간이 지나야 호출 되도독 제한한다. 다른 말로는 이벤트를 그룹화 한다고도 한다. 즉 연달아 발생하는 이벤트를 하나의 그룹으로 그룹화해서 한 번만 호출이 발생하는 것이다.</p>\n<p><a href=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2016/04/debounce.png\"><img src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2016/04/debounce.png\" alt=\"debounce\"></a></p>\n<p><code>debounce</code>를 활용하기 좋은 예제는 자동 완성이다. 사용자가 타이핑을 계속하는데 매 번 api를 호출해서 결과를 받아서 그리면 그 사이에 다른 타이핑이 발생하고 결국 보여주기도 전에 새로운 결과가 필요한 상황이 발생하는 비효율이 발생할 수 있다. 따라서 타이핑을 어느정도 완료했다는 판단이 들면 요청을 발생시키는 것이다.</p>\n<p><code>debounce</code>에서는 두 가지 선택이 있다. 그룹화 된 호출들의 처음에 호출할지 대기 시간이 지난 후에 호출 할지이다. 즉 이벤트1이 발생하자마자 이벤트1을 실행하고 대기시간이 지난 후의 이벤트2가 발생했을 때 다시 이벤트2를 즉시 실행하거나, 이벤트1이 발생하고 대기시간이 지난 후에 이벤트1을 실행하고 대기시간이 지나고 이벤트2가 발생하면 다시 대기시간이 지난 후에 이벤트2를 실행한다. 차이라고 한다면 즉시 실행을 하게 되면 호출이 빈번하지 않은 경우 <code>debounce</code>가 적용되지 않은 것과 같은 효과를 낼 수 있다는 것이다.</p>\n<h3>Throttle</h3>\n<p>일정 주기마다 한 번씩만 호출 되도록 제한한다.</p>","frontmatter":{"title":"debounce vs throttle","date":"2020/03/08 15:34","tags":["TIL","throttle","debounce"],"description":"항상 헷갈려서 정리해 본다."}}},"pageContext":{"slug":"/dev/throttle-and-debounce/","previous":{"fields":{"slug":"/dev/smooth-key-scroll/"},"frontmatter":{"title":"smooth key scroll 구현하기"}},"next":null}}}