{"componentChunkName":"component---src-pages-dev-tsx","path":"/dev/","result":{"data":{"site":{"siteMetadata":{"title":"nukeguys blog","description":"about development, life and something.","siteUrl":"https://nukeguys.github.io"}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"redux-saga API는 편의성을 위해서 여러 Effect Creator들을 제공한다. 그 중 액션을 감지하기 위한 목적으로 자주 사용하는 헬퍼인 takeEvery, takeLatest, takeLeading…","html":"<p><code>redux-saga</code> API는 편의성을 위해서 여러 <code>Effect Creator</code>들을 제공한다. 그 중 액션을 감지하기 위한 목적으로 자주 사용하는 헬퍼인 <code>takeEvery</code>, <code>takeLatest</code>, <code>takeLeading</code>가 있다. 이 함수들은 정확하게 사용하지 않으면 예상치 못하게 동작하는 경우를 만나게 된다. 덕분에 나도 한동안 재현하기 힘든 버그를 잡느라 오랜시간을 헤맸는데 그러면서 사용해야하는 기준을 다시 한 번 명확하게 생각해 보게 된 적이 있다. 그래서 간단히 각각의 기능과 사용을 해야 하는 상황들에 대해 정리해 본다.</p>\n<p>어떤 걸 써도 괜찮은 경우가 있을 수도 있을진 모르겠지만 의도하는 바에 맞게 적절한 것을 골라서 사용해 주는 것이 좋다. <code>redux-saga</code>를 주로 api 호출에 사용하는 경우가 많은데, 호출하는 api가 어떤지에 따라 판단해 보면 된다.</p>\n<h3>takeEvery</h3>\n<p>액션이 dispatch될 때 마다 새로운 task를 실행한다. 항상 fork하기 때문에 동시에 호출될 수 있고, 실행 순서가 보장되지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">takeEvery</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">patternOrChannel<span class=\"token punctuation\">,</span> saga<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>args</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n  <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> action <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span>patternOrChannel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">yield</span> <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span>saga<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>args<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>dispatch된 액션에 대한 처리가 동시에 발생하기 때문에 해당 task가 동시에 중복으로 발생해도 문제가 없는 경우에 사용하면 된다. 예를 들어 클릭을 할 때 마다 서버로 클릭을 보내야 하는 이벤트가 있고, 동시에 전송이 되어 처리하는데 문제가 없는 상황이라면 적절하다.<br>\n하지만 파라미터에 따라 결과가 달라지는 api가 있고, 파라미터를 다르게 해서 api를 중복으로 호출 하는 경우가 있어 takeEvery를 사용하면 주의해야 한다. 구현에 따라 다르겠지만 의도와 다르게 동일한 파라미터를 가진 요청이 중복으로 발생할 가능성도 있기 때문이다. 예를 들어 한 화면에 탭으로 구분된 레이아웃에서 데이터를 불러올 때 동일 api에 파라미터만 변경해서 사용한다면 하나의 액션으로 <code>takeEvery</code>를 사용할 수도 있겠지만, 개인적으로 이런 경우엔 액션을 분리해서 <code>takeLatest</code>나 <code>takeLeading</code>로 처리하고 task를 공통으로 사용하는 것도 괜찮을 것 같다.</p>\n<h3>takeLatest</h3>\n<p>액션이 dispatch 됐을 때 이전에 이미 실행 중인 task가 있다면 취소하고 새로운 task를 실행(fork)한다. 즉 항상 최신 액션이 처리되는 것을 보장한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">takeLatest</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">patternOrChannel<span class=\"token punctuation\">,</span> saga<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>args</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n  <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> lastTask<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> action <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span>patternOrChannel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lastTask<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">yield</span> <span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span>lastTask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// cancel is no-op if the task has already terminated</span>\n      <span class=\"token punctuation\">}</span>\n      lastTask <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span>saga<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>args<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이미 처리 중인 상황이라도 동일한 액션이 dispatch되면 취소되고 다시 호출이 된다. 즉 이전 api 요청은 무시되고 최신 data를 받아올 수 있다. 상황에 따라 다르겠지만 대부분 데이터를 가져오는 요청(GET)은 최신 데이터를 받는 것이 좋다. 페이지 전환 또는 새로고침 기능 등을 통해 동일한 api 요청이 발생하는 경우에는 이전 요청은 받아도 의미가 없고 최신 요청을 빠르게 처리해서 보여주는 것이 좋기 때문이다.<br>\n하지만 액션이 dispatch 될 때 마다 취소되고 새로운 요청이 가기 때문에 결과가 같거나 동기화 자체가 그닥 중요하지 않은 api 요청이 중복으로 발생하는 경우에는 불필요한 딜레이가 생길 수 있다. 이럴 땐 <code>takeLeading</code>으로 처리해 주는 것이 좋다.<br>\n보통 GET 요청이면서 파라미터에 따라 결과가 달라지는 api라면 <code>takeLatest</code>를 사용해주면 적절했다.</p>\n<h3>takeLeading</h3>\n<p>액션이 dispatch되고 task가 실행되면 끝날 때 까지 동일한 액션에 대해서 감지를 하지 않는다. 즉 먼저 호출된 액션이 처리되는 것을 보장한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">takeLeading</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">patternOrChannel<span class=\"token punctuation\">,</span> saga<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>args</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n  <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> action <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span>patternOrChannel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>saga<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>args<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>처리 순서가 중요하거나 중복으로 호출되면 안되는 경우, 위에서 언급한 것 처럼 항상 같은 결과를 반환하는 api를 호출하는 경우(또는 바뀔 가능성이 많지 않고, 바뀌더라도 동기화가 바로 처리될 필요 없는 경우)에 사용해주면 좋다. 데이터를 추가 또는 삭제 등의 경우에는 api에서 처리가 되어 있다면 상관없을 수 있겠지만 중복이 발생하지 않도록 순서대로 처리해 주는 것이 좋고, 고정된 어떤 값을 받아와야 하는 경우에는 이미 요청이 발생한 경우 굳이 다시 요청을 하지 않아도 되기 때문에 <code>takeLatest</code>에 비해 빠르게 응답을 할 수 있기 때문이다.\n일반적으로 GET 요청이 아닌 경우나, GET 요청이면서 결과가 바뀌지 않는 경우들은 <code>takeLeading</code>을 사용해주면 괜찮았다.</p>\n<p>내가 헤맸던 상황은 쿼리에 따라 결과가 달라지는 api를 호출할 때 <code>takeLeading</code>을 사용하고 있었다. 문제는 이 api가 중복해서 호출되는 경우를 예상하지 못했다는 것이다. 하지만 생각치 못하게 같은 api를 요청이 중복으로 발생하는 것이 가능했고 그러다 보니 유저 액션에 따른 화면은 최신 결과를 반영하려 하고 api는 이전의 결과를 받아와서 처리를 하는 상황이었다. 간단히 <code>takeLatest</code>로 바꾸고 해결됐다.<br>\n현재 구현과 상황에 따라 의존적으로 처리 하거나 제약이 필요한 경우도 물론 있겠지만, 기본적으로는 외부상황(api요청 자체만 봤을 때 언제 어디서 호출되는지는 외적인 요인이다)을 배제하고 해당 기능에 대해서만 판단을 하고 구현을 해야 문제가 될 가능성이 줄어든다. 즉 의존성을 줄이는 것으로 볼 수 있다. 소프트웨어에서 어찌보면 당연한 말이지만, 때때로 놓치는 경우가 있다. 다시 한 번 기본의 중요성을 깨닫게 된다.</p>","fields":{"slug":"/dev/redux-saga-effect-creator/"},"frontmatter":{"date":"2020/05/16","title":"takeEvery vs takeLatest vs takeLeading","description":"redux-saga에서 자주 쓰는 effect creator 비교","tags":["redux-saga","jest","test"]}}},{"node":{"excerpt":"redux-saga는 비동기 처리(data fetching이나 browser cache접근 등) 같은 사이드 이펙트를 좀 더 쉽게 관리하고 사용할 수 있도록 도와주는 라이브러리이다. redux-saga는 redux middleware…","html":"<p><code>redux-saga</code>는 비동기 처리(data fetching이나 browser cache접근 등) 같은 사이드 이펙트를 좀 더 쉽게 관리하고 사용할 수 있도록 도와주는 라이브러리이다. redux-saga는 <code>redux middleware</code>이기 때문에 일반적인 redux action을 통해 동작을 제어할 수 있다. 그리고 비동기 처리를 위해 ES6의 <code>generator</code>를 사용하는데, 바로 이 점 때문에 테스트를 쉽게 작성할 수 있다.</p>\n<p>redux-saga를 사용하면서 작성하는 generator 함수는 내부에서 yield를 사용한다. 그리고 이는 <code>effect</code>라고 부르는 객체를 반환하는데 이 객체를 <code>middleware</code>에서 받아 실행하고 그 결과를 다시 반환한다. 즉 어떤 작업을 생성하는 곳과 실제로 실행하는 곳이 분리되어 있는 것이다. 실행은 middleware에서 하기 때문에 우리는 직접 작성한 코드(생성을 담당하는)를 테스트해야 하는데, 두 부분이 분리되어 있는 덕분에 중간에 끼어들어 실행하지 않고도 테스트를 할 수 있게 되는 것이다.</p>\n<p>목적에 따라 redux-saga의 generator 함수를 테스트 하는 방법이 다를 수 있다. 예를 들면 함수의 각 실행 단계를 테스트 하는 것이다. 다른 방법으로는 함수 최종 결과만 테스트 하는 것이다. 현재 구현을 정확하게 테스트 하는데 있어서는 첫 번째 방법이 좋을 수 있지만 이는 내부 구현에 의존적이기 때문에 같은 기능을 하더라도 구현이 바뀌면 테스트도 함께 수정을 해야 하고, 테스트 코드 작성시 작성자의 개입이 상대적으로 많이 발생한다(테스트를 위한 코드에 개입이 많으면 그 코드에 의해 문제를 발견하지 못하는 경우가 생길 수도 있다). 반대로 두번째 방법은 함수 자체의 기능만 검증하기 때문에 구현에 덜 의존적이고 따라서 테스트 코드를 수정하는 일이 생기진 않겠지만 부가적으로 처리해줘야 하는 것들이 생긴다(중간 개입이 적기 때문에). 또 보다 정확한 테스트를 위해서는 내부에서 사용하는 각 함수들의 테스트도 함께 작성 해주는 것이 좋을 수 있다.</p>\n<p>우선은 간단하면서도 쉽게 적용할 수 있는 첫 번째 방법에 대해 정리해 본다.\n아래와 같은 saga 함수에 4가지를 테스트 한다고 가정해보자.(코드가 실제로 동작하려면 좀 더 필요하지만 간단한 설명을 위해 코드를 간략하게 했다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">fetchUser</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">action</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> id <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> action<span class=\"token punctuation\">.</span>payload<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> secret <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>getSecret<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> additionalParams <span class=\"token operator\">=</span> <span class=\"token function\">getParams</span><span class=\"token punctuation\">(</span>secret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>callApiForFetchUser<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>additionalParams<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> userInfo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    login<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    user<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">yield</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token function\">setUserInfoAction</span><span class=\"token punctuation\">(</span>userInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ol>\n<li>secret를 가져오는 effect(<code>getSecret</code>) 생성</li>\n<li>api호출을 하는 effect(<code>callApiForFetchUser</code>) 생성</li>\n<li>redux에 저장하기 위한 effect(<code>setUserInfo</code>) 생성</li>\n<li>실행 완료</li>\n</ol>\n<p>이 테스트 코드는 아래처럼 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Saga Test'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fetchUser'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'사용자 정보를 가져오는 api를 호출하고, redux에 userInfo를 저장하고, 정상 종료한다.'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> <span class=\"token string\">'19870605'</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">const</span> iterator <span class=\"token operator\">=</span> <span class=\"token function\">fetchUser</span><span class=\"token punctuation\">(</span><span class=\"token function\">fetchUserAction</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// 1. secret를 가져오는 effect(`getSecret`) 생성</span>\n      <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toEqual</span><span class=\"token punctuation\">(</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>getSecret<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 2. api호출을 하는 effect(`callApiForFetchUser`) 생성</span>\n      <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> secret<span class=\"token punctuation\">:</span> <span class=\"token string\">'t4lz0mf4lt'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toEqual</span><span class=\"token punctuation\">(</span>\n        <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>callApiForFetchUser<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> param1<span class=\"token punctuation\">:</span> <span class=\"token string\">'param1'</span><span class=\"token punctuation\">,</span> param2<span class=\"token punctuation\">:</span> <span class=\"token string\">'param2'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 3. redux에 저장하기 위한 effect(`setUserInfo`) 생성</span>\n      <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">'nukeguys'</span><span class=\"token punctuation\">,</span> level<span class=\"token punctuation\">:</span> <span class=\"token string\">'vip'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toEqual</span><span class=\"token punctuation\">(</span>\n        <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>\n          <span class=\"token function\">setUserInfoAction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n            login<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n            user<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">'nukeguys'</span><span class=\"token punctuation\">,</span> level<span class=\"token punctuation\">:</span> <span class=\"token string\">'vip'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 4. 실행 완료</span>\n      <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBeTruthy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>단계별로 나눠보자.</p>\n<p><strong>우선 테스트 할 generator 함수를 호출해서 iterator를 받아온다.</strong><br>\ngenerator이기 때문에 iterator가 반환된다. 따라서 각 실행 단계별로 테스트를 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> iterator <span class=\"token operator\">=</span> <span class=\"token function\">fetchUser</span><span class=\"token punctuation\">(</span><span class=\"token function\">fetchUserAction</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>1. secret를 가져오는 effect(<code>getSecret</code>) 생성</strong><br>\n위에서 말한 것 처럼 실행 결과가 아닌 effect를 비교한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toEqual</span><span class=\"token punctuation\">(</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>getSecret<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>2. api호출을 하는 effect(<code>callApiForFetchUser</code>) 생성</strong><br>\n<strong>3. redux에 저장하기 위한 effect(<code>setUserInfo</code>) 생성</strong><br>\n동일하게 effect를 비교한다. 하지만 계속 진행하기 위해서는 이전 실행의 결과가 필요하다. 이를 실제 실행 결과가 아니라 직접 주입시켜서 사용하도록 하는 것이다. 따라서 실제 실행 없이 테스트가 가능하고, 이부분이 테스트 작성자가 개입하게 되는 부분이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> secret<span class=\"token punctuation\">:</span> <span class=\"token string\">'t4lz0mf4lt'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toEqual</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>callApiForFetchUser<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> param1<span class=\"token punctuation\">:</span> <span class=\"token string\">'param1'</span><span class=\"token punctuation\">,</span> param2<span class=\"token punctuation\">:</span> <span class=\"token string\">'param2'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">'nukeguys'</span><span class=\"token punctuation\">,</span> level<span class=\"token punctuation\">:</span> <span class=\"token string\">'vip'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toEqual</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>\n    <span class=\"token function\">setUserInfoAction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      login<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n      user<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">'nukeguys'</span><span class=\"token punctuation\">,</span> level<span class=\"token punctuation\">:</span> <span class=\"token string\">'vip'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>4. 실행 완료</strong><br>\ndone값으로 generator가 최종적으로 이상없이 완료되었음을 확인한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBeTruthy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위에서 언급한 것처럼 이런 방식은 구현 자체에 의존적이기 때문에 구현이 변경되면 테스트도 함께 수정이 필요해진다. 또 주입된 코드에 의해 문제가 있어도 테스트를 통과하는 경우가 발생할 수도 있다. 따라서 필요시에는 최종 결과만을 확인하는 테스트가 필요할 수 있다. 이 경우에는 mocking을 통해 saga를 실제로 실행하고 완료한 후에 확인을 한다. 하지만 saga 내부 로직을 대체하기가 생각보다 까다로운 경우가 많다. 장단이 있기 때문에 두 가지 방법을 적절히 조합해서 사용하는 것이 좋아 보인다. 기회가 되면 두번째 방법도 정리해 볼 예정이다.</p>\n<h3>참고</h3>\n<p><a href=\"https://redux-saga.js.org/docs/advanced/Testing.html\">3.10 Examples of Testing Sagas · Redux-Saga</a></p>","fields":{"slug":"/dev/redux-saga-test/"},"frontmatter":{"date":"2020/04/12","title":"redux-saga 테스트 하기 (feat. jest)","description":"redux-saga generator 함수 순차 테스트 하기","tags":["redux-saga","jest","test"]}}},{"node":{"excerpt":"웹 개발을 하다 보면 네트워크 요청시 실제 원하는 요청(GET, PUT, POST, DELETE 등)전에 OPTIONS…","html":"<p>웹 개발을 하다 보면 네트워크 요청시 실제 원하는 요청(GET, PUT, POST, DELETE 등)전에 <code>OPTIONS</code> 요청이 발생하는 것을 볼 수 있다. 이게 뭘까하고 응답값을 확인하면 아무것도 없다. 응답값이 없는 이 요청은 왜 발생하는걸까?\n<code>preflight</code>라고도 불리는 <code>OPTIONS</code> 요청은 브라우저가 서버에게 지원하는 옵션들을 미리 요청하고 허가된 요청에 한해서 전송하기 위한 보안상의 목적이 있다.<br>\n모든 경우에 발생하지 않고, 실제 요청에 비해 많은 부분을 차지하지 않지만 경우에 따라 수백 ms 응답 속도가 중요하다면 발생하지 않도록 하는 것이 좋다. 그러기 위해선 발생하는 상황을 알아야 하는데 이는 <code>CORS</code>와 관련이 있다.</p>\n<h5>CORS(Cross-Origin Resource Sharing)와 보안</h5>\n<p>웹 개발을 하는 사람이라면 대부분 알겠지만 간단히 정리하면, 현재 웹페이지가 웹페이지를 받은 서버와 다른 서버의 리소스를 요청하는 것을 의미한다. 대표적인 예로 웹서버와 분리되어 있는 API 서버로 요청을 보내거나, 아래처럼 CDN의 이미지를 사용하는 것을 들 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">'</span>&lt;cdn-url>/image.png<span class=\"token punctuation\">'</span></span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>하지만 이는 유용하면서도 보안상의 문제점을 가지고 있다. 웹사이트에서 악의적인 목적으로 외부로 정보를 보내거나 하는 등의 요청을 보낼 수 있기 때문이다. 그렇기 때문에 브라우저는 <code>OPTIONS</code>를 <code>preflight</code>하여 서버에서 허용하는 옵션을 미리 확인하고, 허용되지 않은 요청의 경우 <code>405(Method Not Allowed)</code>에러를 발생시키고 실제 요청은 전송하지 않는다.</p>\n<h5>OPTIONS 요청</h5>\n<p>하지만 모든 CORS 상황에서 <code>OPTIONS</code> 요청이 발생하지 않는다. 아래 조건을 모두 만족하면 OPTIONS 없이 요청을 보낸다.</p>\n<ol>\n<li><code>GET</code>, <code>HEAD</code>, <code>POST</code> 요청 중 하나</li>\n<li>user agent에 의해 자동으로 설정되는(Connection, User-Agent, Fetch 스펙상 <a href=\"https://fetch.spec.whatwg.org/#forbidden-header-name\">forbidden header</a>로 정의되어 있는) 헤더외에 <a href=\"https://fetch.spec.whatwg.org/#cors-safelisted-request-header\">CORS-safelisted request-header</a>로 명시된 헤더들만 포함된 경우(<code>Accept</code>, <code>Accept-Language</code>, <code>Content-Language</code>, <code>Content-Type</code> 등)</li>\n<li>Content-Type은 <code>application/x-www-form-urlencoded</code>,\n<code>multipart/form-data</code>, <code>text/plain</code>만 허용</li>\n</ol>\n<p>위의 조건들 중 하나라도 만족하지 않으면 preflight 요청을 보내게 된다. 이 과정을 간단히 정리하면 아래와 같다.</p>\n<ol>\n<li>브라우저에서 method를 <code>OPTIONS</code>로 요청 전송</li>\n<li>OPTIONS를 받은 서버가 응답헤더에 허용하는 옵션(<code>Access-Control-Allow-*</code>)을 포함해 전송</li>\n<li>브라우저는 응답헤더의 옵션을 확인해 허용되지 않은 요청은 <code>504</code>에러 발생, 허용하는 경우 요청 전송</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1024px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/09a7671f8c2dc6d699843c3075f656de/6f075/options.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.871382636655945%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABSklEQVQoz3WR2XKCQBBF+RBBZRZWURYZluCCqUq5pBJ9yUOSj8j/P9z0gFpFlT6cujDTfWluG5vfP5jt951R+wPWfmG9XqMoCrTbEvt9gfN5SeQ4HhQulxzvJ4XPj5zqCqorUZY9hut5YIwNsG27u2xfd3g7pNTo4XS0SE0yM0ktbDdT7HYTBIHuERCCg3MOQzfrB87ZVXlnmiQJmlWDJMsRhhn8IIWQEUxTYDTiGI8ZLEt/fDiM0RlcuZkJIbBYLJBlGeZRBN934boePM+H4zh0L+/od43USNkbPmJOhmVVoa5foFRBWSls25zO5qhqgrQsI8xmAU0fEqS+/9hQTxnHMVa0mLqukSuFNAuRph5FQVw1jh2qt7vMbzw17DJsGiyXORllFP6sC38ysTGdsjuMDXufGur8KvpdnY/ruh1SisHybsvsTfvzf/sW8+Y51+KkAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"OPTIONS request\"\n        title=\"OPTIONS request\"\n        src=\"/static/09a7671f8c2dc6d699843c3075f656de/3b243/options.png\"\n        srcset=\"/static/09a7671f8c2dc6d699843c3075f656de/00397/options.png 256w,\n/static/09a7671f8c2dc6d699843c3075f656de/c5a17/options.png 512w,\n/static/09a7671f8c2dc6d699843c3075f656de/3b243/options.png 1024w,\n/static/09a7671f8c2dc6d699843c3075f656de/ccc27/options.png 1536w,\n/static/09a7671f8c2dc6d699843c3075f656de/6f075/options.png 1866w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>참고로 CORS가 가능하려면 서버에서 허용된 origin이어야 한다. 서버에서 응답을 보낼 때 헤더에 <code>Access-Control-Allow-Origin</code>을 포함해 함께 보내는데 이 값에 <code>origin</code>이 포함되지 않는다면 에러가 발생하게 된다. 일반적으로 말하는 CORS 문제이다.</p>\n<h5>OPTIONS 요청 없애기</h5>\n<p>첫 번째는 CORS 상황이 되지 않도록 하는 것이다. 즉 웹서버와 동일한 서버의 리소스만 사용하는 것이다. 하지만 API 서버가 분리되어 있는 경우가 많기 때문에 쉽지 않다. 이런 경우에는 웹에서 발생하는 요청을 웹서버와 동일한 서버에서 받아 실제 API서버로 전달하는 중계점을 두면 해결될 수 있다.</p>\n<p>두 번째로는 CORS에서 preflight가 발생하지 않는 조건을 모두 만족시키는 것이다. 하지만 이것도 일반적으로 인증을 위한 헤더를 포함하거나, 최근엔 Content-Type으로 <code>application/json</code>을 사용하는 경우가 많기 때문에 적용하기는 어려울 수 있다.</p>\n<h5>사족</h5>\n<p>관련 정보를 찾아보다가 네트워크 요청을 위한 라이브러리(axios 같은)를 사용하면서 OPTIONS 요청이 발생한다고 문제를 제기하는 경우들 봤는데 이는 http와 관련된 웹 표준이기 때문에 해당 라이브러리들에서는 어찌할 도리가 없다.</p>\n<p>추가로, 내용과는 조금 거리가 있지만 예전부터 요청과 응답을 통제하기 위해 표준에 정의된 헤더나 상태코드를 활용하는 경우를 많지 보지 못했다. 물론 장단점이 있겠지만 좀 더 잘 알고 사용해보면 좋지 않을까 하는 생각이 다시 한 번 들었다.</p>\n<p>[참고] - <a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/CORS\">교차 출처 리소스 공유 (CORS) - HTTP | MDN</a></p>","fields":{"slug":"/dev/options-request/"},"frontmatter":{"date":"2020/03/15","title":"[TIL] `OPTIONS` 요청은 왜 발생하는가?","description":"OPTIONS와 CORS의 관계","tags":["TIL","OPTIONS","CORS"]}}},{"node":{"excerpt":"개발을 하다보면 자주 안쓰다보니 혹은 너무 당연하게 생각하다 가끔 헷갈리거나 쌩둥맞게 낯설게 다가오는 것들이 있다. debounce와 throttle…","html":"<p>개발을 하다보면 자주 안쓰다보니 혹은 너무 당연하게 생각하다 가끔 헷갈리거나 쌩둥맞게 낯설게 다가오는 것들이 있다. <code>debounce</code>와 <code>throttle</code>도 얼마 전에 뭐가 뭐였지 하고 다시 찾아봤던 것 중 하나다.\n다시 보지 않기 위해 기록한다던 누군가(베토벤이었나?)의 말을 빌려 다신 헷갈리지 않기 위해 정리를 해본다.</p>\n<p>일단 둘다 실행을 제어하기 위해, 좀 더 정확히는 빈번한 실행을 방지하기 위한 목적으로 사용한다.</p>\n<h3>Debounce</h3>\n<p>마지막 호출 이후 특정 시간이 지나야 호출 되도독 제한한다. 다른 말로는 이벤트를 그룹화 한다고도 한다. 즉 연속으로 발생하는 이벤트를 하나의 그룹으로 그룹화해서 한 번만 호출이 발생하도록 제한 것이다.</p>\n<p><a href=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2016/04/debounce.png\"><img src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2016/04/debounce.png\" alt=\"debounce\"></a></p>\n<p><code>debounce</code>를 활용하기 좋은 예제는 자동 완성이다. 사용자가 타이핑을 계속하는데 매번 api를 호출해서 결과를 받아서 그리면 그 사이에 다른 타이핑이 발생하고 결국 보여주기도 전에 새로운 결과가 필요한 상황이 발생하는 비효율이 발생할 수 있다. 따라서 타이핑이 더이상 발생하지 않아 타이핑이 완료됐다는 판단이 들면 요청을 발생시키는 것이다.</p>\n<p><code>debounce</code>에서는 두 가지 선택이 있다. 그룹화 된 호출들의 처음에 호출할지 대기 시간이 지난 후에 호출 할지이다. 즉 이벤트1이 발생하자마자 이벤트1을 실행하고 대기시간이 지난 후의 이벤트2가 발생했을 때 다시 이벤트2를 즉시 실행하거나, 이벤트1이 발생하고 대기시간이 지난 후에 이벤트1을 실행하고 대기시간이 지나고 이벤트2가 발생하면 다시 대기시간이 지난 후에 이벤트2를 실행한다. 차이라고 한다면 즉시 실행을 하게 되면 호출이 빈번하지 않은 경우 <code>debounce</code>가 적용되지 않은 것과 동일한 시점에 이벤트가 발생 한다는 것이다.</p>\n<p><a href=\"https://i2.wp.com/css-tricks.com/wp-content/uploads/2016/04/debounce-leading.png\"><img src=\"https://i2.wp.com/css-tricks.com/wp-content/uploads/2016/04/debounce-leading.png\" alt=\"leading\"></a></p>\n<h3>Throttle</h3>\n<p>일정 주기마다 한 번씩만 호출 되도록 제한한다. <code>debounce</code>와 차이점은 특정 시간 안에 최소 한 번의 실행을 보장한 다는 것이다. 다르게 표현하자면 이벤트가 발생한 후 특정 시간 동안 발생하는 이벤트들을 무시하고 정해진 시간이 지난 후에 다시 이벤트를 발생 시키는 것이다.</p>\n<p><code>throttle</code>의 예로는 무한 스크롤을 수 있다. 다음 내용을 미리 가져오기 위해 끝에 도달했는지를 검사해야 하는데 이를 스크롤이 발생할 때 마다 하는건 매우 비효율 적이다. 실제 이벤트 발생보다 덜 빈번하게 주기를 낮춰서 검사하는 것이 좋은데 이때 사용할 수 있다.</p>\n<h3>requestAnimationFrame(rAF)</h3>\n<p><code>throttle</code>과 동일한 효과를 내는 브라우저 native API이다. 매 프레임 마다 실행 되는데 기본적으로 16ms(60fps)마다 실행이 된다. 차이가 있다면 무엇보다 <code>requestAnimationFrame</code>은 브라우저 API라는 점이다. 그렇기 때문에 사용이 편하고 브라우저가 렌더링 스케줄에 대한 최적화를 하기 때문에 렌더링에 있어서는 더 좋을 수 있다. 하지만 모든 브라우저에서 지원하지 않기 때문에 <code>polyfill</code>이 필요할 수 있고 <code>node.js</code>에서는 지원하지 않기 때문에 서버에서는 사용할 수 없다. 추가로 <code>rAF</code>는 다른 두 함수와 다르게 시작 시점을 직접 컨트롤해야 한다는 것이다.</p>\n<p>그렇다면 언제 사용하는 것이 좋을까?\n<code>rAF</code>의 경우 위에서 언급했듯이 렌더링과 관련된 처리를 할 때 매우 유용하다. 브라우저 native API인데다 렌더링에 맞추어져 있기 때문이다. 대신 렌더링이 아닌 경우, 예를 들어 서버 API 호출이나 애니메이션 같은 렌더링의 시작이나 종료를 결정해야 하는 경우에는 <code>debounce</code>나 <code>throttle</code>이 유용하다. 특히 16ms 보다 덜 빈번하게 주기를 조절해야 하는 경우에는 특히 사용해야 한다.</p>\n<p>정리를 해보면,<br>\n<code>debounce</code>는 키입력과 같이 갑자기 이벤트가 몰리는 상황에서 그룹화를 통한 제어가 필요할 때,<br>\n<code>throttle</code>은 정해진 매 주기마다 이벤트 실행을 보장해야 할 때,<br>\n<code>requestAnimationFrame</code>은 throttle과 유사하지만 렌더링과 관련된 (화면에 무언가를 그린다거나 부드러운 애니메이션 효과 등) 작업을 처리할 때 사용하면 좋다.</p>\n<p>좀 더 자세한 내용과 실제 예제를 확인하고 싶으면 아래 참고의 링크를 확인하면 된다.</p>\n<h3>참고</h3>\n<p><a href=\"https://css-tricks.com/debouncing-throttling-explained-examples/\">Debouncing and Throttling Explained Through Examples | CSS-Tricks</a></p>","fields":{"slug":"/dev/debounce-and-throttle/"},"frontmatter":{"date":"2020/03/08","title":"debounce vs throttle","description":"항상 헷갈려서 정리해 본다.","tags":["TIL","throttle","debounce"]}}},{"node":{"excerpt":"…","html":"<p>대개의 브라우저에서 방향키로 스크롤을 하면 뚝뚝 끊겨서 이동이 된다. 보통은 크게 상관이 없지만 컨텐츠를 소비하는 화면이라면 사용성 경험적으로 좋지 못하다.(물론 마우스로는 가능하나 키보드를 사용하는 경우에 한정된 경우다) 이를 개선하기 위해 뷰어에서 키보드로 이동하는 경우에도 smooth-scroll을 적용하기 위한 컴포넌트를 작성했었다. 시간은 좀 지났지만 정리해 본다.\n(적용된 결과는 <a href=\"https://page.kakao.com/viewer?productId=50896822\">여기</a>에서 먼저 확인해보자.)</p>\n<h3>벤치마킹</h3>\n<p>역시나 바퀴의 재발명은 불필요하다는 생각에, 일단 smooth-scroll 기능을 제공하는 곳이 있는지 이미 구현되어 있는 오픈소스들이 있는지 확인 해 봤다. 여기저기 찾다가 도움이 될 만한 chrome extension 2개(<a href=\"https://github.com/gblazex/smoothscroll\">smoothscroll</a>, <a href=\"https://github.com/franciscolourenco/smoothkeyscroll\">smmothkeyscroll</a>)를 발견했다. 하지만 extension으로만 제공해서 사용하기 불가능했기 때문에 참고해서 직접 구현하기로 결정하고 작업을 시작했다.</p>\n<h3>1. Queue를 사용한 가속도 처리</h3>\n<p>기본적인 아이디어는 키 이벤트가 발생하면 <code>발생 시간</code>과 <code>스크롤 거리</code>를 큐에 저장하고 <code>requestAnimationFrame</code>을 호출한다. 그러면 각 단계에서는 <code>스크롤 거리x(현재시간-발생시간)/한 번의 이벤트에 걸리는 시간</code>으로 현재 프레임에 이동할 거리를 구한 후 스크롤(<code>window.scrollBy</code>)한다. 그리고 최종적으로 해당 이벤트에 대한 이동이 끝났으면 큐에서 제거한다.<br>\n이전 스크롤이 끝나기 전에 동일 방향의 이벤트가 다시 발생하면 큐에 새로 추가하고 각 프레임에서는 큐에 들어있는 모든 이벤트에 대해 위의 이동 거리를 계산 후 합해서 스크롤을 한다. 이렇게 되면 키를 계속 누르고 있는 경우에는 이벤트가 큐에 누적되기 때문에 가속이 발생하게 되고, 키를 다시 때게 되면 순차적으로 이벤트가 완료되면서 큐가 줄어들기 때문에 감속이 된다. 또한 한 번에 사용되는 시간이 정해져 있기 때문에 무한정 누적되지 않아 일정한 속도 이상은 늘어나지 않게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// ...</span>\n  <span class=\"token function-variable function\">_keydown</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event<span class=\"token punctuation\">:</span> KeyboardEvent</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n\n    <span class=\"token keyword\">let</span> y<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>keyCode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">case</span> <span class=\"token constant\">KEY_CODE</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UP</span><span class=\"token punctuation\">:</span>\n        y <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>scrollDistance<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">case</span> <span class=\"token constant\">KEY_CODE</span><span class=\"token punctuation\">.</span><span class=\"token constant\">DOWN</span><span class=\"token punctuation\">:</span>\n        y <span class=\"token operator\">=</span> scrollDistance<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">_scrollArray</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    event<span class=\"token punctuation\">.</span><span class=\"token function\">preventDefault</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">_scrollArray</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">y<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">_directionCheck</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_que<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      scrollY<span class=\"token punctuation\">:</span> y<span class=\"token punctuation\">,</span>\n      lastY<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n      start<span class=\"token punctuation\">:</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_pending<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> animationTime <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">step</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> now <span class=\"token operator\">=</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">let</span> totalY <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_que<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> item <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_que<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> elapsed <span class=\"token operator\">=</span> now <span class=\"token operator\">-</span> item<span class=\"token punctuation\">.</span>start<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> finished <span class=\"token operator\">=</span> elapsed <span class=\"token operator\">>=</span> animationTime<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">const</span> rate <span class=\"token operator\">=</span> finished <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">:</span> elapsed <span class=\"token operator\">/</span> animationTime<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> distY <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">.</span>scrollY <span class=\"token operator\">*</span> rate <span class=\"token operator\">-</span> item<span class=\"token punctuation\">.</span>lastY<span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n        totalY <span class=\"token operator\">+=</span> distY<span class=\"token punctuation\">;</span>\n        item<span class=\"token punctuation\">.</span>lastY <span class=\"token operator\">+=</span> distY<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>finished<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_que<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          i<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n\n      window<span class=\"token punctuation\">.</span><span class=\"token function\">scrollBy</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> totalY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_que <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_que<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>step<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_pending <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>step<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_pending <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">_directionCheck</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">y<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> direction <span class=\"token operator\">=</span> y <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token constant\">DIRECTION</span><span class=\"token punctuation\">.</span><span class=\"token constant\">DOWN</span> <span class=\"token punctuation\">:</span> <span class=\"token constant\">DIRECTION</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UP</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_direction <span class=\"token operator\">!==</span> direction<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_direction <span class=\"token operator\">=</span> direction<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_que <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// ...</span></code></pre></div>\n<h3>2. 고정거리 스크롤</h3>\n<p>위 방법으로 하면 가속도 처리가 되긴 하지만, 버벅임이 발생하는 문제가 있었다. 그래서 단순하게 테스트로 이벤트가 발생할 때 마다 일정한 거리를 이동하도록 해봤더니 훨씬 부드러운 스크롤이 됐다. 매 프레임마다 큐를 모두 확인하는 계산이 가볍지 않아서 일까 싶었고 부드러운 스크롤이 목표였기 때문에 가속은 굳이 필요하지 않았다.</p>\n<p>최종적으로 키이벤트가 발생하면 방향에 따라 일정한 이동거리를 저장한다. 그리고 각 프레임에서는 저장된 거리만큼 스크롤을 시킨다. 훨씬 간단하지만 더 자연스럽게 동작했다.</p>\n<p>참고로 처음 구현을 하고 나서도 가끔 끊기는 현상이 있었다. 아래에 주석처럼 키 이벤트에 대한 브라우저의 기본 스크롤 동작이 있기 때문에 함께 동작하면서 발생한 현상이었다. 기본 동작을 방지하기 위해서 <code>event.preventDefault();</code>를 호출해 주어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// ...</span>\n  <span class=\"token function-variable function\">onKeyEvent</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event<span class=\"token punctuation\">:</span> KeyboardEventObject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n    <span class=\"token keyword\">const</span> newDirection <span class=\"token operator\">=</span>\n      keyType <span class=\"token operator\">===</span> KeyboardKeyType<span class=\"token punctuation\">.</span>ArrowUp <span class=\"token operator\">?</span> Direction<span class=\"token punctuation\">.</span>Up <span class=\"token punctuation\">:</span> Direction<span class=\"token punctuation\">.</span>Down<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span><span class=\"token keyword\">type</span> <span class=\"token operator\">===</span> <span class=\"token string\">'keydown'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 호출하지 않으면 브라우저의 기본 스크롤 동작 때문에 끊기는 현상이 생긴다.</span>\n      event<span class=\"token punctuation\">.</span><span class=\"token function\">preventDefault</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">scroll</span><span class=\"token punctuation\">(</span>newDirection<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n      event<span class=\"token punctuation\">.</span><span class=\"token keyword\">type</span> <span class=\"token operator\">===</span> <span class=\"token string\">'keyup'</span> <span class=\"token operator\">&amp;&amp;</span>\n      newDirection <span class=\"token operator\">===</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>scrollDirection\n    <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">scroll</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">direction<span class=\"token punctuation\">:</span> Direction</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>scrollDirection <span class=\"token operator\">=</span> direction<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> scrollSpeed <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>scrollDistance <span class=\"token operator\">=</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>scrollDirection <span class=\"token operator\">===</span> Direction<span class=\"token punctuation\">.</span>Up <span class=\"token operator\">?</span> <span class=\"token operator\">-</span>scrollSpeed <span class=\"token punctuation\">:</span> scrollSpeed<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentFrame<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentFrame <span class=\"token operator\">=</span> <span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>step<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>scrollDirection <span class=\"token operator\">=</span> Direction<span class=\"token punctuation\">.</span>None<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>scrollDistance <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentFrame<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">cancelAnimationFrame</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentFrame<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentFrame <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function-variable function\">step</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentFrame <span class=\"token operator\">=</span> <span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>step<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      window<span class=\"token punctuation\">.</span><span class=\"token function\">scrollBy</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>scrollDistance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ...</span></code></pre></div>\n<p>다시 최종 결과를 비교해서 확인해 보자.(참고로 내가 좋아하는 두 웹툰이다.)<br>\n<a href=\"https://comic.naver.com/webtoon/detail.nhn?titleId=183559&#x26;no=470\">네이버 만화, 신의 탑</a> vs <a href=\"https://page.kakao.com/viewer?productId=50896822\">카카오페이지, 나 혼자만 레벨업</a></p>","fields":{"slug":"/dev/smooth-key-scroll/"},"frontmatter":{"date":"2020/03/01","title":"smooth key scroll 구현하기","description":"키보드를 이용해 부드러운 스크롤 동작시키기","tags":["scroll"]}}},{"node":{"excerpt":"일정을 맞추기 위해 일부 웹페이지에 외부의 도움을 받기로 했다. 프로젝트를 공유해서 작업하는 방식이 아닌 별도의 웹페이지를 제작하면 현재 프로젝트의 특정 화면에 html…","html":"<p>일정을 맞추기 위해 일부 웹페이지에 외부의 도움을 받기로 했다. 프로젝트를 공유해서 작업하는 방식이 아닌 별도의 웹페이지를 제작하면 현재 프로젝트의 특정 화면에 html을 그대로 삽입해서 보여주는 방식이다. 이를 처리하는 과정에서 직면한 문제와 돌고돌아 생각보다 간단하게 해결만 방법을 정리해본다.</p>\n<p>추가해야 할 페이지(outer_html)는 이미 알고 있다고 하면 현재 페이지의 하나의 탭 화면으로 추가해야 한다면 어떻게 해야 할까.</p>\n<p>첫 번째 구현방식은 <a href=\"https://developer.mozilla.org/ko/docs/Web/Web_Components/Using_shadow_DOM\">shadow DOM</a>을 사용하는 것이었다.\b <code>shadow DOM</code>은 간단히 DOM안에 포함되어 있지만 캡슐화 된 DOM이라고 할 수 있다. 예를 들어 다른 누군가가 만든 컴포넌트 또는 코드를 가져다 사용한다고 하면 겹침이 발생할 가능성이 있다. 이럴 때 class명에 prefix를 지정한다거나 하는 방식으로 가능하겠지만 shadow DOM을 사용하면 해당 DOM에서 사용된 style은 외부에 영향을 주지 않도록 하면서 자유롭게 작업이 가능하다. 처음 이 방법을 적용했을 때 <code>&#x3C;script></code> 태그의 실행이 되지 않아 별도 처리가 필요했다.(마지막 방식을 적용해면서, 다시 해보면 될 것 같다는 생각을 했다.) 그리고 다음 방법을 적용해봤다.\n아래처럼 React에 shadow DOM을 만들어주는 component를 만들고 필요한 곳에서 가져다 사용하도록 했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token operator\">&lt;</span>ShadowDom html<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>outer_html<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre></div>\n<p>두 번째는 <code>dangerouslySetInnerHTML</code>를 상용해서 코드를 그대로 표시할 DOM하위에 추가하는 것이었다. 물론 위에서 언급한 것 처럼 style의 중첩 등이 발생할 수 있지만 내부에서 진행한데다 크게 문제되지 않을 것 같다는 판단에 간단한 방법으로 처리했다. 위와 비슷한 정도지만 <code>ShadowDom</code> 컴포넌트를 사용하지 않는다는 점이 다르다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token operator\">&lt;</span>div dangerouslySetInnerHTML<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> __html<span class=\"token punctuation\">:</span> outer_html <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre></div>\n<p>하지만 여기에도 문제가 하나 있었다. 동일하게 CSR(Client Side Rendering)시에 외부 페이지에 있는 <code>&#x3C;script></code>가 실행되지 않는 것이었다. 하지만 SSR(Server Side Rendering)시에는 정상적으로 실행이 되고 있었다. 원인을 찾다가 알게 된 것들을 정리해 본다. (대부분 보안상의 이유로, 정확한 내용들은 찾아보면 금방 알 수 있다.)</p>\n<blockquote>\n<ol>\n<li>innerHTML로 추가하면 script는 동작하지 않는다.</li>\n<li>script태그에 dangerouslySetInnerHTML로 스크립트를 입력하면 동작하지만, DOM을 추가하면 그 내부의 스크립트는 실행되지 않는다.</li>\n<li>동적으로 추가한 DOM 내부의 script를 수행하려면 <code>createContextualFragment</code>라는 것을 사용하면 된다.</li>\n</ol>\n</blockquote>\n<p>세 번째는 위에서 알게 된 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Range/createContextualFragment\">createContextualFragment</a>를 사용하는 것이었다. 아직 정확한 내용은 파악하지 못했지만 비슷한 상황에서 사용하면 된다는 <a href=\"https://github.com/facebook/react/issues/8838#issuecomment-348860974\">내용</a>을 보고 적용해 봤다. 리액트에 적용하는 것이어서 마운트 된 이후에 처리되도록 <code>useEffecrt</code>내에서 적용헀다. <code>containerRef</code>는 코드를 추가하기 위해 미리 만들어 둔 element의 reference이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> range <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createRange</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> containerEl <span class=\"token operator\">=</span> containerRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>containerEl<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  range<span class=\"token punctuation\">.</span><span class=\"token function\">selectNode</span><span class=\"token punctuation\">(</span>containerEl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> fragment <span class=\"token operator\">=</span> range<span class=\"token punctuation\">.</span><span class=\"token function\">createContextualFragment</span><span class=\"token punctuation\">(</span>outer_html<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  containerEl<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>fragment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>web API인데다 사용하는 코드들도 발견했고 호환성도 충분한 듯해서 적용했고 동작도 정상적으로 됐다. 허나 고려하지 못한 부분이 하나 있었다. 외부 코드를 추가하는 페이지를 정적파일을 생성해서 서비스하고 있다는 것이었다. 마운트 된 이후에 DOM을 추가하다보니 SSR시에는 서버에서 빈페이지를 보내는데 이 결과가 정적파일로 만들어지고 있기 때문에 굳이 정적파일로 서비스하는 의미가 없어진 것이다. 그래서 SSR과 CSR을 구분해서 처리할 필요가 있었다. 그래서 SSR시에는 두 번째 방법을 유지하고 CSR시에는 마운트 이후에 해당 DOM을 제거하고 세 번째 방법으로 새로 추가하는 것이다. 적용하고 동작하는 것은 확인까지 했으나 아직 확실하게 파악하지 못한데다 곧 실서비스가 되어야 하는 상황에 좀 더 안전한 방법을 찾았다.</p>\n<p>마지막으로는 좀 더 간단하게 방법을 찾았다. 문제가 되는 부분은 해당 CSR시 DOM의 <code>&#x3C;script></code>태그가 실행이 되지 되지 않는다는 것이다. (SSR시에는 server에서 이미 DOM에 포함되어 내려오기 때문에 브라우저 입장에서는 원래 있는 \u001d코드와 다르지 않기 때문에 정상적으로 실행되는 것이다.) 그래서 단순히 CSR시에 해당 마운트 된 이후에 DOM에 있는 script를 수동으로 호출해 주면 해결될 수 있었다.(좀 더 복잡한 상황에서는 어떨지 모르겠다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> containerEl <span class=\"token operator\">=</span> containerRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>containerEl<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> scripts <span class=\"token operator\">=</span> containerEl<span class=\"token punctuation\">.</span><span class=\"token function\">getElementsByTagName</span><span class=\"token punctuation\">(</span><span class=\"token string\">'script'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> script <span class=\"token keyword\">of</span> scripts<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    window<span class=\"token punctuation\">.</span><span class=\"token function\">eval</span><span class=\"token punctuation\">(</span>script<span class=\"token punctuation\">.</span>innerHTML<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">...</span>\n<span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div\n      ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>containerRef<span class=\"token punctuation\">}</span>\n      dangerouslySetInnerHTML<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> __html<span class=\"token punctuation\">:</span> outer_html <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>useEffect에서 CSR인 경우에 <code>containerRef</code>의 하위에 있는 script를 찾아서 <code>eval</code>을 호출해 주는 것으로 실행해주는 효과를 본다.(eval 대신 new Function(script)를 실행할 수도 있다.)</p>\n<p>최종적으로 적용해 놓고 보니 생각보다 간단한 방법인데 돌고 돌아 왔다는 생각이 들었다. 물론 삽질로 많이 배우듯이 짧은 시간 그 과정에서 많은걸 알게 되었기 때문에 좋은 경험이었다. 아직 좀 더 다양한 경우와, 정확하게 이해를 하지 못해 부족한 부분이 있을 수도 있겠지만 일단은 동작은 충분했고, 결과는 곧 나올 예정이다.</p>\n<p>어느 덧 2019년이 지나고 2020년도 빠르게 지나고 있다. 하루라도 빨리 2019년의 회고를 작성하고 싶지만 워낙 바쁜데다 급하게 작성하고 싶지 않아, 조금 더 뒤로 미루기로 했다. 어서 프로젝트가 잘 마무리되고 여유가 생겨서 찬찬히 돌아볼 수 있는 시간을 가질 수 있었으면 좋겠다.</p>","fields":{"slug":"/dev/include-outer-html/"},"frontmatter":{"date":"2020/01/06","title":"리액트에 외부에서 만든 웹페이지 삽입하기","description":"외부 웹페이지 로딩 & 자바스크립트 실행하기","tags":["react","js","dangerouslySetInnerHTML","createContextualFragment","eval"]}}},{"node":{"excerpt":"웹 페이지들을 개발하다 보면 외부 라이브러리를 비롯한 여러 js…","html":"<p>웹 페이지들을 개발하다 보면 외부 라이브러리를 비롯한 여러 js파일들을 포함시켜야하는 경우가 많다. 크기가 작은 파일들은 문제가 되지 않을 수도 있지만, 조금이라도 웹의 성능을 높이기 위해서는 목적에 따라 로드하고 실행하는 시점을 다르게 가져가야 할 필요가 있다. 사용 목적에 따라 js 파일을 포함하는 방법을 정리해 본다.</p>\n<h2>1. 최우선으로 로드되어야 하는 경우</h2>\n<p>일반적으로 <code>&#x3C;script></code>태그로 포함된 js파일은 기술된 순서대로 로드가 된다. 문서를 파싱하는 과정에서 script 태그를 만나면 파싱을 멈추고 스크립트를 로드하고 실행한 후에 이어간다. 따라서 그 만큼 지연이 생기된다. 보통 렌더링 보다는 기능적인 부분을 담당하는 경우가 많을 것으로 예상되지만, 경우에 따라 웹페이지 로드보다 우선해서 실행되어야 한다면 이 스크립트는 <code>&#x3C;head></code>내에 정의하면 된다. 아래의 예를 보면 스크립트를 다운로드하고 실행하기 전까지 아래에 있는 내용이 화면에 표시되지 않는다. 즉, 그만큼 사용자에 대한 응답시간이 길어지게 되는 셈이다. 꼭 필요한 상황이 아니라면 다음에 나오는 방식으로 상황에 따라 적절한 지연으로 웹페이지 성능을 올려보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>head<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>script src<span class=\"token operator\">=</span><span class=\"token string\">'https://external_script.js'</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>head<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>body<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span>스크립트 실행 후에 보이는 내용<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>body<span class=\"token operator\">></span></code></pre></div>\n<h2>2. 웹 페이지 로드 전까지 지연 시키기</h2>\n<p>고전적인 방식으로 <code>&#x3C;head></code> 대신 <code>&#x3C;body></code>태그의 마지막에 <code>&#x3C;script></code>태그를 추가하게 되면 html 파싱이 완료된 후에 js의 로딩 및 실행이 이뤄진다. 따라서 병목없이 웹 페이지를 해석하고 빠르게 보여주게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>body<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>script src<span class=\"token operator\">=</span><span class=\"token string\">'https://external_script.js'</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>body<span class=\"token operator\">></span></code></pre></div>\n<p>이 방법은 오래됐지만 그 만큼 브라우저 호환 걱정 없이 효과적으로 사용할 수 있다. 굳이 빠르게 로드할 필요가 없는 파일이라면 이렇게만 해도 충분히 효과를 볼 수 있다. 하지만 위의 경우와 반대로 html을 모두 파싱하고 난 후에야 js파일이 로드되기 때문에 사용자와 인터랙션을 담당하는 역할을 하는 등의 스크립트라면 처음 그려지는 것만 빠를 뿐 반응 자체는 동일하게 딜레이가 생기게 된다. 인터넷이 빠른 환경에서는 괜찮지만 그렇지 않은 환경에서는 여전히 문제가 될 수 있다.</p>\n<h2>3. <code>defer</code> 다운은 빠르게 실행은 순서대로</h2>\n<p><code>&#x3C;script></code>태그에 <code>defer</code> 속성을 사용하게 되면 파싱을 멈추지 않고 다운로드와 병행하게 된다. 이후 해석이 완료되고 <code>DOMContentLoaded</code> 이벤트 발생 전에 스크립트를 <code>순서대로</code> 실행한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>head<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>\ndocument<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'DOMContentLoaded'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"defer 스크립트 실행 후 호출\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>script defer src<span class=\"token operator\">=</span><span class=\"token string\">'https://external_script.js'</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>head<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>body<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span>스크립트 실행 전에 보인다<span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>body<span class=\"token operator\">></span></code></pre></div>\n<p>위의 코드에서는 아래 script 태그를 만나도 파싱이 그래도 이어지면서 다운로드를 받고, 파싱이 완료된 후에 스크립트를 실행한다. 그리고 나서 alert가 표시된다.\n만약 스크립트가 두 개 이상 포함된다면 브라우저는 병렬적으로 스크립트를 다운로드 받는다. 그렇게 되면 순서에 상관없이 크기가 작은 스크립트의 다운로드가 먼저 완료된다. 하지만 실행 자체는 기술된 순서대로 이루어 진다. 즉 실행순서에 의존적인 스크립트들을 포함해야 한다면 <code>defer</code>를 사용하면된다. 주의할 점은 defer는 외부 스크립트에만 사용할 수 있다는 점이다.(src 속성이 없는 스크립트에서는 무시된다.)</p>\n<h2>4. <code>async</code> 비동기로 다운 받고 바로 실행</h2>\n<p><code>async</code>속성을 주면 defer와 다르게 순서에 의존적이지 않고 <code>DOMContentLoaded</code> 이벤트와도 서로 의존적이지 않게 의미 그대로 비동기적으로 스크립트를 실행한다. 즉 파싱을 멈추지 않고 다운로드를 진행하고 다운이 완료된 스크립트를 바로 실행한다. 단, 실행하는 동안은 문서의 파싱이 멈추게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>script <span class=\"token keyword\">async</span> src<span class=\"token operator\">=</span><span class=\"token string\">'https://external_script_big.js'</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>script <span class=\"token keyword\">async</span> src<span class=\"token operator\">=</span><span class=\"token string\">'https://external_script_small.js'</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre></div>\n<p>위와 같은 경우에 defer라면 파싱이 모두 끝난 뒤에 <code>external_script_big.js</code>가 먼저 실행되고 이후 <code>external_script_small.js</code>가 실행된다. 하지만 async로 선언된 경우에는 크기가 작은 <code>external_script_small.js</code>가 먼저 다운로드가 끝나면 실행도 먼저 이루어진다.\n따라서 <code>async</code>는 다른 스크립트에 종속적이지 않고 실행 시점을 정확하게 알 필요가 없는 파일의 경우에 유용하게 사용할 수 있다(예를 들면 ga나 광고 같은 경우). 만약 비동기로 로드하되 순서대로 실행하고 싶다면 <code>async=fase(기본값 true)</code>를 사용할 수 있다.\n마찬가지로 외부 스크립트에만 적용된다.\n추가로 동적으로 element를 생성해서 추가하는 경우에는 <code>async</code>가 기본적으로 적용된다. 따라서 순서에 의존적으로 실행되어야 하는 경우에는 <code>async=false</code>를 명시적으로 선언해 주자.</p>\n<p>일반적으로 script가 <code>&#x3C;/body></code>앞에 존재하는 경우라면 <code>async</code>나 <code>defer</code>효과가 크지 않을 수 있다. 그 때 쯤이면 문서의 모든 파싱이 끝난 상태이기 때문에 지연시키는 것이 큰 의미가 없을 수 있기 때문이다. 그러나 head에 모아 두거나 동적으로 추가하는 경우라면 적절하게 지연시킬 필요가 분명히 있다.\n만약 다른 파일에 종속적이지 않고 DOM과 상관없이 실행되어도 괜찮다면 <code>async</code>를, DOM이 관련해 실행순서가 중요하다면 <code>defer</code>를 사용하면된다.<br>\n한 가지 주의할 점은 대부분의 브라우저를 지원하긴 하지만 모든 브라우저에서 지원하지 않는다는 점이다.(역시나 IE가 한 몫 한다)<br>\n만약 async와 defer가 모두 선언되어 있다면, <code>async > defer</code>의 순서로 적용이 된다. 즉 async가 지원되는 브라우저는 async로 동작하고 그렇지 않다면 defer로, 먄약 defer도 지원하지 않으면 동기적으로 스크립트를 실행하게 된다.</p>\n<p><strong>참고</strong><br>\n<a href=\"https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html#script\">async vs defer attributes - Growing with the Web</a><br>\n<a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element/script\">&#x3C;script> - HTML: Hypertext Markup Language | MDN</a><br>\n<a href=\"https://javascript.info/script-async-defer\">Scripts: async, defer</a></p>","fields":{"slug":"/dev/import-js-script/"},"frontmatter":{"date":"2019/12/22","title":"웹 페이지에 javascript 포함시키기","description":"외부 js파일을 로드하고 실행하는 여러가지 방법들","tags":["js","<script>","async","defer"]}}},{"node":{"excerpt":"…","html":"<p>웹의 성능을 올리는 데는 다양한 방법들이 있다. 렌더링을 최적화 하거나 리소스 크기를 최소화 한다. 그리고 가능하다면 리소스의 사용이나 로딩을 필요한 시점까지 연기하거나 비동기로 처리한다. 웹에서 사용하는 리소스들 중 많은 크기를 차지하는 것 중의 하나가 이미지이다. 아무리 최적화를 하고 크기를 줄이더라도 이미지 수가 어느정도 증가하면 로딩에 오랜 시간이 걸릴 수 밖에 없다. 이를 방지하기 위해 ATF<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> 영역만 먼저 로딩 하고 나머지는 필요한 시점에 로딩시키는 lazyloading을 많이 사용한다.</p>\n<p>웹에서 이미지를 lazyloading 시키는 방법도 여러가지가 있는데 구글 개발자 사이트(<a href=\"https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/?hl=ko\">이미지 및 동영상의 지연 로딩</a>)에 보면 관련된 설명을 개념부터 방법까지 친절하게 해주고 있다.</p>\n<p>이 중에서 적용이 쉽고 여러모로 편리한 <code>intersection observer</code>를 사용하는 방법을 정리해 본다.</p>\n<p><code>intersection observer</code>는 MDN(<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\">Intersection Observer</a>)에서 확인해도 되고, 구글에 검색하면 친절하게 설명되어 있는 글들이 많다. 간단히 설명하면 이름에서 알 수 있듯이 지정된 영역에 대해 교차(intersection) 했는지를 감지하고 해당 시점에 원하는 작업을 할 수 있게 해준다. 안타깝게도 모든 버전의 브라우저에서 지원하지 않고 특히 IE에서는 지원조차 하지 않는다. 다행히 W3C에서 <a href=\"https://github.com/w3c/IntersectionObserver/tree/master/polyfill\">polyfill</a>을 지원해 준다. 하지만 브라우저마다 동작이 조금씩 다를 수 있다고 하니 주의해서 사용하자.</p>\n<p><code>intersection observer</code> 사용을 위해서는 observer 객체를 생성하고 lazyloading을 적용할 이미지를 등록 시켜야 한다. 지정된 영역안으로 들어올 때 뿐 아니라 나갈 때도 callback이 호출되기 때문에 <code>isIntersecting</code> 값이 true일 때만 처리 하고, 로드한 후에는 감시할 필요가 없기 때문에 등록을 해제해 주어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Image</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> src <span class=\"token punctuation\">}</span><span class=\"token punctuation\">:</span> IProps</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> imgRef <span class=\"token operator\">=</span> useRef<span class=\"token operator\">&lt;</span>HTMLImageElement<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> observerRef <span class=\"token operator\">=</span> useRef<span class=\"token operator\">&lt;</span>IntersectionObserver<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>isLoad<span class=\"token punctuation\">,</span> setIsLoad<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">onIntersection</span><span class=\"token punctuation\">(</span>\n    <span class=\"token parameter\">entries<span class=\"token punctuation\">:</span> IntersectionObserverEntry<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    io<span class=\"token punctuation\">:</span> IntersectionObserver</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    entries<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">entry</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span>isIntersecting<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        io<span class=\"token punctuation\">.</span><span class=\"token function\">unobserve</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setIsLoad</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>observerRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      observerRef<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IntersectionObserver</span><span class=\"token punctuation\">(</span>onIntersection<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    imgRef<span class=\"token punctuation\">.</span>current <span class=\"token operator\">&amp;&amp;</span> observerRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>imgRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>img ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>imgRef<span class=\"token punctuation\">}</span> src<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>isLoad <span class=\"token operator\">?</span> src <span class=\"token punctuation\">:</span> placeHolder<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>전체 코드와 동작은 아래에서 확인할 수 있다. 눈으로 확인할 수 있도록 <code>threshold</code>를 0.5로 설정했다. 즉 이미지의 절반이 화면에서 나타날 때 로드된다. 스크롤을 천천히 내리면서 확인해보자.</p>\n<p><a href=\"https://codesandbox.io/embed/lazyloading-image-59dxt?autoresize=1&#x26;fontsize=14&#x26;module=%2Fsrc%2FImage.tsx\">https://codesandbox.io/embed/lazyloading-image-59dxt?autoresize=1&#x26;fontsize=14&#x26;module=%2Fsrc%2FImage.tsx</a></p>\n<p>위의 방식도 동작엔 문제가 없지만, 각 Image 컴포넌트 마다 <code>IntersectionObserver</code>를 생성하고 있다. 성능상 얼마나 큰 차이가 있을지는 벤치마킹을 해봐야겠지만 이미지가 많은 경우 매번 생성을 하는건 비효율 적으로 보인다. 따라서 전역적으로 하나만 두고 계속 사용하도록 수정하는 것이 좋아보인다.</p>\n<p>우선 observer를 컴포넌트 밖으로 분리하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Image</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> src <span class=\"token punctuation\">}</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> src<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>observer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      observer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IntersectionObserver</span><span class=\"token punctuation\">(</span>onIntersection<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    imgRef<span class=\"token punctuation\">.</span>current <span class=\"token operator\">&amp;&amp;</span> observer<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>imgRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> observer<span class=\"token punctuation\">:</span> IntersectionObserver <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>하지만 이렇게 하면 IntersectionObserver 생성시 사용한 <code>onIntersection</code> 함수는 첫번째 이미지 내부 함수기 때문에 다른 이미지들에 대해서는 제대로 동작하지 않는다. 따라서 onIntersection도 밖으로 분리한다. 이렇게 분리하다 보면 한가지 문제가 생긴다. <code>setIsLoad</code>는 컴포넌트의 내부에서만 사용가능하기 때문이다. 그래서 함수 외부에서도 호출가능한 방법을 찾아야 한다. 난 <code>CustomEvent</code>를 사용해서 처리했다. CustomEvent는 이름처럼 event를 직접 정의해서 사용할 수 있도록 해준다. 마찬가지로 모든 브라우저 버전에서 지원하지 않으니 주의하고, <a href=\"https://developer.mozilla.org/ko/docs/Web/API/CustomEvent/CustomEvent\">MDN</a>에서 IE에서 사용가능한 polyfill도 제공하니 확인 후 사용하자.\n<code>CustomEvent</code>는 이벤트 타입을 정한 후에 다른 이벤트와 동일하게 <code>addEventListener</code>를 통해 callback을 등록하고, <code>dispatchEvent</code> 호출하면서 해당 이벤트 타입의 객체를 전달하면서 이벤트를 발생시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Image</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> src <span class=\"token punctuation\">}</span><span class=\"token punctuation\">:</span> IProps</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//  ...</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">loadImage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setIsLoad</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">const</span> imgEl <span class=\"token operator\">=</span> imgRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">;</span>\n    imgEl <span class=\"token operator\">&amp;&amp;</span> imgEl<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token constant\">LOAD_IMG_EVENT_TYPE</span><span class=\"token punctuation\">,</span> loadImage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      imgEl <span class=\"token operator\">&amp;&amp;</span> imgEl<span class=\"token punctuation\">.</span><span class=\"token function\">removeEventListener</span><span class=\"token punctuation\">(</span><span class=\"token constant\">LOAD_IMG_EVENT_TYPE</span><span class=\"token punctuation\">,</span> loadImage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>img ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>imgRef<span class=\"token punctuation\">}</span> src<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>isLoad <span class=\"token operator\">?</span> src <span class=\"token punctuation\">:</span> placeHolder<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">let</span> observer<span class=\"token punctuation\">:</span> IntersectionObserver <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token constant\">LOAD_IMG_EVENT_TYPE</span> <span class=\"token operator\">=</span> <span class=\"token string\">'loadImage'</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">onIntersection</span><span class=\"token punctuation\">(</span>\n    <span class=\"token parameter\">entries<span class=\"token punctuation\">:</span> IntersectionObserverEntry<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    io<span class=\"token punctuation\">:</span> IntersectionObserver</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    entries<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">entry</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span>isIntersecting<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        io<span class=\"token punctuation\">.</span><span class=\"token function\">unobserve</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        entry<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span><span class=\"token function\">dispatchEvent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">CustomEvent</span><span class=\"token punctuation\">(</span><span class=\"token constant\">LOAD_IMG_EVENT_TYPE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>최종 코드와 동작은 아래에서 확인하자.</p>\n<p><a href=\"https://codesandbox.io/embed/image2-v7ii7?autoresize=1&#x26;fontsize=14&#x26;module=%2Fsrc%2FImage.tsx\">https://codesandbox.io/embed/image2-v7ii7?autoresize=1&#x26;fontsize=14&#x26;module=%2Fsrc%2FImage.tsx</a></p>\n<p>처음 lazyloading을 구현할 땐 라이브러리도 고려해보고 방법도 많이 찾아봤었다. 그리고 지금은 위의 방법과 비슷하게 직접 구현해서 사용하고 있다. 코드양은 얼마 되지 않지만 결과를 내는데 까지 적지 않은 시간과 노력을 들였고 그만큼 결과적으로 만족스럽다. (뭐든지 처음이 어렵지…) 조금 더 나은 웹을 위해 하나씩 더 알아가보자.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>Above-The-Fold의 약자로 가판대에 접혀있는 신문의 보이는 영역을 의미하는데서 시작되었다. 사용자가 처음 진입했을 때 보이는 기본 영역을 의미한다. (참고: <a href=\"https://m.blog.naver.com/PostView.nhn?blogId=beusable&#x26;logNo=220887404946&#x26;proxyReferer=https%3A%2F%2Fwww.google.com%2F\">Above the Fold란?</a>)</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","fields":{"slug":"/dev/react-lazyimage/"},"frontmatter":{"date":"2019/10/06","title":"react lazyloading 이미지 컴포넌트 구현하기","description":"intersection observer와 CustomEvent 사용기","tags":["react","lazyload","image","intersection-observer"]}}},{"node":{"excerpt":"개발을 하다보니 너무나 당연하게도 git을 사용한다. 처음부터 git을 cli로만 사용하다보니 Sourcetree나 Tower 같은 GUI client를 사용하는 것보다 직접 타이핑 하는게 오히려 더 편하게 느껴진다. 하지만 cli…","html":"<p>개발을 하다보니 너무나 당연하게도 git을 사용한다. 처음부터 git을 cli로만 사용하다보니 <a href=\"https://www.sourcetreeapp.com/\">Sourcetree</a>나 <a href=\"https://www.git-tower.com\">Tower</a> 같은 GUI client를 사용하는 것보다 직접 타이핑 하는게 오히려 더 편하게 느껴진다. 하지만 cli 특성상 타이핑이 많거나 반복되는 경우가 생긴다. 게으름이 기술의 발전을 이끈다고 하던가… 귀차니즘이 너무 심해질 때 마다 하나씩 해결했던 방법들을 몇가지 정리해 본다.</p>\n<h2>1. checkout의 귀차니즘</h2>\n<p>작업을 하다보면 새로 만들거나 혹은 리뷰를 위해 다른 브랜치를 pull 하거나 등등으로 여러 브랜치 사이를 이동하는 경우는 흔한 일이다. 그러나 브랜치명이 길다면 매번 입력하는건 여간 귀찮은 일이 아니다. 사실 <a href=\"https://ohmyz.sh/\">Zsh</a>을 사용하고 있어 탭과 방향키 만으로 브랜치를 선택할 수는 있지만 순간 손을 이동해야 한다. 타이핑을 하다가 방향키로 손을 움직이는 것도 번거로워 진 시점에 현재 로컬의 브랜치들의 리스트를 보여주고 번호 입력으로 checkout을 하는 python script(<a href=\"https://github.com/nukeguys/utils\">github</a>)를 작성했었다.\n이외에도 python으로 일에 필요한 것들을 작성했었는데 지금은 사용하지 않고 있다. 동작은 아래에서 확인 할 수 있다.</p>\n<p><a href=\"https://asciinema.org/a/270031\"><img src=\"https://asciinema.org/a/270031.svg\" alt=\"asciicast\"></a></p>\n<h2>2. alias 설정하기</h2>\n<p>option으로 command 자체가 길어지거나, 빈번하게 command를 연속해서 입력해야 하는 경우에는 축약하거나 한 번에 처리하고 싶어진다. 이런 경우에는 <a href=\"https://git-scm.com/book/ko/v2/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-Git-Alias\">alias</a>를 설정할 수 있다. 간단한 git command 부터 bash 함수까지 실행이 가능하기 때문에 생각보다 많은 것들이 가능해진다.</p>\n<p>내가 처음 사용했던건 log를 좀 더 이쁘게 보기 위한 alias 였다. 이후에 사용하면서 필요하다 싶은 것들을 하나씩 추가했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>alias<span class=\"token punctuation\">]</span>\n\ts <span class=\"token operator\">=</span> status\n\ta <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>git <span class=\"token function\">add</span> <span class=\"token builtin class-name\">.</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">git</span> status\n\tau <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>git <span class=\"token function\">add</span> -u <span class=\"token builtin class-name\">.</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">git</span> status\n\taa <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>git <span class=\"token function\">add</span> <span class=\"token builtin class-name\">.</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">git</span> <span class=\"token function\">add</span> -u <span class=\"token builtin class-name\">.</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">git</span> status\n\tc <span class=\"token operator\">=</span> commit\n\tcm <span class=\"token operator\">=</span> commit -m\n\tca <span class=\"token operator\">=</span> commit --amend <span class=\"token comment\"># careful</span>\n\tac <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>git <span class=\"token function\">add</span> <span class=\"token builtin class-name\">.</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">git</span> commit\n\tacm <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>git <span class=\"token function\">add</span> <span class=\"token builtin class-name\">.</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">git</span> commit -m\n\tl <span class=\"token operator\">=</span> log --graph --all --pretty<span class=\"token operator\">=</span>format:<span class=\"token string\">'%C(yellow)%h%C(cyan)%d%Creset %s %C(white)- %an, %ar%Creset'</span>\n\tll <span class=\"token operator\">=</span> log --stat --abbrev-commit\n\tlg <span class=\"token operator\">=</span> log --pretty<span class=\"token operator\">=</span>format:<span class=\"token string\">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an>%Creset'</span> --abbrev-commit\n\tllg <span class=\"token operator\">=</span> log --color --graph --pretty<span class=\"token operator\">=</span>format:<span class=\"token string\">'%C(bold white)%H %d%Creset%n%s%n%+b%C(bold blue)%an &lt;%ae>%Creset %C(bold green)%cr (%ci)'</span> --abbrev-commit\n\td <span class=\"token operator\">=</span> <span class=\"token function\">diff</span>\n\tlgdiff <span class=\"token operator\">=</span> <span class=\"token string\">\"!f() { git log --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an>%Creset' --abbrev-commit <span class=\"token variable\">$1</span>..<span class=\"token variable\">$2</span>;}; f\"</span>\n\tlgraph <span class=\"token operator\">=</span> log --graph --pretty<span class=\"token operator\">=</span>format:<span class=\"token string\">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an>%Creset'</span> --abbrev-commit\n\tbranch-name <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>git rev-parse --abbrev-ref HEAD\n\tpublish <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>git push -u origin <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">git</span> branch-name<span class=\"token variable\">)</span></span>\n\trm-remote <span class=\"token operator\">=</span> <span class=\"token string\">\"!f() { git push origin --no-verify :<span class=\"token variable\">$1</span>; }; f\"</span>\n\trb <span class=\"token operator\">=</span> <span class=\"token string\">\"!f() { git branch -D <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">git</span> branch <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> -E $1<span class=\"token variable\">)</span></span>; }; f\"</span>\n\trt <span class=\"token operator\">=</span> <span class=\"token string\">\"!f() { git tag -d <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">git</span> tag -l $1<span class=\"token variable\">)</span></span>; }; f\"</span>\n\trrt <span class=\"token operator\">=</span> <span class=\"token string\">\"!f() { git push origin --no-verify -d <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">git</span> tag -l $1<span class=\"token variable\">)</span></span>; }; f\"</span>\n\taliases <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>git config --list <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token string\">'alias<span class=\"token entity\" title=\"\\\\\">\\\\</span>.'</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> <span class=\"token string\">'s/alias<span class=\"token entity\" title=\"\\\\\">\\\\</span>.<span class=\"token entity\" title=\"\\\\\">\\\\</span>([^=]*<span class=\"token entity\" title=\"\\\\\">\\\\</span>)=<span class=\"token entity\" title=\"\\\\\">\\\\</span>(.*<span class=\"token entity\" title=\"\\\\\">\\\\</span>)/<span class=\"token entity\" title=\"\\\\\">\\\\</span>1<span class=\"token entity\" title=\"\\\\\">\\\\</span><span class=\"token entity\" title=\"\\t\">\\t</span> => <span class=\"token entity\" title=\"\\\\\">\\\\</span>2/'</span> <span class=\"token operator\">|</span> <span class=\"token function\">sort</span>\n\tcb <span class=\"token operator\">=</span> <span class=\"token string\">\"!f() { git checkout -b feature/KG-<span class=\"token variable\">$1</span>-<span class=\"token variable\">$2</span>; }; f\"</span></code></pre></div>\n<p>아래는 내가 가장 빈번하게 사용하는 alias들이다.<br>\n<code>publish</code> - remote에 현재 브랜치 push<br>\n<code>rb</code> - 정규식에 매핑되는 로컬 브랜치 삭제 / <code>rm-remote</code> - remote 브랜치 삭제<br>\n<code>cb</code> - 특정 포맷에 맞게 브랜치 생성 / <code>ca</code> - commit —amend 줄여쓰기<br>\n<code>ac</code> - add, commit 한 번에 하기 / <code>lg</code> - log 이쁘게 보기</p>\n<p>등록된 alias들이 기억나지 않을 땐 <code>git aliases</code>를 통해 list 확인이 가능하다. 구글링하면 유용한 alias들이 많으니 자신이 자주 사용하는 것들을 등록하고 사용하면 생각보다 많이 편리하다.</p>\n<h2>3. commit message에 이슈 번호 자동 입력하기</h2>\n<p>commit message는 어느정도 가이드라인을 지켜주는게 이력들을 볼 때 편하다. 하지만 매번 기억하기는 어렵기 때문에 commit시 템플릿을 사용하도록 설정해 놓으면 잊지 않고 지킬 수 있다. template 설정도 alias처럼 config 파일에 직접 추가하거나 <code>git config --global commit.template ~/.gitmessage.txt</code> command를 사용할 수 있다.(global 옵션을 사용하지 않으면 repository별로 설정도 가능하다.) 난 개인적으로 <a href=\"https://chris.beams.io/posts/git-commit/\">How to Write a Git Commit Message</a>를 참고해서 아래와 같은 template을 사용하고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># &lt;type>: (If applied, this commit will...) &lt;subject> (Max 50 char)</span>\n<span class=\"token comment\"># |&lt;----  Using a Maximum Of 50 Characters  ---->|</span>\n<span class=\"token punctuation\">[</span>ISSUE-NUMBER<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># Explain why this change is being made</span>\n<span class=\"token comment\"># |&lt;----   Try To Limit Each Line to a Maximum Of 72 Characters   ---->|</span>\n\n\n<span class=\"token comment\"># Provide links or keys to any relevant tickets, articles or other resources</span>\nResolves: ISSUE-NUMBER\n\n<span class=\"token comment\"># --- COMMIT END ---</span>\n<span class=\"token comment\"># Type can be</span>\n<span class=\"token comment\">#    feat     (new feature)</span>\n<span class=\"token comment\">#    fix      (bug fix)</span>\n<span class=\"token comment\">#    refactor (refactoring production code)</span>\n<span class=\"token comment\">#    style    (formatting, missing semi colons, etc; no code change)</span>\n<span class=\"token comment\">#    docs     (changes to documentation)</span>\n<span class=\"token comment\">#    test     (adding or refactoring tests; no production code change)</span>\n<span class=\"token comment\">#    chore    (updating grunt tasks etc; no production code change)</span>\n<span class=\"token comment\"># --------------------</span>\n<span class=\"token comment\"># Remember to</span>\n<span class=\"token comment\">#    Capitalize the subject line</span>\n<span class=\"token comment\">#    Use the imperative mood in the subject line</span>\n<span class=\"token comment\">#    Do not end the subject line with a period</span>\n<span class=\"token comment\">#    Separate subject from body with a blank line</span>\n<span class=\"token comment\">#    Use the body to explain what and why vs. how</span>\n<span class=\"token comment\">#    Can use multiple lines with \"-\" for bullet points in body</span>\n<span class=\"token comment\"># --------------------</span></code></pre></div>\n<p>그런데 최근에 계속 작성을 하면서 issue 번호를 입력하는 부분이 너무 번거로웠다. 왜냐하면 기본적으로 branch 명에 이슈 번호를 포함해서 정해진 포맷으로 사용하고 있고(이것도 귀찮아서 만든게 <code>cb</code> alias다.) commit시 현재 브랜치명에서 issue 번호를 가져다 template을 자동으로 채워주면 좋겠다는 생각이 들었다.\n그래서 <code>prepare-commit-msg</code> hook을 작성했다. hook은 git workflow의 전후로 script를 실행할 수 있게 해준다. (설정 방법과 자세한 설명은 <a href=\"https://git-scm.com/book/ko/v2/Git%EB%A7%9E%EC%B6%A4-Git-Hooks\">Git - Git 훅</a>을 참고)\n직접 hook directory에 파일을 작성할 수도 있지만 <a href=\"https://github.com/typicode/husky\">husky</a>를 사용하면 hook을 좀 더 쉽게 관리할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">COMMIT_MSG_FILE</span><span class=\"token operator\">=</span><span class=\"token variable\">$1</span>\n<span class=\"token assign-left variable\">ISSUE_NUMBER_TAG</span><span class=\"token operator\">=</span><span class=\"token string\">'ISSUE-NUMBER'</span>\n\n<span class=\"token assign-left variable\">branch_name</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">git</span> rev-parse --abbrev-ref HEAD<span class=\"token variable\">`</span></span>\n<span class=\"token assign-left variable\">issue_number</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">{</span>branch_name<span class=\"token punctuation\">}</span> <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -n <span class=\"token string\">'s/^feature\\/\\(.*-[0-9]*\\)-.*/<span class=\"token entity\" title=\"\\1\">\\1</span>/p'</span><span class=\"token variable\">`</span></span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> -n <span class=\"token string\">\"<span class=\"token variable\">$issue_number</span>\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token function\">sed</span> -i <span class=\"token string\">\".bak\"</span> <span class=\"token string\">\"s/<span class=\"token variable\">${ISSUE_NUMBER_TAG}</span>/<span class=\"token variable\">${issue_number}</span>/g\"</span> <span class=\"token variable\">${COMMIT_MSG_FILE}</span>\n<span class=\"token keyword\">fi</span></code></pre></div>\n<h2>4. tig (text-mode interface for Git) 사용</h2>\n<p><a href=\"https://github.com/jonas/tig\">tig</a>는 텍스트 기반의 git client다. 따라서 terminal 벗어나지 않아도 되고 커스터마이징이 가능하기 때문에 잘만 사용하면 상당히 유용하다. (나도 간단하게만 사용하고 있는데 좀 더 활용을 해보고 나중에 다시 정리해봐야겠다.)\ntig 메뉴얼은 친절하게 한국어로 번역(<a href=\"https://ujuc.github.io/2016/02/10/tig-manual/\">[번역] Tig Manual</a>)된 것이 있으니 한 번 읽어보면 좋을 듯하다.</p>\n<p>이외에도 github 사용을 편하게 만들어주는 <a href=\"https://hub.github.com/\">hub</a>도 있고, 간단한 설정이나 script를 작성하면 cli를 사용하는 불편함들을 많이 제거할 수 있다.</p>","fields":{"slug":"/dev/easy-git/"},"frontmatter":{"date":"2019/09/21","title":"Git 사용 팁 정리","description":"git cli를 사용하다 생긴 귀차니즘 없애기","tags":["git","cli","git-hook","alias"]}}},{"node":{"excerpt":"웹에 페이스북 플러그인을 붙여놓게 되면 데이터는 페이스북에 쌓이게 되고 다시 가져올 수가 없다. (데이터를 추출해서 별도로 저장하면 법적인 문제가 생긴다고 한다.)\n그래서 페이스북 플러그인 대신 입맛에 맞게 UI…","html":"<p>웹에 페이스북 플러그인을 붙여놓게 되면 데이터는 페이스북에 쌓이게 되고 다시 가져올 수가 없다. (데이터를 추출해서 별도로 저장하면 법적인 문제가 생긴다고 한다.)\n그래서 페이스북 플러그인 대신 입맛에 맞게 UI를 변경하고 싶을 때는 페이스북에서 제공하는 <a href=\"https://developers.facebook.com/docs/graph-api?locale=ko_KR\">그래프 API</a>를 사용해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">https://graph.facebook.com/{object-id}/comments\nor\nhttps://graph.facebook.com/comments?id={object-id}</code></pre></div>\n<p>여기서 문제는 가져올 페이지의 <code>object-id</code>가 필요하다는 것이다.\n별도로 알 수 있는 방법이 없어서(찾지 못했다…) 직접 찾아내야 한다. 플러그인에서 댓글의 작성시간을 누르면 새로운 페이지가 나오는데 여기에서 주소표시줄을 보면 <code>fb_comment_id</code>가 아래의 예시처럼 보인다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&amp;fb_comment_id=1234567890123456_2197257797049450</code></pre></div>\n<p>여기서 <code>_</code> 앞에 있는 <code>1234567890123456</code> 이 부분이 api 호출에 사용 할 <code>object-id</code>이다. 단순 하나라면 이정도면 충분하다. 하지만 플러그인이 붙어 있는 페이지가 수십 수백개가 넘는다면 일일히 손으로는 불가능하기 때문에 자동화를 할 필요가 생긴다.\b</p>\n<p>위에서 말한 것 처럼 댓글의 작성일자를 눌렀을 때 <code>object_id</code>가 포함된 경로로 이동되기 때문에, 댓글의 작성일자 태그의 속성을 꺼내오면 될 것 같다. 그래서 간단히 해당 페이지를 긁어서 출력해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> urllib<span class=\"token punctuation\">.</span>request <span class=\"token keyword\">import</span> urlopen\n\nurl <span class=\"token operator\">=</span> <span class=\"token string\">'...'</span>\nhtml <span class=\"token operator\">=</span> urlopen<span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>html<span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>정작 댓글 내용은 보이지 않는다. 이유는 플러그인이 javascript가 실행되어야 하는데 request는 javascript 실행을 하지 못하기 때문이다. 코드를 조금 살펴보면 플러그인인 페이지에 iframe으로 추가되는 것을 알 수 있다. 그래서 iframe의 경로(<code>https://www.facebook.com/plugins/feedback.php?app_id=...</code>)로 다시 한 번 들어가 보면 정확하게 플러그인만 보이는 페이지가 나온다.</p>\n<p>이 페이지를 긁어서 다시 출력해보면 역시나 댓글이 렌더링된 코드들이 보이지 않는다. 이 페이지에서도 로딩된 이후에 javascript를 통해 댓글을 렌더링 하고 있기 때문이다.(코드상 <code>requireLazy</code> 함수가 관련 있는 것으로 추측된다.)</p>\n<p>그래서 렌더링이 될 때까지 기다려야 하는데 이를 위해서 <a href=\"https://miyakogi.github.io/pyppeteer/\">pyppeteer</a>를 사용한다. <code>pyppeteer</code>는 google에서 만든 headless chrome을 사용할 수 있게 해주는 node.js 라이브러리인 <a href=\"https://pptr.dev/\">puppeteer</a>를 python으로 porting한 모듈이다.\n(대신 <a href=\"https://www.seleniumhq.org/\">Selenium</a>을 사용 할 수도 있다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> pyppeteer <span class=\"token keyword\">import</span> launch\n\nurl <span class=\"token operator\">=</span> <span class=\"token string\">'...'</span>\nbrowser <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> launch<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\npage <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> browser<span class=\"token punctuation\">.</span>newPage<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span>goto<span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span>waitForSelector<span class=\"token punctuation\">(</span><span class=\"token string\">'.pluginSkinLight'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'timeout'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\nbodyHTML <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span>evaluate<span class=\"token punctuation\">(</span><span class=\"token string\">'() => document.body.innerHTML'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>bodyHTML<span class=\"token punctuation\">)</span></code></pre></div>\n<p>대략 위처럼 테스트해서 코드를 살펴보면 원하던 댓글들이 렌더링되어 있는 것을 볼 수 있다. 여기서 작성 시간에 있는 href만 찾아내면 된다.</p>\n<p>가져온 html을 <a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/\">Beautiful Soup</a>으로 파싱하면 손쉽게 원하는 태그에서 속성들을 추출할 수 있다.</p>\n<p>하지만 잠시 wait하지 않던 코드를 살펴보자. <code>waitForSelector</code> 부분만 주석처리하고 출력된 코드를 보면, 댓글이 렌더링 되어 있지는 않지만 <code>script</code> 태그 안에 댓글들의 데이터가 얼핏 보인다. 그리고 혹시나 해서 object-id 값을 검색해보면 <code>targetFBID</code>라는 키로 값이 존재하는 것을 알 수 있다.</p>\n<p>즉, 렌더링 되는 것을 기다리지 않고 필요한 데이터는 미리 알 수가 있는 것이다.(플러그인이 react로 작성되어 있는데 사용하는 상태값들이 아닐까 싶다.) 해당 값을 단순 string 매핑으로 찾아 낼 수도 있으나, 코드를 보면 javascript 함수(handleServerJS) 안에서 파라미터로 넘어가는 json 객체안에 데이터들이 포함되어 있다. 따라서 이 부분을 추출해서 json 객체로 변환하면 필요한 다른 데이터들도 추출하기가 쉬워진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> pyppeteer <span class=\"token keyword\">import</span> launch\n<span class=\"token keyword\">import</span> json\n<span class=\"token keyword\">import</span> re\n\npattern <span class=\"token operator\">=</span> re<span class=\"token punctuation\">.</span><span class=\"token builtin\">compile</span><span class=\"token punctuation\">(</span><span class=\"token string\">r'handleServerJS\\(([^)]+)\\)'</span><span class=\"token punctuation\">)</span>\n\nbodyHTML <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> page<span class=\"token punctuation\">.</span>evaluate<span class=\"token punctuation\">(</span><span class=\"token string\">'() => document.body.innerHTML'</span><span class=\"token punctuation\">)</span>\np <span class=\"token operator\">=</span> pattern<span class=\"token punctuation\">.</span>search<span class=\"token punctuation\">(</span>bodyHTML<span class=\"token punctuation\">)</span>\nparam <span class=\"token operator\">=</span> json<span class=\"token punctuation\">.</span>loads<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>group<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nmeta <span class=\"token operator\">=</span> param<span class=\"token punctuation\">[</span><span class=\"token string\">'require'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">'props'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">'meta'</span><span class=\"token punctuation\">]</span>\n<span class=\"token builtin\">id</span> <span class=\"token operator\">=</span> meta<span class=\"token punctuation\">[</span><span class=\"token string\">'targetFBID'</span><span class=\"token punctuation\">]</span>\ncount <span class=\"token operator\">=</span> meta<span class=\"token punctuation\">[</span><span class=\"token string\">'totalCount'</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>간단히 정리한 코드기 때문에 자동화를 위한 입출력이나 예외처리, 속도를 조금 올리기 위해 asyncio등을 적용해주면 간단히 쓰기에는 충분해진다.</p>","fields":{"slug":"/dev/scrap-facebook-comment/"},"frontmatter":{"date":"2019/08/25","title":"페이스북 댓글 플러그인 스크래핑하기","description":"python + pyppeteer로 웹 스크래핑 맛 보기","tags":["acrapping","crawling","python","pyppeteer","facebook","comment"]}}},{"node":{"excerpt":"최근 작업을 하면서 react 성능에 대해 신경을 써야 할 상황이 생겼다. 아직 정확하게는 모르지만 대충 눈치, 코치, 감으로 chrome과 react의 developer tool…","html":"<p>최근 작업을 하면서 react 성능에 대해 신경을 써야 할 상황이 생겼다. 아직 정확하게는 모르지만 대충 눈치, 코치, 감으로 chrome과 react의 developer tool을 사용해서 성능을 측정하고 개선하는 작업을 했는데, 일단 이번엔 <code>React Developer Tools</code>을 사용해 성능을 측정하하고 개선하는 방법을 정리해본다.</p>\n<h2>성능 측정</h2>\n<p>우선 react와 browser의 렌더링 과정에 대해 간단히 알 필요가 있다. react는 DOM의 직접적인 변경을 방지하기 위해 virtual DOM을 사용하고 실제로 변경이 필요한 부분만 DOM에 반영함으로써 성능을 올린다. 브라우저는 변경이 발생하면 크게 두 과정을 필요에 따라 선택적으로 수행한다. DOM tree를 갱신하는 reflow(layout)와 이를 화면에 반영하는 repaint(painting)이다.(<a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Introduction_to_Layout_in_Mozilla#Basic_Data_Flow\">Introduction to Layout in Mozilla - Mozilla | MDN</a>)</p>\n<p>브라우저의 DOM에 변경을 가하는 reflow와 repaint도 당연히 성능에 영향이 크지만, react의 virtual DOM을 재계산하는 reconciliation(<a href=\"https://reactjs.org/docs/reconciliation.html\">Reconciliation – React</a>)과정도 생각보다 성능에 많은 영향을 미친다. 따라서 성능을 올리기 위해서는 이 모든 과정에 대한 고려가 필요하다. react의 reconciliation는 react developer tools를 통해 확인할 수 있고, reflow 및 repaint는 chrome의 developer tool을 통해 확인이 가능하다.</p>\n<h3>Highlight Updates</h3>\n<p>react는 컴포넌트의 state나 props가 변경되면 render를 수행하여 virtual DOM을 갱신한다. react의 developer tools에서 Highlight Updates 설정을 켜놓으면 interaction이 발생할 때 마다 리렌더링되는 컴포넌트의 테두리에 색이 변경되는 것을 볼 수 있다. 즉 변경될 필요가 없는데도 특정 부분의 테두리 색이 나타난다면 불필요한 컴포넌트 렌더링이 발생하고 있는 것이다.</p>\n<h3>Profiler</h3>\n<p>위의 방법은 눈으로 쉽게 확인 가능하지만 상세한 내용은 알 수 가 없다. 경우에 따라 보다 정확하고 자세한 내용을 알고 싶다면 profiler를 사용하면 된다. 기본적인 사용법은 profiler 패널에서 record 버튼을 누르고 원하는 interaction을 하거나 시간이 흐른 뒤에 stop을 누르면 그 사이에 발생한 렌더링에 대해 확인 할 수 있다.</p>\n<p><img src=\"https://reactjs.org/static/stop-profiling-45619de03bed468869f7a0878f220586-53c76.png\" alt=\"stop-profiling-45619de03bed468869f7a0878f220586-53c76.png\"></p>\n<h4>Flame Chart</h4>\n<p>prifiling이 끝나면 그 동안에 발생한 commit<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>별 flame chart를 보여준다. 각 commit은 패널의 우측 상단에서 표시가 되고 각 commit을 선택하면 해당 commit의 flame chart가 표시된다.</p>\n<p><img src=\"https://reactjs.org/static/commit-selector-bd72dec045515d59be51c944e902d263-8ef72.png\" alt=\"commit-selector-bd72dec045515d59be51c944e902d263-8ef72.png\"></p>\n<p>commit이 많이 표시되는 것은 측정 시간동안 DOM의 변경이 그 만큼 발생했다는 것이고, 바의 색과 높이는 렌더링 소용된 시간을 나타낸다. (높고 노란색일 수록 오래 걸렸다는 의미이다.)</p>\n<p>flame chart에서는 commit에서 각 컴포넌트들의 상태를 나타낸다. 바의 길이(너비)는 마지막 렌더링에 걸린 시간을 의미하고 색은 현재 commit에서 소요된 시간을 의미한다. (해당 컴포넌트와 자식컴포넌트를 포함한다.)</p>\n<p>아래 사진에서보면 <code>App</code>과 <code>HashRouter</code> 컴포넌트의 경우 렌더링에 많은 시간이 걸리고 있으나 회색이기 때문에 현재 commit에서는 렌더링이 발생하지 않았다는 것을 알 수 있고, <code>Router</code> 컴포넌트는 렌더링이 발생했고 대부분의 시간이 자식 컴포넌트인 <code>Nav</code>와 <code>Route</code> 렌더링에 소요된 것을 알 수 있다.</p>\n<p><img src=\"https://reactjs.org/static/flame-chart-3046f500b9bfc052bde8b7b3b3cfc243-53c76.png\" alt=\"flame-chart-3046f500b9bfc052bde8b7b3b3cfc243-53c76.png\"></p>\n<p>컴포넌트를 선택하면 이번 commit에서의 <code>state</code>나 <code>prpos</code>도 확인이 가능하고, 다른 commit을 선택하면 변경도 확인할 수 있어서 렌더링이 발생한 이유도 알 수 있다.</p>\n<h4>Ranked Chart</h4>\n<p>두 번째 ranked chart를 선택하면 현재 commit에서 렌더링이 오래걸린 순으로 컴포넌트를 정렬해서 확인 할 수 있다. 단, 자식 컴포넌트의 렌더링을 포함하기 때문에 표시되는 실제 오래걸리는 컴포넌트가 포함된 tree의 top이 표시될 수 있다는 점을 염두해야 한다.</p>\n<h4>Component Chart</h4>\n<p>전체 profiling 동안 특정 컴포넌트의 렌더링에 대해 알고 싶을 땐 component chart가 유용하다. 컴포넌트를 더블클릭하거나 오른쪽 x표시 옆에 있는 차트 모양 아이콘을 선택하면 볼 수 있다.</p>\n<p><img src=\"https://reactjs.org/static/component-chart-d71275b42c6109e222fbb0932a0c8c09-53c76.png\" alt=\"component-chart-d71275b42c6109e222fbb0932a0c8c09-53c76.png\"></p>\n<p>바의 수는 렌더링 된 횟수를 의미하고 각 바의 높이와 색은 각 commit에서 다른 컴포넌트에 비해 상대적으로 해당 컴포넌트가 렌더링되는데 걸린 시간을 의미한다. 바를 선택하면 자세한 내용을 볼 수 있고, 더블 클릭하거나 x를 누르면 이전 화면으로 돌아갈 수 있다.</p>\n<p>보다 상세한 사용법은 react 블로그를 참고하자. (<a href=\"https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html\">Introducing the React Profiler – React Blog</a>)</p>\n<h2>개선 하기</h2>\n<p>profiling 결과를 보다보면 특정 컴포넌트가 렌더링에 시간을 오래 소요하거나 렌더링할 필요가 없는 데도 commit마다 렌더링이 발생하는 경우가 있다. 이런 경우 해당 컴포넌트를 찾아서 불필요한 렌더링이 발생하지 않도록 개선할 필요가 있다.</p>\n<p>우선 렌더링이 발생하는 이유에 대해 생각해보자. react는 state나 props가 변경된 경우 컴포넌트의 변경이 발생할 것으로 예상하고 렌더링을 한다. 이 과정이 위에서 확인되는 렌더링 이다. 최종적으로 실제 DOM에 변경이 없다면 반영이 되지 않겠지만(이 부분은 다음에 정리할 내용에서 확인이 가능하다.) 이 자체만으로 경우에 따라 성능에 많은 영향을 주게 된다. 이 과정을 없애기 위해서는 react에게 렌더링을 할 필요가 없다는 것을 알려줄 필요가 있다. 예상했듯이 class형 컴포넌트에서는 <code>shouldComponentUpdate</code>를 사용하거나 <code>PureComponent</code>를 상속함으로서 미리 정의된 <code>shouldComponentUpdate</code>를 적용할 수 있다. function 컴포넌트에서도 비슷한 역할을 하는 <code>memo</code>라는 HOC가 존재한다.</p>\n<h3>React.memo</h3>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> MyComponent <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">memo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">MyComponent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/* render using props */</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 처럼 사용하면 <code>PureComponent</code> 처럼 shallow 한 비교를 직접 처리해준다. 하지만 좀 더 복잡하거나 예외적인 처리가 필요할 경우에는 두 번째 인자로 이전 props와 다음 props를 받아서 비교를 수행하는 함수를 전달할 수 있다. <code>shouldComponentUpdate</code>와 다른점이 있다면 반환값이 반대라는 점이다. 이름에서 알 수 있듯이 <code>shouldComponentUpdate</code>는 update여부를 반환하기 때문에 다른 경우에 true를 반환하지만 <code>areEqual</code>의 경우는 비교의 결과를 반환하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">MyComponent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/* render using props */</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">areEqual</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prevProps<span class=\"token punctuation\">,</span> nextProps</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/*\n  return true if passing nextProps to render would return\n  the same result as passing prevProps to render,\n  otherwise return false\n  */</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">memo</span><span class=\"token punctuation\">(</span>MyComponent<span class=\"token punctuation\">,</span> areEqual<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>대부분의 경우에는 추가적인 비교함수 없이 대응이 가능하다. 이 때 주의할 점은 shallow하게 비교하기 때문에 <code>immutable</code>한 데이터를 <code>props</code>로 사용해야 한다는 점이다. 즉, 실제 같은 데이터지만 렌더링 마다 새로운 객체를 생성해서 전달한다면 memo의 의미가 없어지게 되는 것이다.</p>\n<p>즉 부모 컴포넌트에서 <code>useMemo</code>나 <code>useCallback</code>을 사용해서 props를 전달하고 자식 컴포넌트에서 <code>memo</code>가 적용되어 있으면 손쉽게 불필요한 렌더링을 막을 수 있게 되는 것이다. (<a href=\"https://nukeguys.github.io/dev/react-hooks/\">react hooks 복습하기</a> 참고)</p>\n<p>그렇다면 <code>memo</code>는 항상 사용하는 것이 좋겠다는 생각을 할 수도 있다. 물론 대부분의 경우에는 효과를 볼 수도 있겠지만 <code>memo</code>도 내부적으로는 <code>useMemo</code>와 같이 동작을 하기 때문에 추가적인 비용이 들게 된다. 즉 매번(또는 빈번하게) 변경되는 컴포넌트에 적용하게 되면 렌더링은 그대로 유지되면서 추가적인 비용만 더 가중시키는 셈이다. 대표적으로 prpos로 <code>children</code>을 받아서 사용하는 컴포넌트를 들 수 있는데, 일반적으로 children은 매번 변경되거나 별도로 memoization을 하는 경우가 많지 않기 때문이다.</p>\n<p>그래서 일단 적용하지 않은 상태로 구현한 뒤에 propfiling을 통해 필요한 곳에 <code>memo</code>를 적용하는 것을 권장한다.</p>\n<p>이번엔 react development tool을 사용해서 렌더링 성능을 측정하고 개선하는 방법을 간단히 정리해봤다. 다음엔 browser의 렌더링 과정과 측정하는 방법을 정리해 볼 예정이다.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>react의 lifecyle은 크게 render와 commit으로 나뉜다. render를 수행한 후 변경된 사항을 DOM에 반영하는 과정이다.(<a href=\"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">React lifecycle methods diagram</a>)</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","fields":{"slug":"/dev/react-optimizing-performance/"},"frontmatter":{"date":"2019/08/04","title":"react dev tool로 성능 측정 해보기","description":"react 성능 측정 및 최적화","tags":["react","performance","developer tool","useMemo","useCallback","reconciliation","layout","repaint"]}}},{"node":{"excerpt":"Frontend를 시작한지 얼마 되지 않았지만 그 짧은 사이에도 크고 작은 것들이 많이 변화했다. 정말 빠르구나 싶기도 하고 그런게 나름 또 이 세계의 재미가 아닌가 싶기도 하다. React도 16.8이 릴리즈 되면서 hooks라는 api…","html":"<p>Frontend를 시작한지 얼마 되지 않았지만 그 짧은 사이에도 크고 작은 것들이 많이 변화했다. 정말 빠르구나 싶기도 하고 그런게 나름 또 이 세계의 재미가 아닌가 싶기도 하다.</p>\n<p>React도 16.8이 릴리즈 되면서 hooks라는 api가 새롭게 등장했다. 익숙해 지려고 할 때 쯤 새로운 놈이 등장해서 다시 또 적응을 해야했고 지금은 나름 열심히 사용하고 있긴하지만 이쯤에서 자주 쓰는 hooks에 대해 정리를 한 번 해볼까한다. (물론 틀린 내용이 있을 수 있고, 주관적인 생각이 포함되어 있을 수 있다.)</p>\n<p>우선 각 hook에 대해 정리하기 전에 hooks라는 이름에 대해 생각해 볼 필요가 있지 싶다. react 문서에서는 hook을 아래처럼 설명하고 있다.</p>\n<blockquote>\n<p>Hooks are functions that let you “hook into” React state and lifecycle features from function components. (<a href=\"https://reactjs.org/docs/hooks-overview.html#but-what-is-a-hook\">Hooks at a Glance – React</a>)</p>\n</blockquote>\n<p>state와 lifecycle을 <code>hook into</code>한다라는게 바로 와닿지는 않는다. 번역하면 연동한다/끌어드린다/밀어넣는다 정도로 될 듯하다.\nhook이라는 단어는 <code>web-hook</code>이나 <code>hooking</code>처럼 흔하게 사용되는 말로 중간에 동작을 가로챈다는 의미로 보는게 이해가 빠를 것 같다. 따라서 react의 hook도 lifecycle 과정에서 state와 관련된 동작을 수행 할 수 있도록 해준다는 의미로 이해하면 될 것 같다.</p>\n<h2>useState</h2>\n<p>class형 컴포넌트에서 <code>this.state</code>와 <code>setState</code>의 역할을 하는 hook이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> setState<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span>initialState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>공식문서에 나와있는 이전방식과 hook의 코드도 비교해보자.(<a href=\"https://reactjs.org/docs/hooks-state.html\">Using the State Hook – React</a>)</p>\n<p>하나의 객체가 아니라 필요한 state를 개별로 접근하고 변경할 수 있다는 점에서 관리와 사용이 훨씬 깔끔해진 느낌이다. <code>useState</code>를 사용할 때 주의해야 할 부분도 있다. 우선 class형 컴포넌트 안에서는 사용할 수 없고, setState와 다르게 merge가 아닌 replace된다는 점이다. 두 번째는 setter의 인자로 값이 아닌 함수를 전달할 수 도 있다는 점이다. count를 증가시키는 코드를 예로 보면 일반적으로 아래처럼 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">increaseCount</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>하지만 setCount를 비동기 callback에서 호출하는 경우에 원하는 대로 count가 증가하지 않는 경우를 경험할 수 있다. 이유는 callback 등록 시점에 함수가 생성되면서 count 값이 고정되어 버리기 때문이다. 처음에 같은 문제를 겪고 한참을 헤맸던 기억이 있다. 이런 경우에는 아래처럼 setCount에 함수(이전 state값을 받아서 새로운 state를 반환하는)를 전달하면 해결 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">increaseCount</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prevCount</span> <span class=\"token operator\">=></span> prevCount <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>물론 위의 경우처럼 단순하게 처리가 불가능한 경우가 있을 수도 있다. 또 state 뿐 아니라 props에 대해서도 동일한 문제가 발생할 수 있다. 그런 경우에는 state를 객체로 변경해서 사용하거나, <code>useRef</code>를 사용해 state 또는 props를 별도의 변수로 저장해서 접근해야 한다.</p>\n<p>추가로 useSate의 초기값으로도 함수를 전달할 수 있다. 이는 초기값 계산의 cost가 높은 경우에 초기화를 지연시키는 역할을 한다.</p>\n<h2>useRef</h2>\n<p>위에서 언급한 <code>useRef</code>도 간단히 정리해본다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> refContainer <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span>initialValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이름에서 유추 가능한 것 처럼, 원하는 값을 객체로 warraping해서 <code>current</code>라는 속성으로 접근할 수 있게 해준다. 보통 DOM의 reference를 담아두는데 사용하지만 class의 멤버 변수처럼 사용하는 것이 가능하다.</p>\n<p>어렵지 않지만 실제로 구현된 아래 코드를 보면 더 쉽게 이해가 된다. (<a href=\"https://github.com/facebook/react/blob/42b75ab007a5e7c159933cfdbf2b6845d89fc7f2/packages/react-reconciler/src/ReactFiberHooks.js#L856-L869\">ReactFiberHooks.js · GitHub</a>)</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> mountRef<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>initialValue<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> current<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">mountWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> ref <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> current<span class=\"token punctuation\">:</span> initialValue <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__DEV__<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">seal</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> ref<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> ref<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> updateRef<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>initialValue<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> current<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>최초에는 ref라는 객체를 만들어 current 속성에 초기값을 설정해서 반환하고, 이후부터는 해당 객체를 반환한다.</p>\n<p>참고로 react의 hooks는 <code>mountXXX</code>와 <code>updateXXX</code>라는 이름으로 최초 실행과 이후 업데이트에서 사용하는 함수가 각각 분리되어 구현 되어 있다.</p>\n<h2>useImperativeHandle &#x26; forwardRef</h2>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">useImperativeHandle</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">,</span> createHandle<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>deps<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code>useImperativeHandle</code>은 부모에게 원하는 interface를 통해 ref를 사용할 수 있게 해준다. 즉, 부모가 자식의 ref를 직접 받아서 접근할 수도 있지만, 제한하거나 커스터마이징해서 제공을 하고 싶을 때 사용하면 된다. <code>useImperativeHandle</code>은 <code>forwardRef</code>와 함께 사용해야 하는데 간단한 사용법은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">FancyInput</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props<span class=\"token punctuation\">,</span> ref</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> inputRef <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">useImperativeHandle</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">focus</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      inputRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">.</span><span class=\"token function\">focus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>input ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>inputRef<span class=\"token punctuation\">}</span> <span class=\"token operator\">...</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nFancyInput <span class=\"token operator\">=</span> <span class=\"token function\">forwardRef</span><span class=\"token punctuation\">(</span>FancyInput<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>useEffect</h2>\n<p><code>useState</code>와 더불어 가장 자주 사용하고 중요한 hook중의 하나이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span>didUpdate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>공식문서의 정의는 아래처럼 되어있다.</p>\n<blockquote>\n<p>The Effect Hook lets you perform side effects in function components.</p>\n</blockquote>\n<p>함수형 컴포넌트에서 <code>side effects</code>를 수행할 수 있게 해준다라는 의미가 바로 와닿지는 않는다. 그래서 문서를 조금 더 살펴보면 이런 내용도 있다.</p>\n<blockquote>\n<p>Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you’re used to calling these operations “side effects” (or just “effects”), you’ve likely performed them in your components before.</p>\n</blockquote>\n<p>즉, 컴포넌트 내부에서 수행하던 <code>data fetching</code>, <code>subscription(이벤트 등록/해제 같은)</code>, <code>manaual한 DOM변경</code> 등과 같은 state를 직접 처리하는 이외의 동작이나 기능들을 <code>side effect</code> 또는 <code>effect</code>로 부르고 있다.</p>\n<p><code>useEffect</code>가 중요한 이유 중의 하나는 react의 <code>lifecycle</code>과 밀접하게 관련이 있기 때문이다.\n기본적으로 렌더링이 완료된 이후에 실행 되는데 두번째 인자인 <code>deps</code>를 통해 실행 여부를 결정할 수 있기 때문에 class 컴포넌트에 있던 <code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>와 같은 lifecycle과 비슷한 역할을 할 수 있다.</p>\n<p>기존 방식과의 차이점은 문서를 확인하면 명확하게 알 수 있다.(<a href=\"https://reactjs.org/docs/hooks-effect.html\">Using the Effect Hook – React</a>)</p>\n<p><code>useEffect</code>에서 함수를 리턴할 수 있는데 이 함수는 다음 effect발생하기 전에 호출이 되기 때문에 메모리 정리나 구독해제 같은 기능을 처리할 수 있다. (<code>componentDidMount</code>에서 등록하고 <code>componentWillUnmount</code>에서 해제하는 것과 유사한 동작)</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> subscription <span class=\"token operator\">=</span> props<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    subscription<span class=\"token punctuation\">.</span><span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그런데 위의 코드를 수행하면 매 렌더링시마다 구독/해제가 일어나기 때문에 비효율적이다. 이런 문제를 해결하기 위해서 위에서 언급한 대로 두번째 인자로 <code>deps(dependencies)</code>를 전달할 수 있다. <code>deps</code>는 배열 형식으로 전달하고, 배열의 각 아이템을 shallow하게 비교해서 변경이 발생한 경우에만 effect가 실행된다. 위 코드처럼 전달하지 않으면 매번 실행이 되고, 빈배열(<code>[ ]</code>)을 전달하면 mount/unmount시에만 호출이 된다. 위 코드에서는 props의 source에 접근하고 있기 때문에 그 값이 변할 경우에만 구독/해제를 할 필요가 있다. 따라서 아래처럼 해주면 원하는 효과를 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> subscription <span class=\"token operator\">=</span> props<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    subscription<span class=\"token punctuation\">.</span><span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>props<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>여기서 주의할 점은, 컴포넌트 범위에서 변경될 수 있는 값(state나 props같은)을 누락하게 되면 원하는 동작을 하지 않을 수 있다는 점이다. 예로 위의 코드에서 deps에 []를 넣게 되면, props의 source가 변경되어도 구독은 계속 이전 source에 된 상태로 남아있게 된다.</p>\n<p><code>useEffect</code>에서 직접적인 접근이 없지만 호출하는 함수에서 변경되는 값이 존재하는 경우에도 마찬가지로 추가를 해줘야 하지만 쉽게 인지하기 어려울 수도 있기 때문에 react에서는 <code>eslint-plugin-react-hooks</code>의\n<a href=\"https://github.com/facebook/react/issues/14920\">exhaustive-deps</a> lint rule을 사용하는 것을 권장하고 있다.</p>\n<h2>useCallback</h2>\n<p>callback의 memoization을 만들어주는 hook이다. 즉, 매번 동일한 함수를 생성하는 것이 아니라 변경될 필요가 없는 경우 이전에 생성된 함수를 반환해주는 기능을 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> memoizedCallback <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code>useCallback</code>이 유용성은 react의 특성을 이해하면 알기 쉽다. 자식에게 callback을 전달하는 경우에 부모가 렌더링 되면서 매번 새로 생성된다면 자식입장에서는 props가 변경되기 때문에 함께 렌더링이 발생하게 되는 것이다. 이런 경우 사용하면 memoization된 callback을 전달함으로써 불필요한 렌더링을 방지할 수 있게 되는 것이다. 자식에서 <code>shouldComponentUpdate</code>를 통해 변경여부를 직접 비교해서 렌더링을 결정하는 효과를 간단히 볼 수 있게 된다. 마찬가지로 callback은 <code>deps</code>에 따라 변경여부를 결정하기 때문에 주의해서 사용할 필요가 있다.</p>\n<h2>useMemo</h2>\n<p><code>useCallback</code>이 memoization된 함수를 반환해 주었다면 <code>useMemo</code>는 memoization된 값을 반환해 준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> memoizedValue <span class=\"token operator\">=</span> <span class=\"token function\">useMemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">computeExpensiveValue</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code>deps</code>가 변경된 경우에만 전달된 함수를 호출하여 결과를 반환하기 때문에 cost가 많은 처리를 필요할 때만 수행하도록 할 수 있다. 주의할 점은 <code>useMemo</code>는 렌더링 중에 실행되기 때문에 계산이 아닌 <code>sideEffect</code>(위에서 언급한)를 수행하면 안된다는 것이다. 또한 이후 버전에서는 매번 재계산하는 방식을 택할 수도 있기 때문에 <code>useMemo</code>는 성능 최적화의 목적으로만 사용해야 한다.</p>\n<p>그 외에 <code>useContext</code>, <code>useReducer</code>, <code>useLayoutEffect</code> 등이 있지만 어렵지 않고 사용빈도도 많지 않기 때문에 생략한다. (공식문서를 보면 쉽게 이해할 수 있다.)</p>\n<p>추가로 <code>customHook</code>을 만들어 사용할 수도 있는데, 공식문서(<a href=\"https://reactjs.org/docs/hooks-custom.html\">Building Your Own Hooks – React</a>)를 보면 간단하게 방법을 알 수 있다. 유용한 custom hook은 <a href=\"https://usehooks.com/\">useHooks - Easy to understand React Hook recipes</a>를 참고하면 작성과 사용법을 아는데 도움이 된다.</p>\n<p>간단하게 hook의 내용과 사용법들을 정리해 봤다. 사실 각각 hook을 사용하면서 고민하거나 헤맸던 부분들에 대해서 정리를 하는게 목적이었으나 그 전에 간단히 기본적인 내용들을 먼저 정리해봤다. 이후에 시간이 되면 <code>useEffect</code>와 <code>useCallback</code>의 <code>deps</code>를 사용하면서 들었던 고민들이나 퍼포먼스를 올리기 위해 하고 있는 삽질들을 다시 한 번 정리해볼 예정이다.</p>","fields":{"slug":"/dev/react-hooks/"},"frontmatter":{"date":"2019/07/28","title":"react hooks 복습하기","description":"익숙할 때 쯤 정리해보는 react hooks","tags":["react","hooks","useState","useRef","useImperativeHandle","forwardRef","useEffect","useCallback","useMemo"]}}},{"node":{"excerpt":"Do’s and Don’ts General Types Number, String, Boolean, and Oject Don’t\nNumber, String, Boolean 또는 Object 타입을 절대 사용하지 마라. 이 타입들은 JavaScript…","html":"<h1>Do’s and Don’ts</h1>\n<h2>General Types</h2>\n<h3>Number, String, Boolean, and Oject</h3>\n<p><strong><em>Don’t</em></strong>\n<code>Number</code>, <code>String</code>, <code>Boolean</code> 또는 <code>Object</code> 타입을 절대 사용하지 마라. 이 타입들은 JavaScript 코드에서 대부분 적절하지 않게 사용되는 non-primitive boxed object<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>들을 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* WRONG */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">s<span class=\"token punctuation\">:</span> String</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong><em>Do</em></strong>\n<code>number</code>, <code>string</code> 그리고 <code>boolean</code>을 사용하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* OK */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">s<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code>Object</code> 대신 non-primitive인 <code>object</code> 타입을 사용하라 (<a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type\">TypeScript 2.2</a>에 추가됨).</p>\n<h4>Generic</h4>\n<p><strong><em>Don’t</em></strong>\n타입 매개변수를 사용하지 않는 generic 타입을 사용하지 마라. 더 자세한 내용은 <a href=\"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---\">TypeScript FAQ page</a>에서 확인.<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></p>\n<h2>Callback Types</h2>\n<h3>Return Types of Callbacks</h3>\n<p><strong><em>Don’t</em></strong>\n값이 무시될 콜백의 리턴타입으로 <code>any</code>를 사용하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* WRONG */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">x</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong><em>Do</em></strong>\n값이 무시될 콜백의 리턴타입으로 <code>void</code>를 사용하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* OK */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">x</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong><em>Why</em></strong>\n확인되지 않는 방법으로 <code>x</code>의 리턴타입을 사용하는 실수를 방지해주기 때문에 <code>void</code>를 사용하는 것이 더 안전하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">x</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> k <span class=\"token operator\">=</span> <span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// oops! meant to do something else</span>\n  k<span class=\"token punctuation\">.</span><span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// error, but would be OK if the return type had been 'any'</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Optional Paameters in Callbacks</h3>\n<p><strong><em>Don’t</em></strong>\n의도한 경우를 제외하고는 선택적 매개변수를 사용하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* WRONG */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Fetcher</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">getObject</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">done</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">data<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> elapsedTime<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이것은 매우 분명한 의미를 갖는다. : <code>done</code> 콜백은 1개 또는 2개의 매개변수를 가지고 호출된다. 작성자는 아마 콜백이 <code>elapsedTime</code> 매개변수에 대해 신경쓰지 않는다는 것을 의도했을 것이다. 그러나 그것을 위해 선택적 매개변수로 만들 필요는 없다. - 더 적은 매개변수를 받는 콜백을 전달하는 것은 언제나 적합하다.<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup></p>\n<p><strong><em>Do</em></strong>\n콜백의 파라미터를 필수(non-optional) 파라미터로 작성하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* OK */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Fetcher</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">getObject</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">done</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">data<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> elapsedTime<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Overloads and Callbacks</h3>\n<p><strong><em>Don’t</em></strong>\n콜백만 다른 별도의 타입 시그니처(overload)를 작성하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* WRONG */</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">beforeAll</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">action</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">,</span> timeout<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">beforeAll</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function-variable function\">action</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">done<span class=\"token punctuation\">:</span> DoneFn</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">,</span>\n  timeout<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong><em>Do</em></strong>\n모든 것을 포함하는 타입 시그니처 하나만 작성하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* OK */</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">beforeAll</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function-variable function\">action</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">done<span class=\"token punctuation\">:</span> DoneFn</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">,</span>\n  timeout<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong><em>Why</em></strong>\n콜백에서 매개변수를 무시하는 것은 언제나 적합하다.(역자:<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>과 같은 의미이다.) 따라서 더 간단한 타입 시그니처는 필요하지 않다. 간단한 타입 시그니처를 제공하는 것은 타입이 잘못된 함수가 첫번째 함수 시그니처와 매칭되어 전달되는 것을 허용한다.<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup></p>\n<h3>Function Overloads</h3>\n<h4>Ordering</h4>\n<p><strong><em>Don’t</em></strong>\n더 구체적인 시그니처 전에 일반적인 시그니처를 두지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* WRONG */</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> HTMLElement</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> HTMLDivElement</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> myElem<span class=\"token punctuation\">:</span> HTMLDivElement<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>myElem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// x: any, wat?</span></code></pre></div>\n<p><strong><em>Do</em></strong>\n더 구체적인 시그니처 다음에 일반적인 시그니처를 두도록 정렬하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* OK */</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> HTMLDivElement</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> HTMLElement</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> myElem<span class=\"token punctuation\">:</span> HTMLDivElement<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>myElem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// x: string, :)</span></code></pre></div>\n<p><strong><em>Why</em></strong>\nTypeScript는 함수 호출을 결정할 때 처음 매칭되는 시그니처를 서낵한다. 먼저 나오는 시그니처가 뒤의 시그니처보다 더 일반적일 경우, 뒤에 나오는 것은 완벽히 가려지고 호출될 수 없다.</p>\n<h3>Use Optional Parameters</h3>\n<p><strong><em>Don’t</em></strong>\n뒤에 나오는 매개변수들만 다른 경우 여러 시그니처를 작성하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* WRONG */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Example</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">diff</span><span class=\"token punctuation\">(</span>one<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">diff</span><span class=\"token punctuation\">(</span>one<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> two<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">diff</span><span class=\"token punctuation\">(</span>one<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> two<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> three<span class=\"token punctuation\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong><em>Do</em></strong>\n가능한 경우에는 선택적 매개변수를 사용하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* OK */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Example</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">diff</span><span class=\"token punctuation\">(</span>one<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> two<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> three<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 방법은 모든 시그니처의 리턴타입이 같은 경우에만 가능하다는 것을 주의하라.</p>\n<p><strong><em>Why</em></strong>\n여기엔 두 가지 중요한 이유가 있다.</p>\n<p>TypeScript는 source의 매개변수로 target의 시그니처 호출할 수 있는지, 그리고 관련없는 매개변수가 허용되는지를 보고 시그니처 호환성을 결정한다. 예를 들어, 이 코드는 시그니처가 선택적 매개변수를 사용하여\n정확히 작성된 경우에만 버그를 발생시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">x</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> x<span class=\"token punctuation\">:</span> Example<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 오버로딩으로 작성되어 있으면, OK -- 첫 번째 시그니처를 사용</span>\n<span class=\"token comment\">// 선택적 매개변수로 작성되어 있으면, 에러</span>\n<span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>diff<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>두 번째 이유는 TypeScript의 <code>stric null checking</code> 기능을 사용하는 경우이다. JavaScript에서 명시되지 않은 매개변수는 <code>undefined</code>로 표현되기 때문에, 일반적으로 선택적 매개변수를 가진 함수에 <code>undefined</code>를 명시적으로 전달하는 것이 좋다. 예를 들어 이 코드는 strict null을 사용하는 경우에도 문제없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">var</span> x<span class=\"token punctuation\">:</span> Example<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 오버로딩으로 작성되어 있으면, `undefined`를 `string` 타입으로 전달하기 때문에 에러</span>\n<span class=\"token comment\">// 선택적 매개변수로 작성되어 있으면, 정상</span>\nx<span class=\"token punctuation\">.</span><span class=\"token function\">diff</span><span class=\"token punctuation\">(</span><span class=\"token string\">'something'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span> <span class=\"token operator\">?</span> undefined <span class=\"token punctuation\">:</span> <span class=\"token string\">'hour'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>Use Union Types</h3>\n<p><strong><em>Don’t</em></strong>\n오직 하나의 매개변수 타입이 다른 경우에는 오버로딩을 사용하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* WRONG */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Moment</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">utcOffset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">utcOffset</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Moment<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">utcOffset</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Moment<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong><em>Do</em></strong>\n가능한 경우에는 유니온 타입을 사용하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* OK */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Moment</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">utcOffset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">utcOffset</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Moment<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>시그니처의 리턴타입이 다르기 때문에 <code>b</code>를 선택적 매개변수로 하지 않은 것을 주의하라.</p>\n<p><strong><em>Why</em></strong>\n이것은 함수에 값을 그대로 전달하는 사람들에게 중요하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 오버로딩으로 작성되어 있으면, 에러</span>\n  <span class=\"token comment\">// 유니온 타입으로 작성되어 있으면, 정상</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">moment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">utcOffset</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>primitive타입이 아닌 boxing된 object형 타입. 따라서 <code>Numer.MAX_VALUE</code>나 <code>Number.isSafeInteger()</code>등으로 사용가능하다.</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p>generic으로 선언하고 내부에서 사용하지 않는 경우를 만들지 말라는 의미로, FAQ 페이지를 보면 해당 타입 매개변수를 사용하는 부분이 없으면 타입추론이 제대로 이루어지지 않는다고 한다.</p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p>매개변수의 개수에 대한 함수의 타입 호환성에서 할당받는 함수의 매개변수가 더 많은 경우는 호환이 가능하기 때문이다. 자주 사용하는 <code>map()</code>,<code>filter()</code> 같은 함수에 매개변수 하나만 사용하는 콜백을 넘기는 경우를 생각하면 쉽다.</p>\n<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-4\">\n<p>호출하는 쪽에서는 항상 정해진 수의 매개변수를 전달하고 콜백에서 필요한 만큼만 받아서 사용해야 하는데, 매개변수 개수가 적은 시그니처가 있으면 호출하는 쪽에서 매개변수를 적게 전달하는 실수가 허용된다.</p>\n<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","fields":{"slug":"/dev/ts-do-and-dont/"},"frontmatter":{"date":"2019/02/11","title":"[번역] TypeScript의 Do's and Don'ts","description":"TypeScript 공식 documentation의 Do's and Don'ts를 번역해 보았다.","tags":["TIL","typscript"]}}},{"node":{"excerpt":"MS에서도 엣지에 크로미움을 사용한다고 발표한 상황에서, 팀에서도 IE10을 더이상 지원하지 않기 위한 근거로 서비스 접속 대한 브라우저 통계가 필요했다. 가이드를 통해 nginx의 access 로그와 GoAccess…","html":"<p>MS에서도 엣지에 크로미움을 사용한다고 발표한 상황에서, 팀에서도 IE10을 더이상 지원하지 않기 위한 근거로 서비스 접속 대한 브라우저 통계가 필요했다.<br>\n가이드를 통해 nginx의 access 로그와 <a href=\"https://goaccess.io/\">GoAccess</a>에 대해 알게 되었고 이를 사용하여 간단하게 로그 분석을 해봤다.\n단순하게 사용만 해본 터라 깊이는 없지만 오랜만에 사용해본 쉘 명령어도 되짚어 볼 겸 간단하게 정리해 본다.</p>\n<p>우선 서버에서 원격으로 접근 가능한 위치에 받아올 로그 파일을 미리 복사해 두고 scp를 통해 내려 받아 압축을 해제한다. (회사에서는 일주일 단위로 로그를 압축하여 백업하고 있었고, 실 서비스 서버이므로 로컬 PC로 로그파일을 내려 받아서 진행했다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># scp로 로그파일 내려받기</span>\n<span class=\"token function\">scp</span> 계정@호스트:파일경로 저장할파일이름   <span class=\"token comment\"># 원하는 파일만</span>\n<span class=\"token function\">scp</span> -r 계정@호스트:폴더경로 ./ <span class=\"token comment\"># 폴더 통째로</span>\n\n<span class=\"token comment\"># gzip/gunzip으로 압축 해제하기</span>\n<span class=\"token function\">gzip</span> -d access.log-xxxxxxxx.gz <span class=\"token comment\"># (gunzip access.log-xxxxxxxx.gz) 원하는 파일만</span>\ngunzip -r ./accesslog <span class=\"token comment\"># 폴더의 압축파일들을 한 번에 해제</span></code></pre></div>\n<p>로그파일이 준비됐으니 GoAccess를 설치한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">brew <span class=\"token function\">install</span> goaccess</code></pre></div>\n<p>GoAccess로 분석을 하기위해 로그파일의 포맷을 설정파일에 명시해야 한다. <code>time-format</code>, <code>date-format</code>, <code>log-format</code> 세 가지만 설정 해주고, 로그가 표준화된 형식일 경우 실행시에 옵션으로 넣어줘도 되는 듯 하다.<br>\n미리 정의된 형식이 주석으로 있으니 해제하여 사용하거나 없으면 맞게 작성해주면 된다. 내 PC의 설정파일의 위치는 <code>/usr/local/Cellar/goaccess/1.2_1/etc/goaccess.conf</code>였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\">######################################</span>\n<span class=\"token comment\"># Time Format Options (required)</span>\n<span class=\"token comment\">######################################</span>\ntime-format %H:%M:%S\n\n<span class=\"token comment\">######################################</span>\n<span class=\"token comment\"># Date Format Options (required)</span>\n<span class=\"token comment\">######################################</span>\ndate-format %d/%b/%Y\n\n<span class=\"token comment\">######################################</span>\n<span class=\"token comment\"># Log Format Options (required)</span>\n<span class=\"token comment\">######################################</span>\nlog-format %h - %^ <span class=\"token punctuation\">[</span>%d:%t %^<span class=\"token punctuation\">]</span>  <span class=\"token string\">\"%r\"</span> %s %b <span class=\"token string\">\"%R\"</span> <span class=\"token string\">\"%u\"</span> %T <span class=\"token string\">\"%^\"</span></code></pre></div>\n<p>GoAccess를 사용하기 전에 필요한 로그를 가공 할 필요가 있었다.\n<a href=\"https://page.kakao.com\">카카오페이지 웹</a>의 경우 PC와 모바일 버전이 다르고(당연히), 모바일의 경우 앱 내에서 호출하는 경우가 있어 제외시켜야 했다. 추가로 리다이렉션(응답코드 30X) 되는 경우도 로그가 중복이기 때문에 제외 시켰다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 앱에서 호출하는 경우 userAgent에 KakaoPage가 포함된다.</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/KaKaoPage/d'</span> access.log-xxxxxxxx <span class=\"token operator\">></span> 1_only_web\n<span class=\"token comment\"># 응답코드 30X인 레코드를 제외시킨다.(더 정확하게 할 수 있겠지만 이 정도만 해도 충분했다.)</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/\" 30. /d'</span> 1_only_web <span class=\"token operator\">></span> 2_delete_redirect</code></pre></div>\n<p>GoAccess를 실행시켜 로그 파일을 분석하고 결과를 html파일로 만든다. (결과 화면은 <a href=\"https://goaccess.io/\">https://goaccess.io/</a>를 참고)</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">goaccess 2_delete_redirect -a -o 2_delete_redirect.html</code></pre></div>\n<p>결과를 대략 정리해 보면 크롬이 대부분을 차지했고, IE와 엣지는 통틀어 3%가 되지 않았다. IE10은 약 20명 내외였으며 서버 수를 고려한다 해도 절대치가 미미한 수준이었다. 아마도 이제 IE10 지원에 대한 고민은 하지 않아도 될 듯 하다.</p>","fields":{"slug":"/dev/goaccess-analyzer/"},"frontmatter":{"date":"2019/01/24","title":"[TIL] GoAccess로 nginx access 로그 분석 겉핥기","description":"브라우저별 접속 통계 확인을 위한 GoAccess 사용기","tags":["TIL","GoAccess","nginx","IE10"]}}}]}},"pageContext":{}}}