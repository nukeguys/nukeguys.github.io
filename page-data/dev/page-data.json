{"componentChunkName":"component---src-pages-dev-tsx","path":"/dev/","webpackCompilationHash":"92b2b03c19a83c3a3956","result":{"data":{"site":{"siteMetadata":{"title":"nukeguys blog","description":"about development, life and something.","siteUrl":"https://nukeguys.github.io"}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"…","html":"<p>웹의 성능을 올리는 데는 다양한 방법들이 있다. 렌더링을 최적화 하거나 리소스 크기를 최소화 한다. 그리고 가능하다면 리소스의 사용이나 로딩을 필요한 시점까지 연기하거나 비동기로 처리한다. 웹에서 사용하는 리소스들 중 많은 크기를 차지하는 것 중의 하나가 이미지이다. 아무리 최적화를 하고 크기를 줄이더라도 이미지 수가 어느정도 증가하면 로딩에 오랜 시간이 걸릴 수 밖에 없다. 이를 방지하기 위해 ATF<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> 영역만 먼저 로딩 하고 나머지는 필요한 시점에 로딩시키는 lazyloading을 많이 사용한다.</p>\n<p>웹에서 이미지를 lazyloading 시키는 방법도 여러가지가 있는데 구글 개발자 사이트(<a href=\"https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/?hl=ko\">이미지 및 동영상의 지연 로딩</a>)에 보면 관련된 설명을 개념부터 방법까지 친절하게 해주고 있다.</p>\n<p>이 중에서 적용이 쉽고 여러모로 편리한 <code>intersection observer</code>를 사용하는 방법을 정리해 본다.</p>\n<p><code>intersection observer</code>는 MDN(<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\">Intersection Observer</a>)에서 확인해도 되고, 구글에 검색하면 친절하게 설명되어 있는 글들이 많다. 간단히 설명하면 이름에서 알 수 있듯이 지정된 영역에 대해 교차(intersection) 했는지를 감지하고 해당 시점에 원하는 작업을 할 수 있게 해준다. 안타깝게도 모든 버전의 브라우저에서 지원하지 않고 특히 IE에서는 지원조차 하지 않는다. 다행히 W3C에서 <a href=\"https://github.com/w3c/IntersectionObserver/tree/master/polyfill\">polyfill</a>을 지원해 준다. 하지만 브라우저마다 동작이 조금씩 다를 수 있다고 하니 주의해서 사용하자.</p>\n<p><code>intersection observer</code> 사용을 위해서는 observer 객체를 생성하고 lazyloading을 적용할 이미지를 등록 시켜야 한다. 지정된 영역안으로 들어올 때 뿐 아니라 나갈 때도 callback이 호출되기 때문에 <code>isIntersecting</code> 값이 true일 때만 처리 하고, 로드한 후에는 감시할 필요가 없기 때문에 등록을 해제해 주어야 한다.</p>\n<pre><code class=\"language-ts\">const Image = ({ src }: IProps) => {\n  const imgRef = useRef&#x3C;HTMLImageElement>(null);\n  const observerRef = useRef&#x3C;IntersectionObserver>();\n  const [isLoad, setIsLoad] = useState(false);\n\n  function onIntersection(\n    entries: IntersectionObserverEntry[],\n    io: IntersectionObserver\n  ) {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        io.unobserve(entry.target);\n        setIsLoad(true);\n      }\n    });\n  }\n\n  useEffect(() => {\n    if (!observerRef.current) {\n      observerRef.current = new IntersectionObserver(onIntersection);\n    }\n\n    imgRef.current &#x26;&#x26; observerRef.current.observe(imgRef.current);\n  }, []);\n\n  return &#x3C;img ref={imgRef} src={isLoad ? src : placeHolder} />;\n};\n</code></pre>\n<p>전체 코드와 동작은 아래에서 확인할 수 있다. 눈으로 확인할 수 있도록 <code>threshold</code>를 0.5로 설정했다. 즉 이미지의 절반이 화면에서 나타날 때 로드된다. 스크롤을 천천히 내리면서 확인해보자.</p>\n<p><iframe src=\"https://codesandbox.io/embed/lazyloading-image-59dxt?autoresize=1&fontsize=14&module=%2Fsrc%2FImage.tsx\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"></iframe></p>\n<p>위의 방식도 동작엔 문제가 없지만, 각 Image 컴포넌트 마다 <code>IntersectionObserver</code>를 생성하고 있다. 성능상 얼마나 큰 차이가 있을지는 벤치마킹을 해봐야겠지만 이미지가 많은 경우 매번 생성을 하는건 비효율 적으로 보인다. 따라서 전역적으로 하나만 두고 계속 사용하도록 수정하는 것이 좋아보인다.</p>\n<p>우선 observer를 컴포넌트 밖으로 분리하자.</p>\n<pre><code class=\"language-ts\">const Image = ({ src }: { src: string }) => {\n  // ...\n  useEffect(() => {\n    if (!observer) {\n      observer = new IntersectionObserver(onIntersection);\n    }\n\n    imgRef.current &#x26;&#x26; observer.observe(imgRef.current);\n  }, []);\n  // ...\n};\nlet observer: IntersectionObserver | null = null;\n</code></pre>\n<p>하지만 이렇게 하면 IntersectionObserver 생성시 사용한 <code>onIntersection</code> 함수는 첫번째 이미지 내부 함수기 때문에 다른 이미지들에 대해서는 제대로 동작하지 않는다. 따라서 onIntersection도 밖으로 분리한다. 이렇게 분리하다 보면 한가지 문제가 생긴다. <code>setIsLoad</code>는 컴포넌트의 내부에서만 사용가능하기 때문이다. 그래서 함수 외부에서도 호출가능한 방법을 찾아야 한다. 난 <code>CustomEvent</code>를 사용해서 처리했다. CustomEvent는 이름처럼 event를 직접 정의해서 사용할 수 있도록 해준다. 마찬가지로 모든 브라우저 버전에서 지원하지 않으니 주의하고, <a href=\"https://developer.mozilla.org/ko/docs/Web/API/CustomEvent/CustomEvent\">MDN</a>에서 IE에서 사용가능한 polyfill도 제공하니 확인 후 사용하자.\n<code>CustomEvent</code>는 이벤트 타입을 정한 후에 다른 이벤트와 동일하게 <code>addEventListener</code>를 통해 callback을 등록하고, <code>dispatchEvent</code> 호출하면서 해당 이벤트 타입의 객체를 전달하면서 이벤트를 발생시킨다.</p>\n<pre><code class=\"language-ts\">const Image = ({ src }: IProps) => {\n  //  ...\n  useEffect(() => {\n    function loadImage() {\n      setIsLoad(true);\n    }\n    const imgEl = imgRef.current;\n    imgEl &#x26;&#x26; imgEl.addEventListener(LOAD_IMG_EVENT_TYPE, loadImage);\n    return () => {\n      imgEl &#x26;&#x26; imgEl.removeEventListener(LOAD_IMG_EVENT_TYPE, loadImage);\n    };\n  }, []);\n\n  // ...\n  return &#x3C;img ref={imgRef} src={isLoad ? src : placeHolder} />;\n\n  let observer: IntersectionObserver | null = null;\n  const LOAD_IMG_EVENT_TYPE = 'loadImage';\n\n  function onIntersection(\n    entries: IntersectionObserverEntry[],\n    io: IntersectionObserver\n  ) {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        io.unobserve(entry.target);\n        entry.target.dispatchEvent(new CustomEvent(LOAD_IMG_EVENT_TYPE));\n      }\n    });\n  }\n};\n</code></pre>\n<p>최종 코드와 동작은 아래에서 확인하자.</p>\n<p><iframe src=\"https://codesandbox.io/embed/image2-v7ii7?fontsize=14\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"></iframe></p>\n<p>처음 lazyloading을 구현할 땐 라이브러리도 고려해보고 방법도 많이 찾아봤었다. 그리고 지금은 위의 방법과 비슷하게 직접 구현해서 사용하고 있다. 코드양은 얼마 되지 않지만 결과를 내는데 까지 적지 않은 시간과 노력을 들였고 그만큼 결과적으로 만족스럽다. (뭐든지 처음이 어렵지...) 조금 더 나은 웹을 위해 하나씩 더 알아가보자.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>Above-The-Fold의 약자로 가판대에 접혀있는 신문의 보이는 영역을 의미하는데서 시작되었다. 사용자가 처음 진입했을 때 보이는 기본 영역을 의미한다. (참고: <a href=\"https://m.blog.naver.com/PostView.nhn?blogId=beusable&#x26;logNo=220887404946&#x26;proxyReferer=https%3A%2F%2Fwww.google.com%2F\">Above the Fold란?</a>)</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","fields":{"slug":"/dev/react-lazyimage/"},"frontmatter":{"date":"2019/10/06","title":"react lazyloading 이미지 컴포넌트 구현","description":"intersection observer와 CustomEvent 사용기","tags":["react","lazyload","image","intersection-observer"]}}},{"node":{"excerpt":"개발을 하다보니 너무나 당연하게도 git을 사용한다. 처음부터 git을 cli로만 사용하다보니 Sourcetree나 Tower 같은 GUI client를 사용하는 것보다 직접 타이핑 하는게 오히려 더 편하게 느껴진다. 하지만 cli…","html":"<p>개발을 하다보니 너무나 당연하게도 git을 사용한다. 처음부터 git을 cli로만 사용하다보니 <a href=\"https://www.sourcetreeapp.com/\">Sourcetree</a>나 <a href=\"https://www.git-tower.com\">Tower</a> 같은 GUI client를 사용하는 것보다 직접 타이핑 하는게 오히려 더 편하게 느껴진다. 하지만 cli 특성상 타이핑이 많거나 반복되는 경우가 생긴다. 게으름이 기술의 발전을 이끈다고 하던가... 귀차니즘이 너무 심해질 때 마다 하나씩 해결했던 방법들을 몇가지 정리해 본다.</p>\n<h2>1. checkout의 귀차니즘</h2>\n<p>작업을 하다보면 새로 만들거나 혹은 리뷰를 위해 다른 브랜치를 pull 하거나 등등으로 여러 브랜치 사이를 이동하는 경우는 흔한 일이다. 그러나 브랜치명이 길다면 매번 입력하는건 여간 귀찮은 일이 아니다. 사실 <a href=\"https://ohmyz.sh/\">Zsh</a>을 사용하고 있어 탭과 방향키 만으로 브랜치를 선택할 수는 있지만 순간 손을 이동해야 한다. 타이핑을 하다가 방향키로 손을 움직이는 것도 번거로워 진 시점에 현재 로컬의 브랜치들의 리스트를 보여주고 번호 입력으로 checkout을 하는 python script(<a href=\"https://github.com/nukeguys/utils\">github</a>)를 작성했었다.\n이외에도 python으로 일에 필요한 것들을 작성했었는데 지금은 사용하지 않고 있다. 동작은 아래에서 확인 할 수 있다.</p>\n<p><a href=\"https://asciinema.org/a/270031\"><img src=\"https://asciinema.org/a/270031.svg\" alt=\"asciicast\"></a></p>\n<h2>2. alias 설정하기</h2>\n<p>option으로 command 자체가 길어지거나, 빈번하게 command를 연속해서 입력해야 하는 경우에는 축약하거나 한 번에 처리하고 싶어진다. 이런 경우에는 <a href=\"https://git-scm.com/book/ko/v2/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-Git-Alias\">alias</a>를 설정할 수 있다. 간단한 git command 부터 bash 함수까지 실행이 가능하기 때문에 생각보다 많은 것들이 가능해진다.</p>\n<p>내가 처음 사용했던건 log를 좀 더 이쁘게 보기 위한 alias 였다. 이후에 사용하면서 필요하다 싶은 것들을 하나씩 추가했다.</p>\n<pre><code class=\"language-bash\">[alias]\n    s = status\n    a = !git add . &#x26;&#x26; git status\n    au = !git add -u . &#x26;&#x26; git status\n    aa = !git add . &#x26;&#x26; git add -u . &#x26;&#x26; git status\n    c = commit\n    cm = commit -m\n    ca = commit --amend # careful\n    ac = !git add . &#x26;&#x26; git commit\n    acm = !git add . &#x26;&#x26; git commit -m\n    l = log --graph --all --pretty=format:'%C(yellow)%h%C(cyan)%d%Creset %s %C(white)- %an, %ar%Creset'\n    ll = log --stat --abbrev-commit\n    lg = log --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&#x3C;%an>%Creset' --abbrev-commit\n    llg = log --color --graph --pretty=format:'%C(bold white)%H %d%Creset%n%s%n%+b%C(bold blue)%an &#x3C;%ae>%Creset %C(bold green)%cr (%ci)' --abbrev-commit\n    d = diff\n    lgdiff = \"!f() { git log --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&#x3C;%an>%Creset' --abbrev-commit $1..$2;}; f\"\n    lgraph = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&#x3C;%an>%Creset' --abbrev-commit\n    branch-name = !git rev-parse --abbrev-ref HEAD\n    publish = !git push -u origin $(git branch-name)\n    rm-remote = \"!f() { git push origin --no-verify :$1; }; f\"\n    rb = \"!f() { git branch -D $(git branch | grep -E $1); }; f\"\n    rt = \"!f() { git tag -d $(git tag -l $1); }; f\"\n    rrt = \"!f() { git push origin --no-verify -d $(git tag -l $1); }; f\"\n    aliases = !git config --list | grep 'alias\\\\.' | sed 's/alias\\\\.\\\\([^=]*\\\\)=\\\\(.*\\\\)/\\\\1\\\\\\t => \\\\2/' | sort\n    cb = \"!f() { git checkout -b feature/KG-$1-$2; }; f\"\n</code></pre>\n<p>아래는 내가 가장 빈번하게 사용하는 alias들이다.<br>\n<code>publish</code> - remote에 현재 브랜치 push<br>\n<code>rb</code> - 정규식에 매핑되는 로컬 브랜치 삭제 / <code>rm-remote</code> - remote 브랜치 삭제<br>\n<code>cb</code> - 특정 포맷에 맞게 브랜치 생성 / <code>ca</code> - commit --amend 줄여쓰기<br>\n<code>ac</code> - add, commit 한 번에 하기 / <code>lg</code> - log 이쁘게 보기</p>\n<p>등록된 alias들이 기억나지 않을 땐 <code>git aliases</code>를 통해 list 확인이 가능하다. 구글링하면 유용한 alias들이 많으니 자신이 자주 사용하는 것들을 등록하고 사용하면 생각보다 많이 편리하다.</p>\n<h2>3. commit message에 이슈 번호 자동 입력하기</h2>\n<p>commit message는 어느정도 가이드라인을 지켜주는게 이력들을 볼 때 편하다. 하지만 매번 기억하기는 어렵기 때문에 commit시 템플릿을 사용하도록 설정해 놓으면 잊지 않고 지킬 수 있다. template 설정도 alias처럼 config 파일에 직접 추가하거나 <code>git config --global commit.template ~/.gitmessage.txt</code> command를 사용할 수 있다.(global 옵션을 사용하지 않으면 repository별로 설정도 가능하다.) 난 개인적으로 <a href=\"https://chris.beams.io/posts/git-commit/\">How to Write a Git Commit Message</a>를 참고해서 아래와 같은 template을 사용하고 있다.</p>\n<pre><code class=\"language-bash\"># &#x3C;type>: (If applied, this commit will...) &#x3C;subject> (Max 50 char)\n# |&#x3C;----  Using a Maximum Of 50 Characters  ---->|\n[ISSUE-NUMBER]\n\n# Explain why this change is being made\n# |&#x3C;----   Try To Limit Each Line to a Maximum Of 72 Characters   ---->|\n\n\n# Provide links or keys to any relevant tickets, articles or other resources\nResolves: ISSUE-NUMBER\n\n# --- COMMIT END ---\n# Type can be\n#    feat     (new feature)\n#    fix      (bug fix)\n#    refactor (refactoring production code)\n#    style    (formatting, missing semi colons, etc; no code change)\n#    docs     (changes to documentation)\n#    test     (adding or refactoring tests; no production code change)\n#    chore    (updating grunt tasks etc; no production code change)\n# --------------------\n# Remember to\n#    Capitalize the subject line\n#    Use the imperative mood in the subject line\n#    Do not end the subject line with a period\n#    Separate subject from body with a blank line\n#    Use the body to explain what and why vs. how\n#    Can use multiple lines with \"-\" for bullet points in body\n# --------------------\n</code></pre>\n<p>그런데 최근에 계속 작성을 하면서 issue 번호를 입력하는 부분이 너무 번거로웠다. 왜냐하면 기본적으로 branch 명에 이슈 번호를 포함해서 정해진 포맷으로 사용하고 있고(이것도 귀찮아서 만든게 <code>cb</code> alias다.) commit시 현재 브랜치명에서 issue 번호를 가져다 template을 자동으로 채워주면 좋겠다는 생각이 들었다.\n그래서 <code>prepare-commit-msg</code> hook을 작성했다. hook은 git workflow의 전후로 script를 실행할 수 있게 해준다. (설정 방법과 자세한 설명은 <a href=\"https://git-scm.com/book/ko/v2/Git%EB%A7%9E%EC%B6%A4-Git-Hooks\">Git - Git 훅</a>을 참고)\n직접 hook directory에 파일을 작성할 수도 있지만 <a href=\"https://github.com/typicode/husky\">husky</a>를 사용하면 hook을 좀 더 쉽게 관리할 수도 있다.</p>\n<pre><code class=\"language-bash\">#!/bin/bash\n\nCOMMIT_MSG_FILE=$1\nISSUE_NUMBER_TAG='ISSUE-NUMBER'\n\nbranch_name=`git rev-parse --abbrev-ref HEAD`\nissue_number=`echo ${branch_name} | sed -n 's/^feature\\/\\(.*-[0-9]*\\)-.*/\\1/p'`\n\nif [ -n \"$issue_number\" ]; then\n  sed -i \".bak\" \"s/${ISSUE_NUMBER_TAG}/${issue_number}/g\" ${COMMIT_MSG_FILE}\nfi\n</code></pre>\n<h2>4. tig (text-mode interface for Git) 사용</h2>\n<p><a href=\"https://github.com/jonas/tig\">tig</a>는 텍스트 기반의 git client다. 따라서 terminal 벗어나지 않아도 되고 커스터마이징이 가능하기 때문에 잘만 사용하면 상당히 유용하다. (나도 간단하게만 사용하고 있는데 좀 더 활용을 해보고 나중에 다시 정리해봐야겠다.)\ntig 메뉴얼은 친절하게 한국어로 번역(<a href=\"https://ujuc.github.io/2016/02/10/tig-manual/\">[번역] Tig Manual</a>)된 것이 있으니 한 번 읽어보면 좋을 듯하다.</p>\n<p>이외에도 github 사용을 편하게 만들어주는 <a href=\"https://hub.github.com/\">hub</a>도 있고, 간단한 설정이나 script를 작성하면 cli를 사용하는 불편함들을 많이 제거할 수 있다.</p>","fields":{"slug":"/dev/easy-git/"},"frontmatter":{"date":"2019/09/21","title":"Git 사용 팁 정리","description":"git cli를 사용하다 생긴 귀차니즘 없애기","tags":["git","cli","git-hook","alias"]}}},{"node":{"excerpt":"웹에 페이스북 플러그인을 붙여놓게 되면 데이터는 페이스북에 쌓이게 되고 다시 가져올 수가 없다. (데이터를 추출해서 별도로 저장하면 법적인 문제가 생긴다고 한다.)\n그래서 페이스북 플러그인 대신 입맛에 맞게 UI…","html":"<p>웹에 페이스북 플러그인을 붙여놓게 되면 데이터는 페이스북에 쌓이게 되고 다시 가져올 수가 없다. (데이터를 추출해서 별도로 저장하면 법적인 문제가 생긴다고 한다.)\n그래서 페이스북 플러그인 대신 입맛에 맞게 UI를 변경하고 싶을 때는 페이스북에서 제공하는 <a href=\"https://developers.facebook.com/docs/graph-api?locale=ko_KR\">그래프 API</a>를 사용해야 한다.</p>\n<pre><code>https://graph.facebook.com/{object-id}/comments\nor\nhttps://graph.facebook.com/comments?id={object-id}\n</code></pre>\n<p>여기서 문제는 가져올 페이지의 <code>object-id</code>가 필요하다는 것이다.\n별도로 알 수 있는 방법이 없어서(찾지 못했다...) 직접 찾아내야 한다. 플러그인에서 댓글의 작성시간을 누르면 새로운 페이지가 나오는데 여기에서 주소표시줄을 보면 <code>fb_comment_id</code>가 아래의 예시처럼 보인다.</p>\n<pre><code>&#x26;fb_comment_id=1234567890123456_2197257797049450\n</code></pre>\n<p>여기서 <code>_</code> 앞에 있는 <code>1234567890123456</code> 이 부분이 api 호출에 사용 할 <code>object-id</code>이다. 단순 하나라면 이정도면 충분하다. 하지만 플러그인이 붙어 있는 페이지가 수십 수백개가 넘는다면 일일히 손으로는 불가능하기 때문에 자동화를 할 필요가 생긴다.\b</p>\n<p>위에서 말한 것 처럼 댓글의 작성일자를 눌렀을 때 <code>object_id</code>가 포함된 경로로 이동되기 때문에, 댓글의 작성일자 태그의 속성을 꺼내오면 될 것 같다. 그래서 간단히 해당 페이지를 긁어서 출력해보자.</p>\n<pre><code class=\"language-python\">from urllib.request import urlopen\n\nurl = '...'\nhtml = urlopen(url)\nprint(html.read().decode(\"utf-8\"))\n</code></pre>\n<p>정작 댓글 내용은 보이지 않는다. 이유는 플러그인이 javascript가 실행되어야 하는데 request는 javascript 실행을 하지 못하기 때문이다. 코드를 조금 살펴보면 플러그인인 페이지에 iframe으로 추가되는 것을 알 수 있다. 그래서 iframe의 경로(<code>https://www.facebook.com/plugins/feedback.php?app_id=...</code>)로 다시 한 번 들어가 보면 정확하게 플러그인만 보이는 페이지가 나온다.</p>\n<p>이 페이지를 긁어서 다시 출력해보면 역시나 댓글이 렌더링된 코드들이 보이지 않는다. 이 페이지에서도 로딩된 이후에 javascript를 통해 댓글을 렌더링 하고 있기 때문이다.(코드상 <code>requireLazy</code> 함수가 관련 있는 것으로 추측된다.)</p>\n<p>그래서 렌더링이 될 때까지 기다려야 하는데 이를 위해서 <a href=\"https://miyakogi.github.io/pyppeteer/\">pyppeteer</a>를 사용한다. <code>pyppeteer</code>는 google에서 만든 headless chrome을 사용할 수 있게 해주는 node.js 라이브러리인 <a href=\"https://pptr.dev/\">puppeteer</a>를 python으로 porting한 모듈이다.\n(대신 <a href=\"https://www.seleniumhq.org/\">Selenium</a>을 사용 할 수도 있다.)</p>\n<pre><code class=\"language-python\">from pyppeteer import launch\n\nurl = '...'\nbrowser = await launch()\npage = await browser.newPage()\nawait page.goto(url)\nawait page.waitForSelector('.pluginSkinLight', {'timeout': 1000})\nbodyHTML = await page.evaluate('() => document.body.innerHTML')\nprint(bodyHTML)\n</code></pre>\n<p>대략 위처럼 테스트해서 코드를 살펴보면 원하던 댓글들이 렌더링되어 있는 것을 볼 수 있다. 여기서 작성 시간에 있는 href만 찾아내면 된다.</p>\n<p>가져온 html을 <a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/\">Beautiful Soup</a>으로 파싱하면 손쉽게 원하는 태그에서 속성들을 추출할 수 있다.</p>\n<p>하지만 잠시 wait하지 않던 코드를 살펴보자. <code>waitForSelector</code> 부분만 주석처리하고 출력된 코드를 보면, 댓글이 렌더링 되어 있지는 않지만 <code>script</code> 태그 안에 댓글들의 데이터가 얼핏 보인다. 그리고 혹시나 해서 object-id 값을 검색해보면 <code>targetFBID</code>라는 키로 값이 존재하는 것을 알 수 있다.</p>\n<p>즉, 렌더링 되는 것을 기다리지 않고 필요한 데이터는 미리 알 수가 있는 것이다.(플러그인이 react로 작성되어 있는데 사용하는 상태값들이 아닐까 싶다.) 해당 값을 단순 string 매핑으로 찾아 낼 수도 있으나, 코드를 보면 javascript 함수(handleServerJS) 안에서 파라미터로 넘어가는 json 객체안에 데이터들이 포함되어 있다. 따라서 이 부분을 추출해서 json 객체로 변환하면 필요한 다른 데이터들도 추출하기가 쉬워진다.</p>\n<pre><code class=\"language-python\">from pyppeteer import launch\nimport json\nimport re\n\npattern = re.compile(r'handleServerJS\\(([^)]+)\\)')\n\nbodyHTML = await page.evaluate('() => document.body.innerHTML')\np = pattern.search(bodyHTML)\nparam = json.loads(p.group(1))\nmeta = param['require'][4][3][0]['props']['meta']\nid = meta['targetFBID']\ncount = meta['totalCount']\n</code></pre>\n<p>간단히 정리한 코드기 때문에 자동화를 위한 입출력이나 예외처리, 속도를 조금 올리기 위해 asyncio등을 적용해주면 간단히 쓰기에는 충분해진다.</p>","fields":{"slug":"/dev/scrap-facebook-comment/"},"frontmatter":{"date":"2019/08/25","title":"페이스북 댓글 플러그인 스크래핑하기","description":"python + pyppeteer로 웹 스크래핑 맛 보기","tags":["acrapping","crawling","python","pyppeteer","facebook","comment"]}}},{"node":{"excerpt":"최근 작업을 하면서 react 성능에 대해 신경을 써야 할 상황이 생겼다. 아직 정확하게는 모르지만 대충 눈치, 코치, 감으로 chrome과 react의 developer tool…","html":"<p>최근 작업을 하면서 react 성능에 대해 신경을 써야 할 상황이 생겼다. 아직 정확하게는 모르지만 대충 눈치, 코치, 감으로 chrome과 react의 developer tool을 사용해서 성능을 측정하고 개선하는 작업을 했는데, 일단 이번엔 <code>React Developer Tools</code>을 사용해 성능을 측정하하고 개선하는 방법을 정리해본다.</p>\n<h2>성능 측정</h2>\n<p>우선 react와 browser의 렌더링 과정에 대해 간단히 알 필요가 있다. react는 DOM의 직접적인 변경을 방지하기 위해 virtual DOM을 사용하고 실제로 변경이 필요한 부분만 DOM에 반영함으로써 성능을 올린다. 브라우저는 변경이 발생하면 크게 두 과정을 필요에 따라 선택적으로 수행한다. DOM tree를 갱신하는 reflow(layout)와 이를 화면에 반영하는 repaint(painting)이다.(<a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Introduction_to_Layout_in_Mozilla#Basic_Data_Flow\">Introduction to Layout in Mozilla - Mozilla | MDN</a>)</p>\n<p>브라우저의 DOM에 변경을 가하는 reflow와 repaint도 당연히 성능에 영향이 크지만, react의 virtual DOM을 재계산하는 reconciliation(<a href=\"https://reactjs.org/docs/reconciliation.html\">Reconciliation – React</a>)과정도 생각보다 성능에 많은 영향을 미친다. 따라서 성능을 올리기 위해서는 이 모든 과정에 대한 고려가 필요하다. react의 reconciliation는 react developer tools를 통해 확인할 수 있고, reflow 및 repaint는 chrome의 developer tool을 통해 확인이 가능하다.</p>\n<h3>Highlight Updates</h3>\n<p>react는 컴포넌트의 state나 props가 변경되면 render를 수행하여 virtual DOM을 갱신한다. react의 developer tools에서 Highlight Updates 설정을 켜놓으면 interaction이 발생할 때 마다 리렌더링되는 컴포넌트의 테두리에 색이 변경되는 것을 볼 수 있다. 즉 변경될 필요가 없는데도 특정 부분의 테두리 색이 나타난다면 불필요한 컴포넌트 렌더링이 발생하고 있는 것이다.</p>\n<h3>Profiler</h3>\n<p>위의 방법은 눈으로 쉽게 확인 가능하지만 상세한 내용은 알 수 가 없다. 경우에 따라 보다 정확하고 자세한 내용을 알고 싶다면 profiler를 사용하면 된다. 기본적인 사용법은 profiler 패널에서 record 버튼을 누르고 원하는 interaction을 하거나 시간이 흐른 뒤에 stop을 누르면 그 사이에 발생한 렌더링에 대해 확인 할 수 있다.</p>\n<p><img src=\"https://reactjs.org/static/stop-profiling-45619de03bed468869f7a0878f220586-53c76.png\" alt=\"stop-profiling-45619de03bed468869f7a0878f220586-53c76.png\"></p>\n<h4>Flame Chart</h4>\n<p>prifiling이 끝나면 그 동안에 발생한 commit<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>별 flame chart를 보여준다. 각 commit은 패널의 우측 상단에서 표시가 되고 각 commit을 선택하면 해당 commit의 flame chart가 표시된다.</p>\n<p><img src=\"https://reactjs.org/static/commit-selector-bd72dec045515d59be51c944e902d263-8ef72.png\" alt=\"commit-selector-bd72dec045515d59be51c944e902d263-8ef72.png\"></p>\n<p>commit이 많이 표시되는 것은 측정 시간동안 DOM의 변경이 그 만큼 발생했다는 것이고, 바의 색과 높이는 렌더링 소용된 시간을 나타낸다. (높고 노란색일 수록 오래 걸렸다는 의미이다.)</p>\n<p>flame chart에서는 commit에서 각 컴포넌트들의 상태를 나타낸다. 바의 길이(너비)는 마지막 렌더링에 걸린 시간을 의미하고 색은 현재 commit에서 소요된 시간을 의미한다. (해당 컴포넌트와 자식컴포넌트를 포함한다.)</p>\n<p>아래 사진에서보면 <code>App</code>과 <code>HashRouter</code> 컴포넌트의 경우 렌더링에 많은 시간이 걸리고 있으나 회색이기 때문에 현재 commit에서는 렌더링이 발생하지 않았다는 것을 알 수 있고, <code>Router</code> 컴포넌트는 렌더링이 발생했고 대부분의 시간이 자식 컴포넌트인 <code>Nav</code>와 <code>Route</code> 렌더링에 소요된 것을 알 수 있다.</p>\n<p><img src=\"https://reactjs.org/static/flame-chart-3046f500b9bfc052bde8b7b3b3cfc243-53c76.png\" alt=\"flame-chart-3046f500b9bfc052bde8b7b3b3cfc243-53c76.png\"></p>\n<p>컴포넌트를 선택하면 이번 commit에서의 <code>state</code>나 <code>prpos</code>도 확인이 가능하고, 다른 commit을 선택하면 변경도 확인할 수 있어서 렌더링이 발생한 이유도 알 수 있다.</p>\n<h4>Ranked Chart</h4>\n<p>두 번째 ranked chart를 선택하면 현재 commit에서 렌더링이 오래걸린 순으로 컴포넌트를 정렬해서 확인 할 수 있다. 단, 자식 컴포넌트의 렌더링을 포함하기 때문에 표시되는 실제 오래걸리는 컴포넌트가 포함된 tree의 top이 표시될 수 있다는 점을 염두해야 한다.</p>\n<h4>Component Chart</h4>\n<p>전체 profiling 동안 특정 컴포넌트의 렌더링에 대해 알고 싶을 땐 component chart가 유용하다. 컴포넌트를 더블클릭하거나 오른쪽 x표시 옆에 있는 차트 모양 아이콘을 선택하면 볼 수 있다.</p>\n<p><img src=\"https://reactjs.org/static/component-chart-d71275b42c6109e222fbb0932a0c8c09-53c76.png\" alt=\"component-chart-d71275b42c6109e222fbb0932a0c8c09-53c76.png\"></p>\n<p>바의 수는 렌더링 된 횟수를 의미하고 각 바의 높이와 색은 각 commit에서 다른 컴포넌트에 비해 상대적으로 해당 컴포넌트가 렌더링되는데 걸린 시간을 의미한다. 바를 선택하면 자세한 내용을 볼 수 있고, 더블 클릭하거나 x를 누르면 이전 화면으로 돌아갈 수 있다.</p>\n<p>보다 상세한 사용법은 react 블로그를 참고하자. (<a href=\"https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html\">Introducing the React Profiler – React Blog</a>)</p>\n<h2>개선 하기</h2>\n<p>profiling 결과를 보다보면 특정 컴포넌트가 렌더링에 시간을 오래 소요하거나 렌더링할 필요가 없는 데도 commit마다 렌더링이 발생하는 경우가 있다. 이런 경우 해당 컴포넌트를 찾아서 불필요한 렌더링이 발생하지 않도록 개선할 필요가 있다.</p>\n<p>우선 렌더링이 발생하는 이유에 대해 생각해보자. react는 state나 props가 변경된 경우 컴포넌트의 변경이 발생할 것으로 예상하고 렌더링을 한다. 이 과정이 위에서 확인되는 렌더링 이다. 최종적으로 실제 DOM에 변경이 없다면 반영이 되지 않겠지만(이 부분은 다음에 정리할 내용에서 확인이 가능하다.) 이 자체만으로 경우에 따라 성능에 많은 영향을 주게 된다. 이 과정을 없애기 위해서는 react에게 렌더링을 할 필요가 없다는 것을 알려줄 필요가 있다. 예상했듯이 class형 컴포넌트에서는 <code>shouldComponentUpdate</code>를 사용하거나 <code>PureComponent</code>를 상속함으로서 미리 정의된 <code>shouldComponentUpdate</code>를 적용할 수 있다. function 컴포넌트에서도 비슷한 역할을 하는 <code>memo</code>라는 HOC가 존재한다.</p>\n<h3>React.memo</h3>\n<pre><code class=\"language-ts\">const MyComponent = React.memo(function MyComponent(props) {\n  /* render using props */\n});\n</code></pre>\n<p>위 처럼 사용하면 <code>PureComponent</code> 처럼 shallow 한 비교를 직접 처리해준다. 하지만 좀 더 복잡하거나 예외적인 처리가 필요할 경우에는 두 번째 인자로 이전 props와 다음 props를 받아서 비교를 수행하는 함수를 전달할 수 있다. <code>shouldComponentUpdate</code>와 다른점이 있다면 반환값이 반대라는 점이다. 이름에서 알 수 있듯이 <code>shouldComponentUpdate</code>는 update여부를 반환하기 때문에 다른 경우에 true를 반환하지만 <code>areEqual</code>의 경우는 비교의 결과를 반환하면 된다.</p>\n<pre><code class=\"language-ts\">function MyComponent(props) {\n  /* render using props */\n}\nfunction areEqual(prevProps, nextProps) {\n  /*\n  return true if passing nextProps to render would return\n  the same result as passing prevProps to render,\n  otherwise return false\n  */\n}\nexport default React.memo(MyComponent, areEqual);\n</code></pre>\n<p>대부분의 경우에는 추가적인 비교함수 없이 대응이 가능하다. 이 때 주의할 점은 shallow하게 비교하기 때문에 <code>immutable</code>한 데이터를 <code>props</code>로 사용해야 한다는 점이다. 즉, 실제 같은 데이터지만 렌더링 마다 새로운 객체를 생성해서 전달한다면 memo의 의미가 없어지게 되는 것이다.</p>\n<p>즉 부모 컴포넌트에서 <code>useMemo</code>나 <code>useCallback</code>을 사용해서 props를 전달하고 자식 컴포넌트에서 <code>memo</code>가 적용되어 있으면 손쉽게 불필요한 렌더링을 막을 수 있게 되는 것이다. (<a href=\"https://nukeguys.github.io/dev/react-hooks/\">react hooks 복습하기</a> 참고)</p>\n<p>그렇다면 <code>memo</code>는 항상 사용하는 것이 좋겠다는 생각을 할 수도 있다. 물론 대부분의 경우에는 효과를 볼 수도 있겠지만 <code>memo</code>도 내부적으로는 <code>useMemo</code>와 같이 동작을 하기 때문에 추가적인 비용이 들게 된다. 즉 매번(또는 빈번하게) 변경되는 컴포넌트에 적용하게 되면 렌더링은 그대로 유지되면서 추가적인 비용만 더 가중시키는 셈이다. 대표적으로 prpos로 <code>children</code>을 받아서 사용하는 컴포넌트를 들 수 있는데, 일반적으로 children은 매번 변경되거나 별도로 memoization을 하는 경우가 많지 않기 때문이다.</p>\n<p>그래서 일단 적용하지 않은 상태로 구현한 뒤에 propfiling을 통해 필요한 곳에 <code>memo</code>를 적용하는 것을 권장한다.</p>\n<p>이번엔 react development tool을 사용해서 렌더링 성능을 측정하고 개선하는 방법을 간단히 정리해봤다. 다음엔 browser의 렌더링 과정과 측정하는 방법을 정리해 볼 예정이다.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>react의 lifecyle은 크게 render와 commit으로 나뉜다. render를 수행한 후 변경된 사항을 DOM에 반영하는 과정이다.(<a href=\"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">React lifecycle methods diagram</a>)</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","fields":{"slug":"/dev/react-optimizing-performance/"},"frontmatter":{"date":"2019/08/04","title":"react dev tool로 성능 측정 해보기","description":"react 성능 측정 및 최적화","tags":["react","performance","developer tool","useMemo","useCallback","reconciliation","layout","repaint"]}}},{"node":{"excerpt":"Frontend를 시작한지 얼마 되지 않았지만 그 짧은 사이에도 크고 작은 것들이 많이 변화했다. 정말 빠르구나 싶기도 하고 그런게 나름 또 이 세계의 재미가 아닌가 싶기도 하다. React도 16.8이 릴리즈 되면서 hooks라는 api…","html":"<p>Frontend를 시작한지 얼마 되지 않았지만 그 짧은 사이에도 크고 작은 것들이 많이 변화했다. 정말 빠르구나 싶기도 하고 그런게 나름 또 이 세계의 재미가 아닌가 싶기도 하다.</p>\n<p>React도 16.8이 릴리즈 되면서 hooks라는 api가 새롭게 등장했다. 익숙해 지려고 할 때 쯤 새로운 놈이 등장해서 다시 또 적응을 해야했고 지금은 나름 열심히 사용하고 있긴하지만 이쯤에서 자주 쓰는 hooks에 대해 정리를 한 번 해볼까한다. (물론 틀린 내용이 있을 수 있고, 주관적인 생각이 포함되어 있을 수 있다.)</p>\n<p>우선 각 hook에 대해 정리하기 전에 hooks라는 이름에 대해 생각해 볼 필요가 있지 싶다. react 문서에서는 hook을 아래처럼 설명하고 있다.</p>\n<blockquote>\n<p>Hooks are functions that let you “hook into” React state and lifecycle features from function components. (<a href=\"https://reactjs.org/docs/hooks-overview.html#but-what-is-a-hook\">Hooks at a Glance – React</a>)</p>\n</blockquote>\n<p>state와 lifecycle을 <code>hook into</code>한다라는게 바로 와닿지는 않는다. 번역하면 연동한다/끌어드린다/밀어넣는다 정도로 될 듯하다.\nhook이라는 단어는 <code>web-hook</code>이나 <code>hooking</code>처럼 흔하게 사용되는 말로 중간에 동작을 가로챈다는 의미로 보는게 이해가 빠를 것 같다. 따라서 react의 hook도 lifecycle 과정에서 state와 관련된 동작을 수행 할 수 있도록 해준다는 의미로 이해하면 될 것 같다.</p>\n<h2>useState</h2>\n<p>class형 컴포넌트에서 <code>this.state</code>와 <code>setState</code>의 역할을 하는 hook이다.</p>\n<pre><code class=\"language-ts\">const [state, setState] = useState(initialState);\n</code></pre>\n<p>공식문서에 나와있는 이전방식과 hook의 코드도 비교해보자.(<a href=\"https://reactjs.org/docs/hooks-state.html\">Using the State Hook – React</a>)</p>\n<p>하나의 객체가 아니라 필요한 state를 개별로 접근하고 변경할 수 있다는 점에서 관리와 사용이 훨씬 깔끔해진 느낌이다. <code>useState</code>를 사용할 때 주의해야 할 부분도 있다. 우선 class형 컴포넌트 안에서는 사용할 수 없고, setState와 다르게 merge가 아닌 replace된다는 점이다. 두 번째는 setter의 인자로 값이 아닌 함수를 전달할 수 도 있다는 점이다. count를 증가시키는 코드를 예로 보면 일반적으로 아래처럼 할 수 있다.</p>\n<pre><code class=\"language-ts\">const increaseCount = () => {\n  setCount(count + 1);\n};\n</code></pre>\n<p>하지만 setCount를 비동기 callback에서 호출하는 경우에 원하는 대로 count가 증가하지 않는 경우를 경험할 수 있다. 이유는 callback 등록 시점에 함수가 생성되면서 count 값이 고정되어 버리기 때문이다. 처음에 같은 문제를 겪고 한참을 헤맸던 기억이 있다. 이런 경우에는 아래처럼 setCount에 함수(이전 state값을 받아서 새로운 state를 반환하는)를 전달하면 해결 할 수 있다.</p>\n<pre><code class=\"language-ts\">const increaseCount = () => {\n  setCount(prevCount => prevCount + 1);\n};\n</code></pre>\n<p>물론 위의 경우처럼 단순하게 처리가 불가능한 경우가 있을 수도 있다. 또 state 뿐 아니라 props에 대해서도 동일한 문제가 발생할 수 있다. 그런 경우에는 state를 객체로 변경해서 사용하거나, <code>useRef</code>를 사용해 state 또는 props를 별도의 변수로 저장해서 접근해야 한다.</p>\n<p>추가로 useSate의 초기값으로도 함수를 전달할 수 있다. 이는 초기값 계산의 cost가 높은 경우에 초기화를 지연시키는 역할을 한다.</p>\n<h2>useRef</h2>\n<p>위에서 언급한 <code>useRef</code>도 간단히 정리해본다.</p>\n<pre><code class=\"language-ts\">const refContainer = useRef(initialValue);\n</code></pre>\n<p>이름에서 유추 가능한 것 처럼, 원하는 값을 객체로 warraping해서 <code>current</code>라는 속성으로 접근할 수 있게 해준다. 보통 DOM의 reference를 담아두는데 사용하지만 class의 멤버 변수처럼 사용하는 것이 가능하다.</p>\n<p>어렵지 않지만 실제로 구현된 아래 코드를 보면 더 쉽게 이해가 된다. (<a href=\"https://github.com/facebook/react/blob/42b75ab007a5e7c159933cfdbf2b6845d89fc7f2/packages/react-reconciler/src/ReactFiberHooks.js#L856-L869\">ReactFiberHooks.js · GitHub</a>)</p>\n<pre><code class=\"language-ts\">function mountRef&#x3C;T>(initialValue: T): { current: T } {\n  const hook = mountWorkInProgressHook();\n  const ref = { current: initialValue };\n  if (__DEV__) {\n    Object.seal(ref);\n  }\n  hook.memoizedState = ref;\n  return ref;\n}\n\nfunction updateRef&#x3C;T>(initialValue: T): { current: T } {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n</code></pre>\n<p>최초에는 ref라는 객체를 만들어 current 속성에 초기값을 설정해서 반환하고, 이후부터는 해당 객체를 반환한다.</p>\n<p>참고로 react의 hooks는 <code>mountXXX</code>와 <code>updateXXX</code>라는 이름으로 최초 실행과 이후 업데이트에서 사용하는 함수가 각각 분리되어 구현 되어 있다.</p>\n<h2>useImperativeHandle &#x26; forwardRef</h2>\n<pre><code class=\"language-ts\">useImperativeHandle(ref, createHandle, [deps]);\n</code></pre>\n<p><code>useImperativeHandle</code>은 부모에게 원하는 interface를 통해 ref를 사용할 수 있게 해준다. 즉, 부모가 자식의 ref를 직접 받아서 접근할 수도 있지만, 제한하거나 커스터마이징해서 제공을 하고 싶을 때 사용하면 된다. <code>useImperativeHandle</code>은 <code>forwardRef</code>와 함께 사용해야 하는데 간단한 사용법은 아래와 같다.</p>\n<pre><code class=\"language-ts\">function FancyInput(props, ref) {\n  const inputRef = useRef();\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      inputRef.current.focus();\n    }\n  }));\n  return &#x3C;input ref={inputRef} ... />;\n}\nFancyInput = forwardRef(FancyInput);\n</code></pre>\n<h2>useEffect</h2>\n<p><code>useState</code>와 더불어 가장 자주 사용하고 중요한 hook중의 하나이다.</p>\n<pre><code class=\"language-ts\">useEffect(didUpdate);\n</code></pre>\n<p>공식문서의 정의는 아래처럼 되어있다.</p>\n<blockquote>\n<p>The Effect Hook lets you perform side effects in function components.</p>\n</blockquote>\n<p>함수형 컴포넌트에서 <code>side effects</code>를 수행할 수 있게 해준다라는 의미가 바로 와닿지는 않는다. 그래서 문서를 조금 더 살펴보면 이런 내용도 있다.</p>\n<blockquote>\n<p>Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you’re used to calling these operations “side effects” (or just “effects”), you’ve likely performed them in your components before.</p>\n</blockquote>\n<p>즉, 컴포넌트 내부에서 수행하던 <code>data fetching</code>, <code>subscription(이벤트 등록/해제 같은)</code>, <code>manaual한 DOM변경</code> 등과 같은 state를 직접 처리하는 이외의 동작이나 기능들을 <code>side effect</code> 또는 <code>effect</code>로 부르고 있다.</p>\n<p><code>useEffect</code>가 중요한 이유 중의 하나는 react의 <code>lifecycle</code>과 밀접하게 관련이 있기 때문이다.\n기본적으로 렌더링이 완료된 이후에 실행 되는데 두번째 인자인 <code>deps</code>를 통해 실행 여부를 결정할 수 있기 때문에 class 컴포넌트에 있던 <code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>와 같은 lifecycle과 비슷한 역할을 할 수 있다.</p>\n<p>기존 방식과의 차이점은 문서를 확인하면 명확하게 알 수 있다.(<a href=\"https://reactjs.org/docs/hooks-effect.html\">Using the Effect Hook – React</a>)</p>\n<p><code>useEffect</code>에서 함수를 리턴할 수 있는데 이 함수는 다음 effect발생하기 전에 호출이 되기 때문에 메모리 정리나 구독해제 같은 기능을 처리할 수 있다. (<code>componentDidMount</code>에서 등록하고 <code>componentWillUnmount</code>에서 해제하는 것과 유사한 동작)</p>\n<pre><code class=\"language-ts\">useEffect(() => {\n  const subscription = props.source.subscribe();\n  return () => {\n    subscription.unsubscribe();\n  };\n});\n</code></pre>\n<p>그런데 위의 코드를 수행하면 매 렌더링시마다 구독/해제가 일어나기 때문에 비효율적이다. 이런 문제를 해결하기 위해서 위에서 언급한 대로 두번째 인자로 <code>deps(dependencies)</code>를 전달할 수 있다. <code>deps</code>는 배열 형식으로 전달하고, 배열의 각 아이템을 shallow하게 비교해서 변경이 발생한 경우에만 effect가 실행된다. 위 코드처럼 전달하지 않으면 매번 실행이 되고, 빈배열(<code>[ ]</code>)을 전달하면 mount/unmount시에만 호출이 된다. 위 코드에서는 props의 source에 접근하고 있기 때문에 그 값이 변할 경우에만 구독/해제를 할 필요가 있다. 따라서 아래처럼 해주면 원하는 효과를 볼 수 있다.</p>\n<pre><code class=\"language-ts\">useEffect(() => {\n  const subscription = props.source.subscribe();\n  return () => {\n    subscription.unsubscribe();\n  };\n}, [props.source]);\n</code></pre>\n<p>여기서 주의할 점은, 컴포넌트 범위에서 변경될 수 있는 값(state나 props같은)을 누락하게 되면 원하는 동작을 하지 않을 수 있다는 점이다. 예로 위의 코드에서 deps에 []를 넣게 되면, props의 source가 변경되어도 구독은 계속 이전 source에 된 상태로 남아있게 된다.</p>\n<p><code>useEffect</code>에서 직접적인 접근이 없지만 호출하는 함수에서 변경되는 값이 존재하는 경우에도 마찬가지로 추가를 해줘야 하지만 쉽게 인지하기 어려울 수도 있기 때문에 react에서는 <code>eslint-plugin-react-hooks</code>의\n<a href=\"https://github.com/facebook/react/issues/14920\">exhaustive-deps</a> lint rule을 사용하는 것을 권장하고 있다.</p>\n<h2>useCallback</h2>\n<p>callback의 memoization을 만들어주는 hook이다. 즉, 매번 동일한 함수를 생성하는 것이 아니라 변경될 필요가 없는 경우 이전에 생성된 함수를 반환해주는 기능을 한다.</p>\n<pre><code class=\"language-ts\">const memoizedCallback = useCallback(() => {\n  doSomething(a, b);\n}, [a, b]);\n</code></pre>\n<p><code>useCallback</code>이 유용성은 react의 특성을 이해하면 알기 쉽다. 자식에게 callback을 전달하는 경우에 부모가 렌더링 되면서 매번 새로 생성된다면 자식입장에서는 props가 변경되기 때문에 함께 렌더링이 발생하게 되는 것이다. 이런 경우 사용하면 memoization된 callback을 전달함으로써 불필요한 렌더링을 방지할 수 있게 되는 것이다. 자식에서 <code>shouldComponentUpdate</code>를 통해 변경여부를 직접 비교해서 렌더링을 결정하는 효과를 간단히 볼 수 있게 된다. 마찬가지로 callback은 <code>deps</code>에 따라 변경여부를 결정하기 때문에 주의해서 사용할 필요가 있다.</p>\n<h2>useMemo</h2>\n<p><code>useCallback</code>이 memoization된 함수를 반환해 주었다면 <code>useMemo</code>는 memoization된 값을 반환해 준다.</p>\n<pre><code class=\"language-ts\">const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n</code></pre>\n<p><code>deps</code>가 변경된 경우에만 전달된 함수를 호출하여 결과를 반환하기 때문에 cost가 많은 처리를 필요할 때만 수행하도록 할 수 있다. 주의할 점은 <code>useMemo</code>는 렌더링 중에 실행되기 때문에 계산이 아닌 <code>sideEffect</code>(위에서 언급한)를 수행하면 안된다는 것이다. 또한 이후 버전에서는 매번 재계산하는 방식을 택할 수도 있기 때문에 <code>useMemo</code>는 성능 최적화의 목적으로만 사용해야 한다.</p>\n<p>그 외에 <code>useContext</code>, <code>useReducer</code>, <code>useLayoutEffect</code> 등이 있지만 어렵지 않고 사용빈도도 많지 않기 때문에 생략한다. (공식문서를 보면 쉽게 이해할 수 있다.)</p>\n<p>추가로 <code>customHook</code>을 만들어 사용할 수도 있는데, 공식문서(<a href=\"https://reactjs.org/docs/hooks-custom.html\">Building Your Own Hooks – React</a>)를 보면 간단하게 방법을 알 수 있다. 유용한 custom hook은 <a href=\"https://usehooks.com/\">useHooks - Easy to understand React Hook recipes</a>를 참고하면 작성과 사용법을 아는데 도움이 된다.</p>\n<p>간단하게 hook의 내용과 사용법들을 정리해 봤다. 사실 각각 hook을 사용하면서 고민하거나 헤맸던 부분들에 대해서 정리를 하는게 목적이었으나 그 전에 간단히 기본적인 내용들을 먼저 정리해봤다. 이후에 시간이 되면 <code>useEffect</code>와 <code>useCallback</code>의 <code>deps</code>를 사용하면서 들었던 고민들이나 퍼포먼스를 올리기 위해 하고 있는 삽질들을 다시 한 번 정리해볼 예정이다.</p>","fields":{"slug":"/dev/react-hooks/"},"frontmatter":{"date":"2019/07/28","title":"react hooks 복습하기","description":"익숙할 때 쯤 정리해보는 react hooks","tags":["react","hooks","useState","useRef","useImperativeHandle","forwardRef","useEffect","useCallback","useMemo"]}}},{"node":{"excerpt":"Do's and Don'ts General Types Number, String, Boolean, and Oject Don't\nNumber, String, Boolean 또는 Object 타입을 절대 사용하지 마라. 이 타입들은 JavaScript…","html":"<h1>Do's and Don'ts</h1>\n<h2>General Types</h2>\n<h3>Number, String, Boolean, and Oject</h3>\n<p><strong><em>Don't</em></strong>\n<code>Number</code>, <code>String</code>, <code>Boolean</code> 또는 <code>Object</code> 타입을 절대 사용하지 마라. 이 타입들은 JavaScript 코드에서 대부분 적절하지 않게 사용되는 non-primitive boxed object<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>들을 의미한다.</p>\n<pre><code class=\"language-ts\">/* WRONG */\nfunction reverse(s: String): String;\n</code></pre>\n<p><strong><em>Do</em></strong>\n<code>number</code>, <code>string</code> 그리고 <code>boolean</code>을 사용하라.</p>\n<pre><code class=\"language-ts\">/* OK */\nfunction reverse(s: string): string;\n</code></pre>\n<p><code>Object</code> 대신 non-primitive인 <code>object</code> 타입을 사용하라 (<a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type\">TypeScript 2.2</a>에 추가됨).</p>\n<h4>Generic</h4>\n<p><strong><em>Don't</em></strong>\n타입 매개변수를 사용하지 않는 generic 타입을 사용하지 마라. 더 자세한 내용은 <a href=\"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---\">TypeScript FAQ page</a>에서 확인.<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></p>\n<h2>Callback Types</h2>\n<h3>Return Types of Callbacks</h3>\n<p><strong><em>Don't</em></strong>\n값이 무시될 콜백의 리턴타입으로 <code>any</code>를 사용하지 마라.</p>\n<pre><code class=\"language-ts\">/* WRONG */\nfunction fn(x: () => any) {\n  x();\n}\n</code></pre>\n<p><strong><em>Do</em></strong>\n값이 무시될 콜백의 리턴타입으로 <code>void</code>를 사용하라.</p>\n<pre><code class=\"language-ts\">/* OK */\nfunction fn(x: () => void) {\n  x();\n}\n</code></pre>\n<p><strong><em>Why</em></strong>\n확인되지 않는 방법으로 <code>x</code>의 리턴타입을 사용하는 실수를 방지해주기 때문에 <code>void</code>를 사용하는 것이 더 안전하다.</p>\n<pre><code class=\"language-ts\">function fn(x: () => void) {\n  var k = x(); // oops! meant to do something else\n  k.doSomething(); // error, but would be OK if the return type had been 'any'\n}\n</code></pre>\n<h3>Optional Paameters in Callbacks</h3>\n<p><strong><em>Don't</em></strong>\n의도한 경우를 제외하고는 선택적 매개변수를 사용하지 마라.</p>\n<pre><code class=\"language-ts\">/* WRONG */\ninterface Fetcher {\n  getObject(done: (data: any, elapsedTime?: number) => void): void;\n}\n</code></pre>\n<p>이것은 매우 분명한 의미를 갖는다. : <code>done</code> 콜백은 1개 또는 2개의 매개변수를 가지고 호출된다. 작성자는 아마 콜백이 <code>elapsedTime</code> 매개변수에 대해 신경쓰지 않는다는 것을 의도했을 것이다. 그러나 그것을 위해 선택적 매개변수로 만들 필요는 없다. - 더 적은 매개변수를 받는 콜백을 전달하는 것은 언제나 적합하다.<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup></p>\n<p><strong><em>Do</em></strong>\n콜백의 파라미터를 필수(non-optional) 파라미터로 작성하라.</p>\n<pre><code class=\"language-ts\">/* OK */\ninterface Fetcher {\n  getObject(done: (data: any, elapsedTime: number) => void): void;\n}\n</code></pre>\n<h3>Overloads and Callbacks</h3>\n<p><strong><em>Don't</em></strong>\n콜백만 다른 별도의 타입 시그니처(overload)를 작성하지 마라.</p>\n<pre><code class=\"language-ts\">/* WRONG */\ndeclare function beforeAll(action: () => void, timeout?: number): void;\ndeclare function beforeAll(\n  action: (done: DoneFn) => void,\n  timeout?: number\n): void;\n</code></pre>\n<p><strong><em>Do</em></strong>\n모든 것을 포함하는 타입 시그니처 하나만 작성하라.</p>\n<pre><code class=\"language-ts\">/* OK */\ndeclare function beforeAll(\n  action: (done: DoneFn) => void,\n  timeout?: number\n): void;\n</code></pre>\n<p><strong><em>Why</em></strong>\n콜백에서 매개변수를 무시하는 것은 언제나 적합하다.(역자:<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>과 같은 의미이다.) 따라서 더 간단한 타입 시그니처는 필요하지 않다. 간단한 타입 시그니처를 제공하는 것은 타입이 잘못된 함수가 첫번째 함수 시그니처와 매칭되어 전달되는 것을 허용한다.<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup></p>\n<h3>Function Overloads</h3>\n<h4>Ordering</h4>\n<p><strong><em>Don't</em></strong>\n더 구체적인 시그니처 전에 일반적인 시그니처를 두지 마라.</p>\n<pre><code class=\"language-ts\">/* WRONG */\ndeclare function fn(x: any): any;\ndeclare function fn(x: HTMLElement): number;\ndeclare function fn(x: HTMLDivElement): string;\n\nvar myElem: HTMLDivElement;\nvar x = fn(myElem); // x: any, wat?\n</code></pre>\n<p><strong><em>Do</em></strong>\n더 구체적인 시그니처 다음에 일반적인 시그니처를 두도록 정렬하라.</p>\n<pre><code class=\"language-ts\">/* OK */\ndeclare function fn(x: HTMLDivElement): string;\ndeclare function fn(x: HTMLElement): number;\ndeclare function fn(x: any): any;\n\nvar myElem: HTMLDivElement;\nvar x = fn(myElem); // x: string, :)\n</code></pre>\n<p><strong><em>Why</em></strong>\nTypeScript는 함수 호출을 결정할 때 처음 매칭되는 시그니처를 서낵한다. 먼저 나오는 시그니처가 뒤의 시그니처보다 더 일반적일 경우, 뒤에 나오는 것은 완벽히 가려지고 호출될 수 없다.</p>\n<h3>Use Optional Parameters</h3>\n<p><strong><em>Don't</em></strong>\n뒤에 나오는 매개변수들만 다른 경우 여러 시그니처를 작성하지 마라.</p>\n<pre><code class=\"language-ts\">/* WRONG */\ninterface Example {\n  diff(one: string): number;\n  diff(one: string, two: string): number;\n  diff(one: string, two: string, three: boolean): number;\n}\n</code></pre>\n<p><strong><em>Do</em></strong>\n가능한 경우에는 선택적 매개변수를 사용하라.</p>\n<pre><code class=\"language-ts\">/* OK */\ninterface Example {\n  diff(one: string, two?: string, three?: boolean): number;\n}\n</code></pre>\n<p>이 방법은 모든 시그니처의 리턴타입이 같은 경우에만 가능하다는 것을 주의하라.</p>\n<p><strong><em>Why</em></strong>\n여기엔 두 가지 중요한 이유가 있다.</p>\n<p>TypeScript는 source의 매개변수로 target의 시그니처 호출할 수 있는지, 그리고 관련없는 매개변수가 허용되는지를 보고 시그니처 호환성을 결정한다. 예를 들어, 이 코드는 시그니처가 선택적 매개변수를 사용하여\n정확히 작성된 경우에만 버그를 발생시킨다.</p>\n<pre><code class=\"language-ts\">function fn(x: (a: string, b: number, c: number) => void) {}\nvar x: Example;\n// 오버로딩으로 작성되어 있으면, OK -- 첫 번째 시그니처를 사용\n// 선택적 매개변수로 작성되어 있으면, 에러\nfn(x.diff);\n</code></pre>\n<p>두 번째 이유는 TypeScript의 <code>stric null checking</code> 기능을 사용하는 경우이다. JavaScript에서 명시되지 않은 매개변수는 <code>undefined</code>로 표현되기 때문에, 일반적으로 선택적 매개변수를 가진 함수에 <code>undefined</code>를 명시적으로 전달하는 것이 좋다. 예를 들어 이 코드는 strict null을 사용하는 경우에도 문제없다.</p>\n<pre><code class=\"language-ts\">var x: Example;\n// 오버로딩으로 작성되어 있으면, `undefined`를 `string` 타입으로 전달하기 때문에 에러\n// 선택적 매개변수로 작성되어 있으면, 정상\nx.diff('something', true ? undefined : 'hour');\n</code></pre>\n<h3>Use Union Types</h3>\n<p><strong><em>Don't</em></strong>\n오직 하나의 매개변수 타입이 다른 경우에는 오버로딩을 사용하지 마라.</p>\n<pre><code class=\"language-ts\">/* WRONG */\ninterface Moment {\n  utcOffset(): number;\n  utcOffset(b: number): Moment;\n  utcOffset(b: string): Moment;\n}\n</code></pre>\n<p><strong><em>Do</em></strong>\n가능한 경우에는 유니온 타입을 사용하라.</p>\n<pre><code class=\"language-ts\">/* OK */\ninterface Moment {\n  utcOffset(): number;\n  utcOffset(b: number | string): Moment;\n}\n</code></pre>\n<p>시그니처의 리턴타입이 다르기 때문에 <code>b</code>를 선택적 매개변수로 하지 않은 것을 주의하라.</p>\n<p><strong><em>Why</em></strong>\n이것은 함수에 값을 그대로 전달하는 사람들에게 중요하다.</p>\n<pre><code class=\"language-ts\">function fn(x: string): void;\nfunction fn(x: number): void;\nfunction fn(x: number | string) {\n  // 오버로딩으로 작성되어 있으면, 에러\n  // 유니온 타입으로 작성되어 있으면, 정상\n  return moment().utcOffset(x);\n}\n</code></pre>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>primitive타입이 아닌 boxing된 object형 타입. 따라서 <code>Numer.MAX_VALUE</code>나 <code>Number.isSafeInteger()</code>등으로 사용가능하다.</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p>generic으로 선언하고 내부에서 사용하지 않는 경우를 만들지 말라는 의미로, FAQ 페이지를 보면 해당 타입 매개변수를 사용하는 부분이 없으면 타입추론이 제대로 이루어지지 않는다고 한다.</p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p>매개변수의 개수에 대한 함수의 타입 호환성에서 할당받는 함수의 매개변수가 더 많은 경우는 호환이 가능하기 때문이다. 자주 사용하는 <code>map()</code>,<code>filter()</code> 같은 함수에 매개변수 하나만 사용하는 콜백을 넘기는 경우를 생각하면 쉽다.</p>\n<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-4\">\n<p>호출하는 쪽에서는 항상 정해진 수의 매개변수를 전달하고 콜백에서 필요한 만큼만 받아서 사용해야 하는데, 매개변수 개수가 적은 시그니처가 있으면 호출하는 쪽에서 매개변수를 적게 전달하는 실수가 허용된다.</p>\n<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","fields":{"slug":"/dev/ts-do-and-dont/"},"frontmatter":{"date":"2019/02/11","title":"[번역] TypeScript의 Do's and Don'ts","description":"TypeScript 공식 documentation의 Do's and Don'ts를 번역해 보았다.","tags":["TIL","typscript"]}}},{"node":{"excerpt":"MS에서도 엣지에 크로미움을 사용한다고 발표한 상황에서, 팀에서도 IE10을 더이상 지원하지 않기 위한 근거로 서비스 접속 대한 브라우저 통계가 필요했다. 가이드를 통해 nginx의 access 로그와 GoAccess…","html":"<p>MS에서도 엣지에 크로미움을 사용한다고 발표한 상황에서, 팀에서도 IE10을 더이상 지원하지 않기 위한 근거로 서비스 접속 대한 브라우저 통계가 필요했다.<br>\n가이드를 통해 nginx의 access 로그와 <a href=\"https://goaccess.io/\">GoAccess</a>에 대해 알게 되었고 이를 사용하여 간단하게 로그 분석을 해봤다.\n단순하게 사용만 해본 터라 깊이는 없지만 오랜만에 사용해본 쉘 명령어도 되짚어 볼 겸 간단하게 정리해 본다.</p>\n<p>우선 서버에서 원격으로 접근 가능한 위치에 받아올 로그 파일을 미리 복사해 두고 scp를 통해 내려 받아 압축을 해제한다. (회사에서는 일주일 단위로 로그를 압축하여 백업하고 있었고, 실 서비스 서버이므로 로컬 PC로 로그파일을 내려 받아서 진행했다.)</p>\n<pre><code class=\"language-bash\"># scp로 로그파일 내려받기\nscp 계정@호스트:파일경로 저장할파일이름   # 원하는 파일만\nscp -r 계정@호스트:폴더경로 ./ # 폴더 통째로\n\n# gzip/gunzip으로 압축 해제하기\ngzip -d access.log-xxxxxxxx.gz # (gunzip access.log-xxxxxxxx.gz) 원하는 파일만\ngunzip -r ./accesslog # 폴더의 압축파일들을 한 번에 해제\n</code></pre>\n<p>로그파일이 준비됐으니 GoAccess를 설치한다.</p>\n<pre><code class=\"language-bash\">brew install goaccess\n</code></pre>\n<p>GoAccess로 분석을 하기위해 로그파일의 포맷을 설정파일에 명시해야 한다. <code>time-format</code>, <code>date-format</code>, <code>log-format</code> 세 가지만 설정 해주고, 로그가 표준화된 형식일 경우 실행시에 옵션으로 넣어줘도 되는 듯 하다.<br>\n미리 정의된 형식이 주석으로 있으니 해제하여 사용하거나 없으면 맞게 작성해주면 된다. 내 PC의 설정파일의 위치는 <code>/usr/local/Cellar/goaccess/1.2_1/etc/goaccess.conf</code>였다.</p>\n<pre><code class=\"language-bash\">######################################\n# Time Format Options (required)\n######################################\ntime-format %H:%M:%S\n\n######################################\n# Date Format Options (required)\n######################################\ndate-format %d/%b/%Y\n\n######################################\n# Log Format Options (required)\n######################################\nlog-format %h - %^ [%d:%t %^]  \"%r\" %s %b \"%R\" \"%u\" %T \"%^\"\n</code></pre>\n<p>GoAccess를 사용하기 전에 필요한 로그를 가공 할 필요가 있었다.\n<a href=\"https://page.kakao.com\">카카오페이지 웹</a>의 경우 PC와 모바일 버전이 다르고(당연히), 모바일의 경우 앱 내에서 호출하는 경우가 있어 제외시켜야 했다. 추가로 리다이렉션(응답코드 30X) 되는 경우도 로그가 중복이기 때문에 제외 시켰다.</p>\n<pre><code class=\"language-bash\"># 앱에서 호출하는 경우 userAgent에 KakaoPage가 포함된다.\nsed '/KaKaoPage/d' access.log-xxxxxxxx > 1_only_web\n# 응답코드 30X인 레코드를 제외시킨다.(더 정확하게 할 수 있겠지만 이 정도만 해도 충분했다.)\nsed '/\" 30. /d' 1_only_web > 2_delete_redirect\n</code></pre>\n<p>GoAccess를 실행시켜 로그 파일을 분석하고 결과를 html파일로 만든다. (결과 화면은 <a href=\"https://goaccess.io/\">https://goaccess.io/</a>를 참고)</p>\n<pre><code class=\"language-bash\">goaccess 2_delete_redirect -a -o 2_delete_redirect.html\n</code></pre>\n<p>결과를 대략 정리해 보면 크롬이 대부분을 차지했고, IE와 엣지는 통틀어 3%가 되지 않았다. IE10은 약 20명 내외였으며 서버 수를 고려한다 해도 절대치가 미미한 수준이었다. 아마도 이제 IE10 지원에 대한 고민은 하지 않아도 될 듯 하다.</p>","fields":{"slug":"/dev/goaccess-analyzer/"},"frontmatter":{"date":"2019/01/24","title":"[TIL] GoAccess로 nginx access 로그 분석 겉핥기","description":"브라우저별 접속 통계 확인을 위한 GoAccess 사용기","tags":["TIL","GoAccess","nginx","IE10"]}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}