{"componentChunkName":"component---src-pages-dev-tsx","path":"/dev/","webpackCompilationHash":"b76d519b42708c11ec6d","result":{"data":{"site":{"siteMetadata":{"title":"nukeguys blog","description":"about development, life and something.","siteUrl":"https://nukeguys.github.io"}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"Frontend를 시작한지 얼마 되지 않았지만 그 짧은 사이에도 크고 작은 것들이 많이 변화했다. 정말 빠르구나 싶기도 하고 그런게 나름 또 이 세계의 재미가 아닌가 싶기도 하다. React도 16.8이 릴리즈 되면서 hooks라는 api…","html":"<p>Frontend를 시작한지 얼마 되지 않았지만 그 짧은 사이에도 크고 작은 것들이 많이 변화했다. 정말 빠르구나 싶기도 하고 그런게 나름 또 이 세계의 재미가 아닌가 싶기도 하다.</p>\n<p>React도 16.8이 릴리즈 되면서 hooks라는 api가 새롭게 등장했다. 익숙해 지려고 할 때 쯤 새로운 놈이 등장해서 다시 또 적응을 해야했고 지금은 나름 열심히 사용하고 있긴하지만 이쯤에서 자주 쓰는 hooks에 대해 정리를 한 번 해볼까한다. (물론 틀린 내용이 있을 수 있고, 주관적인 생각이 포함되어 있을 수 있다.)</p>\n<p>우선 각 hook에 대해 정리하기 전에 hooks라는 이름에 대해 생각해 볼 필요가 있지 싶다. react 문서에서는 hook을 아래처럼 설명하고 있다.</p>\n<blockquote>\n<p>Hooks are functions that let you “hook into” React state and lifecycle features from function components. (<a href=\"https://reactjs.org/docs/hooks-overview.html#but-what-is-a-hook\">Hooks at a Glance – React</a>)</p>\n</blockquote>\n<p>state와 lifecycle을 <code>hook into</code>한다라는게 바로 와닿지는 않는다. 번역하면 연동한다/끌어드린다/밀어넣는다 정도로 될 듯하다.\nhook이라는 단어는 <code>web-hook</code>이나 <code>hooking</code>처럼 흔하게 사용되는 말로 중간에 동작을 가로챈다는 의미로 보는게 이해가 빠를 것 같다. 따라서 react의 hook도 lifecycle 과정에서 state와 관련된 동작을 수행 할 수 있도록 해준다는 의미로 이해하면 될 것 같다.</p>\n<h2>useState</h2>\n<p>class형 컴포넌트에서 <code>this.state</code>와 <code>setState</code>의 역할을 하는 hook이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> setState<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span>initialState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>공식문서에 나와있는 이전방식과 hook의 코드도 비교해보자.(<a href=\"https://reactjs.org/docs/hooks-state.html\">Using the State Hook – React</a>)</p>\n<p>하나의 객체가 아니라 필요한 state를 개별로 접근하고 변경할 수 있다는 점에서 관리와 사용이 훨씬 깔끔해진 느낌이다. <code>useState</code>를 사용할 때 주의해야 할 부분도 있다. 우선 class형 컴포넌트 안에서는 사용할 수 없고, setState와 다르게 merge가 아닌 replace된다는 점이다. 두 번째는 setter의 인자로 값이 아닌 함수를 전달할 수 도 있다는 점이다. count를 증가시키는 코드를 예로 보면 일반적으로 아래처럼 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">increaseCount</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>하지만 setCount를 비동기 callback에서 호출하는 경우에 원하는 대로 count가 증가하지 않는 경우를 경험할 수 있다. 이유는 callback 등록 시점에 함수가 생성되면서 count 값이 고정되어 버리기 때문이다. 처음에 같은 문제를 겪고 한참을 헤맸던 기억이 있다. 이런 경우에는 아래처럼 setCount에 함수(이전 state값을 받아서 새로운 state를 반환하는)를 전달하면 해결 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">increaseCount</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prevCount</span> <span class=\"token operator\">=></span> prevCount <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>물론 위의 경우처럼 단순하게 처리가 불가능한 경우가 있을 수도 있다. 또 state 뿐 아니라 props에 대해서도 동일한 문제가 발생할 수 있다. 그런 경우에는 state를 객체로 변경해서 사용하거나, <code>useRef</code>를 사용해 state 또는 props를 별도의 변수로 저장해서 접근해야 한다.</p>\n<p>추가로 useSate의 초기값으로도 함수를 전달할 수 있다. 이는 초기값 계산의 cost가 높은 경우에 초기화를 지연시키는 역할을 한다.</p>\n<h2>useRef</h2>\n<p>위에서 언급한 <code>useRef</code>도 간단히 정리해본다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> refContainer <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span>initialValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이름에서 유추 가능한 것 처럼, 원하는 값을 객체로 warraping해서 <code>current</code>라는 속성으로 접근할 수 있게 해준다. 보통 DOM의 reference를 담아두는데 사용하지만 class의 멤버 변수처럼 사용하는 것이 가능하다.</p>\n<p>어렵지 않지만 실제로 구현된 아래 코드를 보면 더 쉽게 이해가 된다. (<a href=\"https://github.com/facebook/react/blob/42b75ab007a5e7c159933cfdbf2b6845d89fc7f2/packages/react-reconciler/src/ReactFiberHooks.js#L856-L869\">ReactFiberHooks.js · GitHub</a>)</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> mountRef<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>initialValue<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> current<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">mountWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> ref <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> current<span class=\"token punctuation\">:</span> initialValue <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__DEV__<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">seal</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> ref<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> ref<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> updateRef<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>initialValue<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> current<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>최초에는 ref라는 객체를 만들어 current 속성에 초기값을 설정해서 반환하고, 이후부터는 해당 객체를 반환한다.</p>\n<p>참고로 react의 hooks는 <code>mountXXX</code>와 <code>updateXXX</code>라는 이름으로 최초 실행과 이후 업데이트에서 사용하는 함수가 각각 분리되어 구현 되어 있다.</p>\n<h2>useImperativeHandle &#x26; forwardRef</h2>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">useImperativeHandle</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">,</span> createHandle<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>deps<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code>useImperativeHandle</code>은 부모에게 원하는 interface를 통해 ref를 사용할 수 있게 해준다. 즉, 부모가 자식의 ref를 직접 받아서 접근할 수도 있지만, 제한하거나 커스터마이징해서 제공을 하고 싶을 때 사용하면 된다. <code>useImperativeHandle</code>은 <code>forwardRef</code>와 함께 사용해야 하는데 간단한 사용법은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">FancyInput</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props<span class=\"token punctuation\">,</span> ref</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> inputRef <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">useImperativeHandle</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">focus</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      inputRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">.</span><span class=\"token function\">focus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>input ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>inputRef<span class=\"token punctuation\">}</span> <span class=\"token operator\">...</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nFancyInput <span class=\"token operator\">=</span> <span class=\"token function\">forwardRef</span><span class=\"token punctuation\">(</span>FancyInput<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>useEffect</h2>\n<p><code>useState</code>와 더불어 가장 자주 사용하고 중요한 hook중의 하나이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span>didUpdate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>공식문서의 정의는 아래처럼 되어있다.</p>\n<blockquote>\n<p>The Effect Hook lets you perform side effects in function components.</p>\n</blockquote>\n<p>함수형 컴포넌트에서 <code>side effects</code>를 수행할 수 있게 해준다라는 의미가 바로 와닿지는 않는다. 그래서 문서를 조금 더 살펴보면 이런 내용도 있다.</p>\n<blockquote>\n<p>Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you’re used to calling these operations “side effects” (or just “effects”), you’ve likely performed them in your components before.</p>\n</blockquote>\n<p>즉, 컴포넌트 내부에서 수행하던 <code>data fetching</code>, <code>subscription(이벤트 등록/해제 같은)</code>, <code>manaual한 DOM변경</code> 등과 같은 state를 직접 처리하는 이외의 동작이나 기능들을 <code>side effect</code> 또는 <code>effect</code>로 부르고 있다.</p>\n<p><code>useEffect</code>가 중요한 이유 중의 하나는 react의 <code>lifecycle</code>과 밀접하게 관련이 있기 때문이다.\n기본적으로 렌더링이 완료된 이후에 실행 되는데 두번째 인자인 <code>deps</code>를 통해 실행 여부를 결정할 수 있기 때문에 class 컴포넌트에 있던 <code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>와 같은 lifecycle과 비슷한 역할을 할 수 있다.</p>\n<p>기존 방식과의 차이점은 문서를 확인하면 명확하게 알 수 있다.(<a href=\"https://reactjs.org/docs/hooks-effect.html\">Using the Effect Hook – React</a>)</p>\n<p><code>useEffect</code>에서 함수를 리턴할 수 있는데 이 함수는 다음 effect발생하기 전에 호출이 되기 때문에 메모리 정리나 구독해제 같은 기능을 처리할 수 있다. (<code>componentDidMount</code>에서 등록하고 <code>componentWillUnmount</code>에서 해제하는 것과 유사한 동작)</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> subscription <span class=\"token operator\">=</span> props<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    subscription<span class=\"token punctuation\">.</span><span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그런데 위의 코드를 수행하면 매 렌더링시마다 구독/해제가 일어나기 때문에 비효율적이다. 이런 문제를 해결하기 위해서 위에서 언급한 대로 두번째 인자로 <code>deps(dependencies)</code>를 전달할 수 있다. <code>deps</code>는 배열 형식으로 전달하고, 배열의 각 아이템을 shallow하게 비교해서 변경이 발생한 경우에만 effect가 실행된다. 위 코드처럼 전달하지 않으면 매번 실행이 되고, 빈배열(<code>[ ]</code>)을 전달하면 mount/unmount시에만 호출이 된다. 위 코드에서는 props의 source에 접근하고 있기 때문에 그 값이 변할 경우에만 구독/해제를 할 필요가 있다. 따라서 아래처럼 해주면 원하는 효과를 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> subscription <span class=\"token operator\">=</span> props<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    subscription<span class=\"token punctuation\">.</span><span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>props<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>여기서 주의할 점은, 컴포넌트 범위에서 변경될 수 있는 값(state나 props같은)을 누락하게 되면 원하는 동작을 하지 않을 수 있다는 점이다. 예로 위의 코드에서 deps에 []를 넣게 되면, props의 source가 변경되어도 구독은 계속 이전 source에 된 상태로 남아있게 된다.</p>\n<p><code>useEffect</code>에서 직접적인 접근이 없지만 호출하는 함수에서 변경되는 값이 존재하는 경우에도 마찬가지로 추가를 해줘야 하지만 쉽게 인지하기 어려울 수도 있기 때문에 react에서는 <code>eslint-plugin-react-hooks</code>의\n<a href=\"https://github.com/facebook/react/issues/14920\">exhaustive-deps</a> lint rule을 사용하는 것을 권장하고 있다.</p>\n<h2>useCallback</h2>\n<p>callback의 memoization을 만들어주는 hook이다. 즉, 매번 동일한 함수를 생성하는 것이 아니라 변경될 필요가 없는 경우 이전에 생성된 함수를 반환해주는 기능을 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> memoizedCallback <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code>useCallback</code>이 유용성은 react의 특성을 이해하면 알기 쉽다. 자식에게 callback을 전달하는 경우에 부모가 렌더링 되면서 매번 새로 생성된다면 자식입장에서는 props가 변경되기 때문에 함께 렌더링이 발생하게 되는 것이다. 이런 경우 사용하면 memoization된 callback을 전달함으로써 불필요한 렌더링을 방지할 수 있게 되는 것이다. 자식에서 <code>shouldComponentUpdate</code>를 통해 변경여부를 직접 비교해서 렌더링을 결정하는 효과를 간단히 볼 수 있게 된다. 마찬가지로 callback은 <code>deps</code>에 따라 변경여부를 결정하기 때문에 주의해서 사용할 필요가 있다.</p>\n<h2>useMemo</h2>\n<p><code>useCallback</code>이 memoization된 함수를 반환해 주었다면 <code>useMemo</code>는 memoization된 값을 반환해 준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> memoizedValue <span class=\"token operator\">=</span> <span class=\"token function\">useMemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">computeExpensiveValue</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code>deps</code>가 변경된 경우에만 전달된 함수를 호출하여 결과를 반환하기 때문에 cost가 많은 처리를 필요할 때만 수행하도록 할 수 있다. 주의할 점은 <code>useMemo</code>는 렌더링 중에 실행되기 때문에 계산이 아닌 <code>sideEffect</code>(위에서 언급한)를 수행하면 안된다는 것이다. 또한 이후 버전에서는 매번 재계산하는 방식을 택할 수도 있기 때문에 <code>useMemo</code>는 성능 최적화의 목적으로만 사용해야 한다.</p>\n<p>그 외에 <code>useContext</code>, <code>useReducer</code>, <code>useLayoutEffect</code> 등이 있지만 어렵지 않고 사용빈도도 많지 않기 때문에 생략한다. (공식문서를 보면 쉽게 이해할 수 있다.)</p>\n<p>추가로 <code>customHook</code>을 만들어 사용할 수도 있는데, 공식문서(<a href=\"https://reactjs.org/docs/hooks-custom.html\">Building Your Own Hooks – React</a>)를 보면 간단하게 방법을 알 수 있다. 유용한 custom hook은 <a href=\"https://usehooks.com/\">useHooks - Easy to understand React Hook recipes</a>를 참고하면 작성과 사용법을 아는데 도움이 된다.</p>\n<p>간단하게 hook의 내용과 사용법들을 정리해 봤다. 사실 각각 hook을 사용하면서 고민하거나 헤맸던 부분들에 대해서 정리를 하는게 목적이었으나 그 전에 간단히 기본적인 내용들을 먼저 정리해봤다. 이후에 시간이 되면 <code>useEffect</code>와 <code>useCallback</code>의 <code>deps</code>를 사용하면서 들었던 고민들이나 퍼포먼스를 올리기 위해 하고 있는 삽질들을 다시 한 번 정리해볼 예정이다.</p>","fields":{"slug":"/dev/react-hooks/"},"frontmatter":{"date":"2019/07/28","title":"react hooks 복습하기","description":"익숙할 때 쯤 정리해보는 react hooks","tags":["react","hooks","useState","useRef","useImperativeHandle","forwardRef","useEffect","useCallback","useMemo"]}}},{"node":{"excerpt":"Do’s and Don’ts General Types Number, String, Boolean, and Oject Don’t\nNumber, String, Boolean 또는 Object 타입을 절대 사용하지 마라. 이 타입들은 JavaScript…","html":"<h1>Do’s and Don’ts</h1>\n<h2>General Types</h2>\n<h3>Number, String, Boolean, and Oject</h3>\n<p><strong><em>Don’t</em></strong>\n<code>Number</code>, <code>String</code>, <code>Boolean</code> 또는 <code>Object</code> 타입을 절대 사용하지 마라. 이 타입들은 JavaScript 코드에서 대부분 적절하지 않게 사용되는 non-primitive boxed object<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>들을 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* WRONG */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">s<span class=\"token punctuation\">:</span> String</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong><em>Do</em></strong>\n<code>number</code>, <code>string</code> 그리고 <code>boolean</code>을 사용하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* OK */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">s<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code>Object</code> 대신 non-primitive인 <code>object</code> 타입을 사용하라 (<a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type\">TypeScript 2.2</a>에 추가됨).</p>\n<h4>Generic</h4>\n<p><strong><em>Don’t</em></strong>\n타입 매개변수를 사용하지 않는 generic 타입을 사용하지 마라. 더 자세한 내용은 <a href=\"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---\">TypeScript FAQ page</a>에서 확인.<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></p>\n<h2>Callback Types</h2>\n<h3>Return Types of Callbacks</h3>\n<p><strong><em>Don’t</em></strong>\n값이 무시될 콜백의 리턴타입으로 <code>any</code>를 사용하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* WRONG */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">x</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong><em>Do</em></strong>\n값이 무시될 콜백의 리턴타입으로 <code>void</code>를 사용하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* OK */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">x</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong><em>Why</em></strong>\n확인되지 않는 방법으로 <code>x</code>의 리턴타입을 사용하는 실수를 방지해주기 때문에 <code>void</code>를 사용하는 것이 더 안전하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">x</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> k <span class=\"token operator\">=</span> <span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// oops! meant to do something else</span>\n  k<span class=\"token punctuation\">.</span><span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// error, but would be OK if the return type had been 'any'</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Optional Paameters in Callbacks</h3>\n<p><strong><em>Don’t</em></strong>\n의도한 경우를 제외하고는 선택적 매개변수를 사용하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* WRONG */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Fetcher</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">getObject</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">done</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">data<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> elapsedTime<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이것은 매우 분명한 의미를 갖는다. : <code>done</code> 콜백은 1개 또는 2개의 매개변수를 가지고 호출된다. 작성자는 아마 콜백이 <code>elapsedTime</code> 매개변수에 대해 신경쓰지 않는다는 것을 의도했을 것이다. 그러나 그것을 위해 선택적 매개변수로 만들 필요는 없다. - 더 적은 매개변수를 받는 콜백을 전달하는 것은 언제나 적합하다.<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup></p>\n<p><strong><em>Do</em></strong>\n콜백의 파라미터를 필수(non-optional) 파라미터로 작성하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* OK */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Fetcher</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">getObject</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">done</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">data<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> elapsedTime<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Overloads and Callbacks</h3>\n<p><strong><em>Don’t</em></strong>\n콜백만 다른 별도의 타입 시그니처(overload)를 작성하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* WRONG */</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">beforeAll</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">action</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">,</span> timeout<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">beforeAll</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function-variable function\">action</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">done<span class=\"token punctuation\">:</span> DoneFn</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">,</span>\n  timeout<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong><em>Do</em></strong>\n모든 것을 포함하는 타입 시그니처 하나만 작성하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* OK */</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">beforeAll</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function-variable function\">action</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">done<span class=\"token punctuation\">:</span> DoneFn</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">,</span>\n  timeout<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong><em>Why</em></strong>\n콜백에서 매개변수를 무시하는 것은 언제나 적합하다.(역자:<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>과 같은 의미이다.) 따라서 더 간단한 타입 시그니처는 필요하지 않다. 간단한 타입 시그니처를 제공하는 것은 타입이 잘못된 함수가 첫번째 함수 시그니처와 매칭되어 전달되는 것을 허용한다.<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup></p>\n<h3>Function Overloads</h3>\n<h4>Ordering</h4>\n<p><strong><em>Don’t</em></strong>\n더 구체적인 시그니처 전에 일반적인 시그니처를 두지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* WRONG */</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> HTMLElement</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> HTMLDivElement</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> myElem<span class=\"token punctuation\">:</span> HTMLDivElement<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>myElem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// x: any, wat?</span></code></pre></div>\n<p><strong><em>Do</em></strong>\n더 구체적인 시그니처 다음에 일반적인 시그니처를 두도록 정렬하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* OK */</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> HTMLDivElement</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> HTMLElement</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> myElem<span class=\"token punctuation\">:</span> HTMLDivElement<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>myElem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// x: string, :)</span></code></pre></div>\n<p><strong><em>Why</em></strong>\nTypeScript는 함수 호출을 결정할 때 처음 매칭되는 시그니처를 서낵한다. 먼저 나오는 시그니처가 뒤의 시그니처보다 더 일반적일 경우, 뒤에 나오는 것은 완벽히 가려지고 호출될 수 없다.</p>\n<h3>Use Optional Parameters</h3>\n<p><strong><em>Don’t</em></strong>\n뒤에 나오는 매개변수들만 다른 경우 여러 시그니처를 작성하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* WRONG */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Example</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">diff</span><span class=\"token punctuation\">(</span>one<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">diff</span><span class=\"token punctuation\">(</span>one<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> two<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">diff</span><span class=\"token punctuation\">(</span>one<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> two<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> three<span class=\"token punctuation\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong><em>Do</em></strong>\n가능한 경우에는 선택적 매개변수를 사용하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* OK */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Example</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">diff</span><span class=\"token punctuation\">(</span>one<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> two<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> three<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 방법은 모든 시그니처의 리턴타입이 같은 경우에만 가능하다는 것을 주의하라.</p>\n<p><strong><em>Why</em></strong>\n여기엔 두 가지 중요한 이유가 있다.</p>\n<p>TypeScript는 source의 매개변수로 target의 시그니처 호출할 수 있는지, 그리고 관련없는 매개변수가 허용되는지를 보고 시그니처 호환성을 결정한다. 예를 들어, 이 코드는 시그니처가 선택적 매개변수를 사용하여\n정확히 작성된 경우에만 버그를 발생시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">x</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> x<span class=\"token punctuation\">:</span> Example<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 오버로딩으로 작성되어 있으면, OK -- 첫 번째 시그니처를 사용</span>\n<span class=\"token comment\">// 선택적 매개변수로 작성되어 있으면, 에러</span>\n<span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>diff<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>두 번째 이유는 TypeScript의 <code>stric null checking</code> 기능을 사용하는 경우이다. JavaScript에서 명시되지 않은 매개변수는 <code>undefined</code>로 표현되기 때문에, 일반적으로 선택적 매개변수를 가진 함수에 <code>undefined</code>를 명시적으로 전달하는 것이 좋다. 예를 들어 이 코드는 strict null을 사용하는 경우에도 문제없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">var</span> x<span class=\"token punctuation\">:</span> Example<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 오버로딩으로 작성되어 있으면, `undefined`를 `string` 타입으로 전달하기 때문에 에러</span>\n<span class=\"token comment\">// 선택적 매개변수로 작성되어 있으면, 정상</span>\nx<span class=\"token punctuation\">.</span><span class=\"token function\">diff</span><span class=\"token punctuation\">(</span><span class=\"token string\">'something'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span> <span class=\"token operator\">?</span> undefined <span class=\"token punctuation\">:</span> <span class=\"token string\">'hour'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>Use Union Types</h3>\n<p><strong><em>Don’t</em></strong>\n오직 하나의 매개변수 타입이 다른 경우에는 오버로딩을 사용하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* WRONG */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Moment</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">utcOffset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">utcOffset</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Moment<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">utcOffset</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Moment<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong><em>Do</em></strong>\n가능한 경우에는 유니온 타입을 사용하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/* OK */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Moment</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">utcOffset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">utcOffset</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Moment<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>시그니처의 리턴타입이 다르기 때문에 <code>b</code>를 선택적 매개변수로 하지 않은 것을 주의하라.</p>\n<p><strong><em>Why</em></strong>\n이것은 함수에 값을 그대로 전달하는 사람들에게 중요하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 오버로딩으로 작성되어 있으면, 에러</span>\n  <span class=\"token comment\">// 유니온 타입으로 작성되어 있으면, 정상</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">moment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">utcOffset</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>primitive타입이 아닌 boxing된 object형 타입. 따라서 <code>Numer.MAX_VALUE</code>나 <code>Number.isSafeInteger()</code>등으로 사용가능하다.</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p>generic으로 선언하고 내부에서 사용하지 않는 경우를 만들지 말라는 의미로, FAQ 페이지를 보면 해당 타입 매개변수를 사용하는 부분이 없으면 타입추론이 제대로 이루어지지 않는다고 한다.</p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p>매개변수의 개수에 대한 함수의 타입 호환성에서 할당받는 함수의 매개변수가 더 많은 경우는 호환이 가능하기 때문이다. 자주 사용하는 <code>map()</code>,<code>filter()</code> 같은 함수에 매개변수 하나만 사용하는 콜백을 넘기는 경우를 생각하면 쉽다.</p>\n<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-4\">\n<p>호출하는 쪽에서는 항상 정해진 수의 매개변수를 전달하고 콜백에서 필요한 만큼만 받아서 사용해야 하는데, 매개변수 개수가 적은 시그니처가 있으면 호출하는 쪽에서 매개변수를 적게 전달하는 실수가 허용된다.</p>\n<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","fields":{"slug":"/dev/ts-do-and-dont/"},"frontmatter":{"date":"2019/02/11","title":"[번역] TypeScript의 Do's and Don'ts","description":"TypeScript 공식 documentation의 Do's and Don'ts를 번역해 보았다.","tags":["TIL","typscript"]}}},{"node":{"excerpt":"MS에서도 엣지에 크로미움을 사용한다고 발표한 상황에서, 팀에서도 IE10을 더이상 지원하지 않기 위한 근거로 서비스 접속 대한 브라우저 통계가 필요했다. 가이드를 통해 nginx의 access 로그와 GoAccess…","html":"<p>MS에서도 엣지에 크로미움을 사용한다고 발표한 상황에서, 팀에서도 IE10을 더이상 지원하지 않기 위한 근거로 서비스 접속 대한 브라우저 통계가 필요했다.<br>\n가이드를 통해 nginx의 access 로그와 <a href=\"https://goaccess.io/\">GoAccess</a>에 대해 알게 되었고 이를 사용하여 간단하게 로그 분석을 해봤다.\n단순하게 사용만 해본 터라 깊이는 없지만 오랜만에 사용해본 쉘 명령어도 되짚어 볼 겸 간단하게 정리해 본다.</p>\n<p>우선 서버에서 원격으로 접근 가능한 위치에 받아올 로그 파일을 미리 복사해 두고 scp를 통해 내려 받아 압축을 해제한다. (회사에서는 일주일 단위로 로그를 압축하여 백업하고 있었고, 실 서비스 서버이므로 로컬 PC로 로그파일을 내려 받아서 진행했다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># scp로 로그파일 내려받기</span>\n<span class=\"token function\">scp</span> 계정@호스트:파일경로 저장할파일이름   <span class=\"token comment\"># 원하는 파일만</span>\n<span class=\"token function\">scp</span> -r 계정@호스트:폴더경로 ./ <span class=\"token comment\"># 폴더 통째로</span>\n\n<span class=\"token comment\"># gzip/gunzip으로 압축 해제하기</span>\n<span class=\"token function\">gzip</span> -d access.log-xxxxxxxx.gz <span class=\"token comment\"># (gunzip access.log-xxxxxxxx.gz) 원하는 파일만</span>\ngunzip -r ./accesslog <span class=\"token comment\"># 폴더의 압축파일들을 한 번에 해제</span></code></pre></div>\n<p>로그파일이 준비됐으니 GoAccess를 설치한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">brew <span class=\"token function\">install</span> goaccess</code></pre></div>\n<p>GoAccess로 분석을 하기위해 로그파일의 포맷을 설정파일에 명시해야 한다. <code>time-format</code>, <code>date-format</code>, <code>log-format</code> 세 가지만 설정 해주고, 로그가 표준화된 형식일 경우 실행시에 옵션으로 넣어줘도 되는 듯 하다.<br>\n미리 정의된 형식이 주석으로 있으니 해제하여 사용하거나 없으면 맞게 작성해주면 된다. 내 PC의 설정파일의 위치는 <code>/usr/local/Cellar/goaccess/1.2_1/etc/goaccess.conf</code>였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\">######################################</span>\n<span class=\"token comment\"># Time Format Options (required)</span>\n<span class=\"token comment\">######################################</span>\ntime-format %H:%M:%S\n\n<span class=\"token comment\">######################################</span>\n<span class=\"token comment\"># Date Format Options (required)</span>\n<span class=\"token comment\">######################################</span>\ndate-format %d/%b/%Y\n\n<span class=\"token comment\">######################################</span>\n<span class=\"token comment\"># Log Format Options (required)</span>\n<span class=\"token comment\">######################################</span>\nlog-format %h - %^ <span class=\"token punctuation\">[</span>%d:%t %^<span class=\"token punctuation\">]</span>  <span class=\"token string\">\"%r\"</span> %s %b <span class=\"token string\">\"%R\"</span> <span class=\"token string\">\"%u\"</span> %T <span class=\"token string\">\"%^\"</span></code></pre></div>\n<p>GoAccess를 사용하기 전에 필요한 로그를 가공 할 필요가 있었다.\n<a href=\"https://page.kakao.com\">카카오페이지 웹</a>의 경우 PC와 모바일 버전이 다르고(당연히), 모바일의 경우 앱 내에서 호출하는 경우가 있어 제외시켜야 했다. 추가로 리다이렉션(응답코드 30X) 되는 경우도 로그가 중복이기 때문에 제외 시켰다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 앱에서 호출하는 경우 userAgent에 KakaoPage가 포함된다.</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/KaKaoPage/d'</span> access.log-xxxxxxxx <span class=\"token operator\">></span> 1_only_web\n<span class=\"token comment\"># 응답코드 30X인 레코드를 제외시킨다.(더 정확하게 할 수 있겠지만 이 정도만 해도 충분했다.)</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/\" 30. /d'</span> 1_only_web <span class=\"token operator\">></span> 2_delete_redirect</code></pre></div>\n<p>GoAccess를 실행시켜 로그 파일을 분석하고 결과를 html파일로 만든다. (결과 화면은 <a href=\"https://goaccess.io/\">https://goaccess.io/</a>를 참고)</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">goaccess 2_delete_redirect -a -o 2_delete_redirect.html</code></pre></div>\n<p>결과를 대략 정리해 보면 크롬이 대부분을 차지했고, IE와 엣지는 통틀어 3%가 되지 않았다. IE10은 약 20명 내외였으며 서버 수를 고려한다 해도 절대치가 미미한 수준이었다. 아마도 이제 IE10 지원에 대한 고민은 하지 않아도 될 듯 하다.</p>","fields":{"slug":"/dev/goaccess-analyzer/"},"frontmatter":{"date":"2019/01/24","title":"[TIL] GoAccess로 nginx access 로그 분석 겉핥기","description":"브라우저별 접속 통계 확인을 위한 GoAccess 사용기","tags":["TIL","GoAccess","nginx","IE10"]}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}