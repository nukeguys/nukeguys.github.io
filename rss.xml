<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[nukeguys blog]]></title><description><![CDATA[about development, life and something.]]></description><link>https://nukeguys.github.io</link><generator>RSS for Node</generator><lastBuildDate>Sun, 11 Aug 2019 16:11:05 GMT</lastBuildDate><item><title><![CDATA[거절은 거절한다. "Accepted"]]></title><description><![CDATA[내가 가장 즐기는 취미 중의 하나가 영화다. 영화를 보기 시작한 건 처음 영화관에 갔던 중학교 때 부터 였던 걸로 기억한다.
난 깊이 있게 본다기 보다는 다작으로 많이 보는 편이다. 그래서 지금은 왓챠에 기록엔 영화만 1,70…]]></description><link>https://nukeguys.github.io/life/accepted/</link><guid isPermaLink="false">https://nukeguys.github.io/life/accepted/</guid><pubDate>Sun, 11 Aug 2019 14:51:12 GMT</pubDate><content:encoded>&lt;p&gt;내가 가장 즐기는 취미 중의 하나가 영화다. 영화를 보기 시작한 건 처음 영화관에 갔던 중학교 때 부터 였던 걸로 기억한다.
난 깊이 있게 본다기 보다는 다작으로 많이 보는 편이다. 그래서 지금은 왓챠에 기록엔 영화만 1,700편이 넘어섰다.
참 많이도 봤지만 한 번 본 영화는 특별한 계기가 있지 않은 이상 다시 보기가 쉽지 않다. 하지만 그 중에도 유별나게 여러 번 본 영화가 두 편 있다. (항상 컴퓨터에 저장되어 있다.)&lt;/p&gt;
&lt;p&gt;하나는 건축학개론. 첫 사랑에 대한 아련한 추억이 있는 것도 아닌데 왜인지 건축학 개론이 나온 시점에 집중적으로 몰아서 봤던 것 같다. 아마 5번 이상? 10번은 안되는 정도 본 것 같다.&lt;/p&gt;
&lt;p&gt;그리고 가장 많이 본 영화. 아마 오늘까지 합쳐 20번 정도는 봤을 것 같은 영화가 있다. 바로 &lt;a href=&quot;https://namu.wiki/w/%EC%96%B5%EC%85%89%ED%8B%B0%EB%93%9C&quot;&gt;억셉티드&lt;/a&gt;다.
이 영화에 대해 소개를 한 번 해보려고 한다.(나중에 알았지만 06학번, 내가 대학에 입학하던 시절을 배경으로 만들어 졌다. 그래서 더 보게 되는 건지도 모르겠지만.)&lt;/p&gt;
&lt;p&gt;억셉티드는 대학에 합격하지 못해 실망하는 부모님을 속이려 위조한 합격통지서를 시작으로 점점 일이 커져 가짜 대학교를 만들어내는 과정을 그린 영화다.&lt;/p&gt;
&lt;p&gt;주인공인 바틀비 게인즈는 지원한 대학교 8곳에 모두 떨어졌다. 그리고 부모님을 설득하기 위해 대학 4년 동안 학비를 쓰느니 그만큼을 벌겠다는 얼토당토 않는 소리를 하다가 당연히 안좋은 소리를 듣는다.
그래서 결국은 근처의 명문 대학인 South Harmon의 합격 통지서로 &lt;a href=&quot;https://www.southharmoninstituteoftechnology.org/&quot;&gt;South Harmon Institute of Technology&lt;/a&gt;(S.H.I.T)라는 새로운 대학을 만들어 합격통지서를 위조한다. 그렇게 임시방편으로 시작한 일이 폐쇄한 정신병원을 빌려 가짜 학교 건물을 만들고 엎친데 덮친격으로 클릭만 하면 합격인 홈페이지 덕분에 학생들(다른 곳에서는 모두 떨어진)이 오리엔테이션에 모여들게 된다.&lt;/p&gt;
&lt;p&gt;일을 수습하기 위해 모두를 돌려보내려 모인 강당에서 자신처럼 다른 곳에서 모두 거절당하고 온 학생들에게 동질감을 느끼고 오히려 가짜 대학을 진짜로 바꿔버린다. 그리고 대학이 어떤 곳인지 알아보았지만, 예상외로 대학은 자신의 기대와는 너무나도 다르다는 것을 알게 된다. 취업을 위해 맹목적으로 학점에 목매는 학생들, 빡빡한 일정과 과제들, 정작 듣고 싶은 수업은 듣지 못하는 여주인공 모니카, 그리고 전통이라는 명목으로 선배들에게 괴롭힘을 당하는 절친 슈레이더.&lt;/p&gt;
&lt;p&gt;이에 실망한 주인공은 학생들에게 직접 원하는 과목을 물어보고 그들이 직접 가르치는 커리큘럼을 실행한다.(내가 좋아하는 &lt;a href=&quot;https://www.opencollege.kr/&quot;&gt;오픈컬리지&lt;/a&gt;와 비슷하다.) 요리를 좋아하는 학생의 학비는 요리에, 조각, 명상, 스케이드보드, 심지어 초능력까지. 그들이 직접 원하는 과목을 개설하고 서로 가르치며 배워 나간다.&lt;/p&gt;
&lt;p&gt;하지만 이렇게 평탄하기만 하면 영화가 아니겠지. 안타깝게도 앞뜰을 만들기 위해 S.H.I.T의 부지를 사려던 South Harmon의 교육 관계자들에 의해 모든 행각에 들통이 나게 된다. 그리고 주인공과 친구들은 자신들이 했던 교육과정을 대학교로 인정받기 위해 교유과정 심문 위원회를 신청하게 된다.&lt;/p&gt;
&lt;p&gt;이 영화의 진정한 매력은 이 심문회 과정에 담겨있다. 닮은게 하나도 없는 학생들을 강제로 모두 같은 모습으로 만들길 원하고, 대학을 좋은 직장에 취업을 위한 과정으로만 여기는 기존의 대학에 대해 주인공은 말한다.
우리는 그렇지 않아 자랑스럽다고. 대학이 왜 그래야만 하는건지 반문한다. 그들은 그들의 방식대로 우리는 우리의 방식대로 서로 같이 존재 할 수 없는지 말이다. 오히려 학생들의 창의력과 열정을 뺏아간 당신들이 잘못이 아니냐고 말이다.
그리고 교육부 직원에게도 말한다. 당신의 꿈은 어릴 때 부터 교육부 직원이었냐고. 마술사나 화가, 시인 혹은 세계일주만 하고 싶지 않았냐고 말이다.&lt;/p&gt;
&lt;p&gt;자신도 자포자기로 시작한 일이 정말 놀라운 일이 되었다고 한다. 인생은 가능성으로 가득차 있기 때문에. 그리고 인정 따위는 필요 없다고 말한다. 진정한 교육은 선생이나 시설, 화려한 전통이나 돈은 필요없다고. 그저 자신을 개선하고자 하는 사람들만 있으면 된다고. S.H.I.T에는 그런 사람들로 넘쳐나고 인정없이도 계속해서 배우고 자랄 것 이며 변하지 않을 것이라고.&lt;/p&gt;
&lt;p&gt;위원회는 결론을 내린다. 혁신을 거부하는 대신 조심스럽게 지켜보겠다며 1년 간의 유예기간을 준다. 그리고 위원장은 주인공에데 다가와 말한다. 자신은 트롬본을 하고 싶었다고. 그렇게 모두 환호하고 다시 학교는 운영되고 주인공도 실망이 가득했던 가족들에게 인정을 받는다. 초능력을 원했던 학생이 South Harmon 학장의 차를 폭발시키며 영화는 끝난다.&lt;/p&gt;
&lt;p&gt;나는 왜 이 영화를 좋아했을까?&lt;/p&gt;
&lt;p&gt;따지고 보면 이 영화는 억지스럽고 비현실 적인 면이 많고, 미국에서도 그렇게 많은 인기를 끌지 못했다.(이상하리 만큼 한국에서는 평이 좋다.) 영화 자체의 완성도나 스토리, 작품성도 뛰어나다고 볼 수 없다. 어찌보면 흔한 킬링타임용 영화에 비할 수 있을 정도라고 볼 수 있다. 단지 교육이라는 주제를 가볍게 풀어냈다. 그것도 너무나 이상적으로. 영화의 마지막 주인공의 발언들은 속시원하게 만들어 주기도 한다.&lt;/p&gt;
&lt;p&gt;한 때는 꿈이 학교를 만드는 일이라고 할 정도 였지만 이유는 사실 잘 모르겠다. 그냥 언제부턴가 교육에 관심이 생겼고, 오히려 난 반대 학교의 방식에 더 가까웠던 것 같지만 S.H.I.T의 교육 방식에 매우 공감이 갔다. 오픈컬리지가 없었다면 직접 해보고 싶을 정도 였다. (오픈컬리지 외에도 열정대학이나 비슷한 서비스들이 생기기도 했다.) 어릴 때 부터 해보고 싶고 관심은 있는 건 많았으나 막상 틀에 갇혀 시도는 못 했던, 그래서 더 그런지도 모르겠다.&lt;/p&gt;
&lt;p&gt;가끔씩 집중이 안되고 생각이 많아질 때 면 이 영화를 보곤한다.(물론 처음의 그 감동은 다시 느껴지지 않지만 그래도 아직은 충분히 볼 만 하다.) 우연히 생각나서 본 김에 책 대신 영화에 대해 정리를 해봤다.
글에 나타난 것 보다는 더 많은 생각과 감정을 들게 했던 영화라, 앞으로도 당분간은 다시 볼 수 있을 것 같고 원한다면 누군가에게는 추천을 조심스럽게 해 볼만 할 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[react dev tool로 성능 측정 해보기]]></title><description><![CDATA[최근 작업을 하면서 react 성능에 대해 신경을 써야 할 상황이 생겼다. 아직 정확하게는 모르지만 대충 눈치, 코치, 감으로 chrome과 react의 developer tool…]]></description><link>https://nukeguys.github.io/dev/react-optimizing-performance/</link><guid isPermaLink="false">https://nukeguys.github.io/dev/react-optimizing-performance/</guid><pubDate>Sun, 04 Aug 2019 02:08:52 GMT</pubDate><content:encoded>&lt;p&gt;최근 작업을 하면서 react 성능에 대해 신경을 써야 할 상황이 생겼다. 아직 정확하게는 모르지만 대충 눈치, 코치, 감으로 chrome과 react의 developer tool을 사용해서 성능을 측정하고 개선하는 작업을 했는데, 일단 이번엔 &lt;code&gt;React Developer Tools&lt;/code&gt;을 사용해 성능을 측정하하고 개선하는 방법을 정리해본다.&lt;/p&gt;
&lt;h2&gt;성능 측정&lt;/h2&gt;
&lt;p&gt;우선 react와 browser의 렌더링 과정에 대해 간단히 알 필요가 있다. react는 DOM의 직접적인 변경을 방지하기 위해 virtual DOM을 사용하고 실제로 변경이 필요한 부분만 DOM에 반영함으로써 성능을 올린다. 브라우저는 변경이 발생하면 크게 두 과정을 필요에 따라 선택적으로 수행한다. DOM tree를 갱신하는 reflow(layout)와 이를 화면에 반영하는 repaint(painting)이다.(&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Introduction_to_Layout_in_Mozilla#Basic_Data_Flow&quot;&gt;Introduction to Layout in Mozilla - Mozilla | MDN&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;브라우저의 DOM에 변경을 가하는 reflow와 repaint도 당연히 성능에 영향이 크지만, react의 virtual DOM을 재계산하는 reconciliation(&lt;a href=&quot;https://reactjs.org/docs/reconciliation.html&quot;&gt;Reconciliation – React&lt;/a&gt;)과정도 생각보다 성능에 많은 영향을 미친다. 따라서 성능을 올리기 위해서는 이 모든 과정에 대한 고려가 필요하다. react의 reconciliation는 react developer tools를 통해 확인할 수 있고, reflow 및 repaint는 chrome의 developer tool을 통해 확인이 가능하다.&lt;/p&gt;
&lt;h3&gt;Highlight Updates&lt;/h3&gt;
&lt;p&gt;react는 컴포넌트의 state나 props가 변경되면 render를 수행하여 virtual DOM을 갱신한다. react의 developer tools에서 Highlight Updates 설정을 켜놓으면 interaction이 발생할 때 마다 리렌더링되는 컴포넌트의 테두리에 색이 변경되는 것을 볼 수 있다. 즉 변경될 필요가 없는데도 특정 부분의 테두리 색이 나타난다면 불필요한 컴포넌트 렌더링이 발생하고 있는 것이다.&lt;/p&gt;
&lt;h3&gt;Profiler&lt;/h3&gt;
&lt;p&gt;위의 방법은 눈으로 쉽게 확인 가능하지만 상세한 내용은 알 수 가 없다. 경우에 따라 보다 정확하고 자세한 내용을 알고 싶다면 profiler를 사용하면 된다. 기본적인 사용법은 profiler 패널에서 record 버튼을 누르고 원하는 interaction을 하거나 시간이 흐른 뒤에 stop을 누르면 그 사이에 발생한 렌더링에 대해 확인 할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://reactjs.org/static/stop-profiling-45619de03bed468869f7a0878f220586-53c76.png&quot; alt=&quot;stop-profiling-45619de03bed468869f7a0878f220586-53c76.png&quot;&gt;&lt;/p&gt;
&lt;h4&gt;Flame Chart&lt;/h4&gt;
&lt;p&gt;prifiling이 끝나면 그 동안에 발생한 commit&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;별 flame chart를 보여준다. 각 commit은 패널의 우측 상단에서 표시가 되고 각 commit을 선택하면 해당 commit의 flame chart가 표시된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://reactjs.org/static/commit-selector-bd72dec045515d59be51c944e902d263-8ef72.png&quot; alt=&quot;commit-selector-bd72dec045515d59be51c944e902d263-8ef72.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;commit이 많이 표시되는 것은 측정 시간동안 DOM의 변경이 그 만큼 발생했다는 것이고, 바의 색과 높이는 렌더링 소용된 시간을 나타낸다. (높고 노란색일 수록 오래 걸렸다는 의미이다.)&lt;/p&gt;
&lt;p&gt;flame chart에서는 commit에서 각 컴포넌트들의 상태를 나타낸다. 바의 길이(너비)는 마지막 렌더링에 걸린 시간을 의미하고 색은 현재 commit에서 소요된 시간을 의미한다. (해당 컴포넌트와 자식컴포넌트를 포함한다.)&lt;/p&gt;
&lt;p&gt;아래 사진에서보면 &lt;code&gt;App&lt;/code&gt;과 &lt;code&gt;HashRouter&lt;/code&gt; 컴포넌트의 경우 렌더링에 많은 시간이 걸리고 있으나 회색이기 때문에 현재 commit에서는 렌더링이 발생하지 않았다는 것을 알 수 있고, &lt;code&gt;Router&lt;/code&gt; 컴포넌트는 렌더링이 발생했고 대부분의 시간이 자식 컴포넌트인 &lt;code&gt;Nav&lt;/code&gt;와 &lt;code&gt;Route&lt;/code&gt; 렌더링에 소요된 것을 알 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://reactjs.org/static/flame-chart-3046f500b9bfc052bde8b7b3b3cfc243-53c76.png&quot; alt=&quot;flame-chart-3046f500b9bfc052bde8b7b3b3cfc243-53c76.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;컴포넌트를 선택하면 이번 commit에서의 &lt;code&gt;state&lt;/code&gt;나 &lt;code&gt;prpos&lt;/code&gt;도 확인이 가능하고, 다른 commit을 선택하면 변경도 확인할 수 있어서 렌더링이 발생한 이유도 알 수 있다.&lt;/p&gt;
&lt;h4&gt;Ranked Chart&lt;/h4&gt;
&lt;p&gt;두 번째 ranked chart를 선택하면 현재 commit에서 렌더링이 오래걸린 순으로 컴포넌트를 정렬해서 확인 할 수 있다. 단, 자식 컴포넌트의 렌더링을 포함하기 때문에 표시되는 실제 오래걸리는 컴포넌트가 포함된 tree의 top이 표시될 수 있다는 점을 염두해야 한다.&lt;/p&gt;
&lt;h4&gt;Component Chart&lt;/h4&gt;
&lt;p&gt;전체 profiling 동안 특정 컴포넌트의 렌더링에 대해 알고 싶을 땐 component chart가 유용하다. 컴포넌트를 더블클릭하거나 오른쪽 x표시 옆에 있는 차트 모양 아이콘을 선택하면 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://reactjs.org/static/component-chart-d71275b42c6109e222fbb0932a0c8c09-53c76.png&quot; alt=&quot;component-chart-d71275b42c6109e222fbb0932a0c8c09-53c76.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;바의 수는 렌더링 된 횟수를 의미하고 각 바의 높이와 색은 각 commit에서 다른 컴포넌트에 비해 상대적으로 해당 컴포넌트가 렌더링되는데 걸린 시간을 의미한다. 바를 선택하면 자세한 내용을 볼 수 있고, 더블 클릭하거나 x를 누르면 이전 화면으로 돌아갈 수 있다.&lt;/p&gt;
&lt;p&gt;보다 상세한 사용법은 react 블로그를 참고하자. (&lt;a href=&quot;https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html&quot;&gt;Introducing the React Profiler – React Blog&lt;/a&gt;)&lt;/p&gt;
&lt;h2&gt;개선 하기&lt;/h2&gt;
&lt;p&gt;profiling 결과를 보다보면 특정 컴포넌트가 렌더링에 시간을 오래 소요하거나 렌더링할 필요가 없는 데도 commit마다 렌더링이 발생하는 경우가 있다. 이런 경우 해당 컴포넌트를 찾아서 불필요한 렌더링이 발생하지 않도록 개선할 필요가 있다.&lt;/p&gt;
&lt;p&gt;우선 렌더링이 발생하는 이유에 대해 생각해보자. react는 state나 props가 변경된 경우 컴포넌트의 변경이 발생할 것으로 예상하고 렌더링을 한다. 이 과정이 위에서 확인되는 렌더링 이다. 최종적으로 실제 DOM에 변경이 없다면 반영이 되지 않겠지만(이 부분은 다음에 정리할 내용에서 확인이 가능하다.) 이 자체만으로 경우에 따라 성능에 많은 영향을 주게 된다. 이 과정을 없애기 위해서는 react에게 렌더링을 할 필요가 없다는 것을 알려줄 필요가 있다. 예상했듯이 class형 컴포넌트에서는 &lt;code&gt;shouldComponentUpdate&lt;/code&gt;를 사용하거나 &lt;code&gt;PureComponent&lt;/code&gt;를 상속함으로서 미리 정의된 &lt;code&gt;shouldComponentUpdate&lt;/code&gt;를 적용할 수 있다. function 컴포넌트에서도 비슷한 역할을 하는 &lt;code&gt;memo&lt;/code&gt;라는 HOC가 존재한다.&lt;/p&gt;
&lt;h3&gt;React.memo&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; MyComponent &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;MyComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;/* render using props */&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 처럼 사용하면 &lt;code&gt;PureComponent&lt;/code&gt; 처럼 shallow 한 비교를 직접 처리해준다. 하지만 좀 더 복잡하거나 예외적인 처리가 필요할 경우에는 두 번째 인자로 이전 props와 다음 props를 받아서 비교를 수행하는 함수를 전달할 수 있다. &lt;code&gt;shouldComponentUpdate&lt;/code&gt;와 다른점이 있다면 반환값이 반대라는 점이다. 이름에서 알 수 있듯이 &lt;code&gt;shouldComponentUpdate&lt;/code&gt;는 update여부를 반환하기 때문에 다른 경우에 true를 반환하지만 &lt;code&gt;areEqual&lt;/code&gt;의 경우는 비교의 결과를 반환하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;MyComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;/* render using props */&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;areEqual&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;prevProps&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nextProps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;/*
  return true if passing nextProps to render would return
  the same result as passing prevProps to render,
  otherwise return false
  */&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;MyComponent&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; areEqual&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;대부분의 경우에는 추가적인 비교함수 없이 대응이 가능하다. 이 때 주의할 점은 shallow하게 비교하기 때문에 &lt;code&gt;immutable&lt;/code&gt;한 데이터를 &lt;code&gt;props&lt;/code&gt;로 사용해야 한다는 점이다. 즉, 실제 같은 데이터지만 렌더링 마다 새로운 객체를 생성해서 전달한다면 memo의 의미가 없어지게 되는 것이다.&lt;/p&gt;
&lt;p&gt;즉 부모 컴포넌트에서 &lt;code&gt;useMemo&lt;/code&gt;나 &lt;code&gt;useCallback&lt;/code&gt;을 사용해서 props를 전달하고 자식 컴포넌트에서 &lt;code&gt;memo&lt;/code&gt;가 적용되어 있으면 손쉽게 불필요한 렌더링을 막을 수 있게 되는 것이다. (&lt;a href=&quot;https://nukeguys.github.io/dev/react-hooks/&quot;&gt;react hooks 복습하기&lt;/a&gt; 참고)&lt;/p&gt;
&lt;p&gt;그렇다면 &lt;code&gt;memo&lt;/code&gt;는 항상 사용하는 것이 좋겠다는 생각을 할 수도 있다. 물론 대부분의 경우에는 효과를 볼 수도 있겠지만 &lt;code&gt;memo&lt;/code&gt;도 내부적으로는 &lt;code&gt;useMemo&lt;/code&gt;와 같이 동작을 하기 때문에 추가적인 비용이 들게 된다. 즉 매번(또는 빈번하게) 변경되는 컴포넌트에 적용하게 되면 렌더링은 그대로 유지되면서 추가적인 비용만 더 가중시키는 셈이다. 대표적으로 prpos로 &lt;code&gt;children&lt;/code&gt;을 받아서 사용하는 컴포넌트를 들 수 있는데, 일반적으로 children은 매번 변경되거나 별도로 memoization을 하는 경우가 많지 않기 때문이다.&lt;/p&gt;
&lt;p&gt;그래서 일단 적용하지 않은 상태로 구현한 뒤에 propfiling을 통해 필요한 곳에 &lt;code&gt;memo&lt;/code&gt;를 적용하는 것을 권장한다.&lt;/p&gt;
&lt;p&gt;이번엔 react development tool을 사용해서 렌더링 성능을 측정하고 개선하는 방법을 간단히 정리해봤다. 다음엔 browser의 렌더링 과정과 측정하는 방법을 정리해 볼 예정이다.&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;react의 lifecyle은 크게 render와 commit으로 나뉜다. render를 수행한 후 변경된 사항을 DOM에 반영하는 과정이다.(&lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;React lifecycle methods diagram&lt;/a&gt;)&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[react hooks 복습하기]]></title><description><![CDATA[Frontend를 시작한지 얼마 되지 않았지만 그 짧은 사이에도 크고 작은 것들이 많이 변화했다. 정말 빠르구나 싶기도 하고 그런게 나름 또 이 세계의 재미가 아닌가 싶기도 하다. React도 16.8이 릴리즈 되면서 hooks라는 api…]]></description><link>https://nukeguys.github.io/dev/react-hooks/</link><guid isPermaLink="false">https://nukeguys.github.io/dev/react-hooks/</guid><pubDate>Sun, 28 Jul 2019 01:35:46 GMT</pubDate><content:encoded>&lt;p&gt;Frontend를 시작한지 얼마 되지 않았지만 그 짧은 사이에도 크고 작은 것들이 많이 변화했다. 정말 빠르구나 싶기도 하고 그런게 나름 또 이 세계의 재미가 아닌가 싶기도 하다.&lt;/p&gt;
&lt;p&gt;React도 16.8이 릴리즈 되면서 hooks라는 api가 새롭게 등장했다. 익숙해 지려고 할 때 쯤 새로운 놈이 등장해서 다시 또 적응을 해야했고 지금은 나름 열심히 사용하고 있긴하지만 이쯤에서 자주 쓰는 hooks에 대해 정리를 한 번 해볼까한다. (물론 틀린 내용이 있을 수 있고, 주관적인 생각이 포함되어 있을 수 있다.)&lt;/p&gt;
&lt;p&gt;우선 각 hook에 대해 정리하기 전에 hooks라는 이름에 대해 생각해 볼 필요가 있지 싶다. react 문서에서는 hook을 아래처럼 설명하고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hooks are functions that let you “hook into” React state and lifecycle features from function components. (&lt;a href=&quot;https://reactjs.org/docs/hooks-overview.html#but-what-is-a-hook&quot;&gt;Hooks at a Glance – React&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;state와 lifecycle을 &lt;code&gt;hook into&lt;/code&gt;한다라는게 바로 와닿지는 않는다. 번역하면 연동한다/끌어드린다/밀어넣는다 정도로 될 듯하다.
hook이라는 단어는 &lt;code&gt;web-hook&lt;/code&gt;이나 &lt;code&gt;hooking&lt;/code&gt;처럼 흔하게 사용되는 말로 중간에 동작을 가로챈다는 의미로 보는게 이해가 빠를 것 같다. 따라서 react의 hook도 lifecycle 과정에서 state와 관련된 동작을 수행 할 수 있도록 해준다는 의미로 이해하면 될 것 같다.&lt;/p&gt;
&lt;h2&gt;useState&lt;/h2&gt;
&lt;p&gt;class형 컴포넌트에서 &lt;code&gt;this.state&lt;/code&gt;와 &lt;code&gt;setState&lt;/code&gt;의 역할을 하는 hook이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setState&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;initialState&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;공식문서에 나와있는 이전방식과 hook의 코드도 비교해보자.(&lt;a href=&quot;https://reactjs.org/docs/hooks-state.html&quot;&gt;Using the State Hook – React&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;하나의 객체가 아니라 필요한 state를 개별로 접근하고 변경할 수 있다는 점에서 관리와 사용이 훨씬 깔끔해진 느낌이다. &lt;code&gt;useState&lt;/code&gt;를 사용할 때 주의해야 할 부분도 있다. 우선 class형 컴포넌트 안에서는 사용할 수 없고, setState와 다르게 merge가 아닌 replace된다는 점이다. 두 번째는 setter의 인자로 값이 아닌 함수를 전달할 수 도 있다는 점이다. count를 증가시키는 코드를 예로 보면 일반적으로 아래처럼 할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;increaseCount&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;setCount&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;count &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 setCount를 비동기 callback에서 호출하는 경우에 원하는 대로 count가 증가하지 않는 경우를 경험할 수 있다. 이유는 callback 등록 시점에 함수가 생성되면서 count 값이 고정되어 버리기 때문이다. 처음에 같은 문제를 겪고 한참을 헤맸던 기억이 있다. 이런 경우에는 아래처럼 setCount에 함수(이전 state값을 받아서 새로운 state를 반환하는)를 전달하면 해결 할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;increaseCount&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;setCount&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;prevCount&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; prevCount &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;물론 위의 경우처럼 단순하게 처리가 불가능한 경우가 있을 수도 있다. 또 state 뿐 아니라 props에 대해서도 동일한 문제가 발생할 수 있다. 그런 경우에는 state를 객체로 변경해서 사용하거나, &lt;code&gt;useRef&lt;/code&gt;를 사용해 state 또는 props를 별도의 변수로 저장해서 접근해야 한다.&lt;/p&gt;
&lt;p&gt;추가로 useSate의 초기값으로도 함수를 전달할 수 있다. 이는 초기값 계산의 cost가 높은 경우에 초기화를 지연시키는 역할을 한다.&lt;/p&gt;
&lt;h2&gt;useRef&lt;/h2&gt;
&lt;p&gt;위에서 언급한 &lt;code&gt;useRef&lt;/code&gt;도 간단히 정리해본다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; refContainer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useRef&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;initialValue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이름에서 유추 가능한 것 처럼, 원하는 값을 객체로 warraping해서 &lt;code&gt;current&lt;/code&gt;라는 속성으로 접근할 수 있게 해준다. 보통 DOM의 reference를 담아두는데 사용하지만 class의 멤버 변수처럼 사용하는 것이 가능하다.&lt;/p&gt;
&lt;p&gt;어렵지 않지만 실제로 구현된 아래 코드를 보면 더 쉽게 이해가 된다. (&lt;a href=&quot;https://github.com/facebook/react/blob/42b75ab007a5e7c159933cfdbf2b6845d89fc7f2/packages/react-reconciler/src/ReactFiberHooks.js#L856-L869&quot;&gt;ReactFiberHooks.js · GitHub&lt;/a&gt;)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; mountRef&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;initialValue&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; current&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mountWorkInProgressHook&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; ref &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; current&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; initialValue &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__DEV__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;seal&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ref&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ref&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; ref&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; updateRef&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;initialValue&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; current&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateWorkInProgressHook&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;최초에는 ref라는 객체를 만들어 current 속성에 초기값을 설정해서 반환하고, 이후부터는 해당 객체를 반환한다.&lt;/p&gt;
&lt;p&gt;참고로 react의 hooks는 &lt;code&gt;mountXXX&lt;/code&gt;와 &lt;code&gt;updateXXX&lt;/code&gt;라는 이름으로 최초 실행과 이후 업데이트에서 사용하는 함수가 각각 분리되어 구현 되어 있다.&lt;/p&gt;
&lt;h2&gt;useImperativeHandle &amp;#x26; forwardRef&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token function&quot;&gt;useImperativeHandle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ref&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; createHandle&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;deps&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;useImperativeHandle&lt;/code&gt;은 부모에게 원하는 interface를 통해 ref를 사용할 수 있게 해준다. 즉, 부모가 자식의 ref를 직접 받아서 접근할 수도 있지만, 제한하거나 커스터마이징해서 제공을 하고 싶을 때 사용하면 된다. &lt;code&gt;useImperativeHandle&lt;/code&gt;은 &lt;code&gt;forwardRef&lt;/code&gt;와 함께 사용해야 하는데 간단한 사용법은 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;FancyInput&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ref&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; inputRef &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useRef&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;useImperativeHandle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ref&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function-variable function&quot;&gt;focus&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      inputRef&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;focus&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;input ref&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;inputRef&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
FancyInput &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;forwardRef&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;FancyInput&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;useEffect&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;useState&lt;/code&gt;와 더불어 가장 자주 사용하고 중요한 hook중의 하나이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token function&quot;&gt;useEffect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;didUpdate&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;공식문서의 정의는 아래처럼 되어있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Effect Hook lets you perform side effects in function components.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;함수형 컴포넌트에서 &lt;code&gt;side effects&lt;/code&gt;를 수행할 수 있게 해준다라는 의미가 바로 와닿지는 않는다. 그래서 문서를 조금 더 살펴보면 이런 내용도 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you’re used to calling these operations “side effects” (or just “effects”), you’ve likely performed them in your components before.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, 컴포넌트 내부에서 수행하던 &lt;code&gt;data fetching&lt;/code&gt;, &lt;code&gt;subscription(이벤트 등록/해제 같은)&lt;/code&gt;, &lt;code&gt;manaual한 DOM변경&lt;/code&gt; 등과 같은 state를 직접 처리하는 이외의 동작이나 기능들을 &lt;code&gt;side effect&lt;/code&gt; 또는 &lt;code&gt;effect&lt;/code&gt;로 부르고 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;useEffect&lt;/code&gt;가 중요한 이유 중의 하나는 react의 &lt;code&gt;lifecycle&lt;/code&gt;과 밀접하게 관련이 있기 때문이다.
기본적으로 렌더링이 완료된 이후에 실행 되는데 두번째 인자인 &lt;code&gt;deps&lt;/code&gt;를 통해 실행 여부를 결정할 수 있기 때문에 class 컴포넌트에 있던 &lt;code&gt;componentDidMount&lt;/code&gt;, &lt;code&gt;componentDidUpdate&lt;/code&gt;, &lt;code&gt;componentWillUnmount&lt;/code&gt;와 같은 lifecycle과 비슷한 역할을 할 수 있다.&lt;/p&gt;
&lt;p&gt;기존 방식과의 차이점은 문서를 확인하면 명확하게 알 수 있다.(&lt;a href=&quot;https://reactjs.org/docs/hooks-effect.html&quot;&gt;Using the Effect Hook – React&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;useEffect&lt;/code&gt;에서 함수를 리턴할 수 있는데 이 함수는 다음 effect발생하기 전에 호출이 되기 때문에 메모리 정리나 구독해제 같은 기능을 처리할 수 있다. (&lt;code&gt;componentDidMount&lt;/code&gt;에서 등록하고 &lt;code&gt;componentWillUnmount&lt;/code&gt;에서 해제하는 것과 유사한 동작)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token function&quot;&gt;useEffect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; subscription &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;source&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    subscription&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;unsubscribe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그런데 위의 코드를 수행하면 매 렌더링시마다 구독/해제가 일어나기 때문에 비효율적이다. 이런 문제를 해결하기 위해서 위에서 언급한 대로 두번째 인자로 &lt;code&gt;deps(dependencies)&lt;/code&gt;를 전달할 수 있다. &lt;code&gt;deps&lt;/code&gt;는 배열 형식으로 전달하고, 배열의 각 아이템을 shallow하게 비교해서 변경이 발생한 경우에만 effect가 실행된다. 위 코드처럼 전달하지 않으면 매번 실행이 되고, 빈배열(&lt;code&gt;[ ]&lt;/code&gt;)을 전달하면 mount/unmount시에만 호출이 된다. 위 코드에서는 props의 source에 접근하고 있기 때문에 그 값이 변할 경우에만 구독/해제를 할 필요가 있다. 따라서 아래처럼 해주면 원하는 효과를 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token function&quot;&gt;useEffect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; subscription &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;source&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    subscription&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;unsubscribe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;source&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서 주의할 점은, 컴포넌트 범위에서 변경될 수 있는 값(state나 props같은)을 누락하게 되면 원하는 동작을 하지 않을 수 있다는 점이다. 예로 위의 코드에서 deps에 []를 넣게 되면, props의 source가 변경되어도 구독은 계속 이전 source에 된 상태로 남아있게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;useEffect&lt;/code&gt;에서 직접적인 접근이 없지만 호출하는 함수에서 변경되는 값이 존재하는 경우에도 마찬가지로 추가를 해줘야 하지만 쉽게 인지하기 어려울 수도 있기 때문에 react에서는 &lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;의
&lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt;exhaustive-deps&lt;/a&gt; lint rule을 사용하는 것을 권장하고 있다.&lt;/p&gt;
&lt;h2&gt;useCallback&lt;/h2&gt;
&lt;p&gt;callback의 memoization을 만들어주는 hook이다. 즉, 매번 동일한 함수를 생성하는 것이 아니라 변경될 필요가 없는 경우 이전에 생성된 함수를 반환해주는 기능을 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; memoizedCallback &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;useCallback&lt;/code&gt;이 유용성은 react의 특성을 이해하면 알기 쉽다. 자식에게 callback을 전달하는 경우에 부모가 렌더링 되면서 매번 새로 생성된다면 자식입장에서는 props가 변경되기 때문에 함께 렌더링이 발생하게 되는 것이다. 이런 경우 사용하면 memoization된 callback을 전달함으로써 불필요한 렌더링을 방지할 수 있게 되는 것이다. 자식에서 &lt;code&gt;shouldComponentUpdate&lt;/code&gt;를 통해 변경여부를 직접 비교해서 렌더링을 결정하는 효과를 간단히 볼 수 있게 된다. 마찬가지로 callback은 &lt;code&gt;deps&lt;/code&gt;에 따라 변경여부를 결정하기 때문에 주의해서 사용할 필요가 있다.&lt;/p&gt;
&lt;h2&gt;useMemo&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;useCallback&lt;/code&gt;이 memoization된 함수를 반환해 주었다면 &lt;code&gt;useMemo&lt;/code&gt;는 memoization된 값을 반환해 준다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; memoizedValue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useMemo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;computeExpensiveValue&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;deps&lt;/code&gt;가 변경된 경우에만 전달된 함수를 호출하여 결과를 반환하기 때문에 cost가 많은 처리를 필요할 때만 수행하도록 할 수 있다. 주의할 점은 &lt;code&gt;useMemo&lt;/code&gt;는 렌더링 중에 실행되기 때문에 계산이 아닌 &lt;code&gt;sideEffect&lt;/code&gt;(위에서 언급한)를 수행하면 안된다는 것이다. 또한 이후 버전에서는 매번 재계산하는 방식을 택할 수도 있기 때문에 &lt;code&gt;useMemo&lt;/code&gt;는 성능 최적화의 목적으로만 사용해야 한다.&lt;/p&gt;
&lt;p&gt;그 외에 &lt;code&gt;useContext&lt;/code&gt;, &lt;code&gt;useReducer&lt;/code&gt;, &lt;code&gt;useLayoutEffect&lt;/code&gt; 등이 있지만 어렵지 않고 사용빈도도 많지 않기 때문에 생략한다. (공식문서를 보면 쉽게 이해할 수 있다.)&lt;/p&gt;
&lt;p&gt;추가로 &lt;code&gt;customHook&lt;/code&gt;을 만들어 사용할 수도 있는데, 공식문서(&lt;a href=&quot;https://reactjs.org/docs/hooks-custom.html&quot;&gt;Building Your Own Hooks – React&lt;/a&gt;)를 보면 간단하게 방법을 알 수 있다. 유용한 custom hook은 &lt;a href=&quot;https://usehooks.com/&quot;&gt;useHooks - Easy to understand React Hook recipes&lt;/a&gt;를 참고하면 작성과 사용법을 아는데 도움이 된다.&lt;/p&gt;
&lt;p&gt;간단하게 hook의 내용과 사용법들을 정리해 봤다. 사실 각각 hook을 사용하면서 고민하거나 헤맸던 부분들에 대해서 정리를 하는게 목적이었으나 그 전에 간단히 기본적인 내용들을 먼저 정리해봤다. 이후에 시간이 되면 &lt;code&gt;useEffect&lt;/code&gt;와 &lt;code&gt;useCallback&lt;/code&gt;의 &lt;code&gt;deps&lt;/code&gt;를 사용하면서 들었던 고민들이나 퍼포먼스를 올리기 위해 하고 있는 삽질들을 다시 한 번 정리해볼 예정이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[불완전한 완벽주의에 대하여]]></title><description><![CDATA[집에 TV…]]></description><link>https://nukeguys.github.io/life/imperfect-perfectionism/</link><guid isPermaLink="false">https://nukeguys.github.io/life/imperfect-perfectionism/</guid><pubDate>Sun, 21 Jul 2019 15:06:20 GMT</pubDate><content:encoded>&lt;p&gt;집에 TV가 없기도 하고 잘 보지도 않는데 오늘 아침에 우연히 예능을 보게 됐다. 한 때 자주 보던
&lt;a href=&quot;https://page.kakao.com/home?seriesId=51206359&quot;&gt;전지적 참견 시점&lt;/a&gt;이었고, 게스트로 &lt;code&gt;강진주&lt;/code&gt;라는 배우가 나왔다. 별 생각없이 보다가 문뜩 들렸던 말과 상황에 주말에 쳐진 몸을 움직이고 자아성찰(?)을 하는 계기가 됐다.&lt;/p&gt;
&lt;p&gt;간단히 내용을 정리해 보면, 일을 할 때는 정말 열심히 몰입해서 다 쏟아내지만 정작 쉬는 기간에는 뭘 할지 모르겠다고 한다. 이 말에 매니저가 자기계발을 하라면서 이것저것 관심은 두지만 정작 제대로 끝내는 일은 별로 없다고 잔소리를 해댔다. 이 말에 강진주는 자신이 완벽주의가 있어 완벽하게 해야 한다는 생각에 끝맺음을 잘 못한다면서 완벽하지 않을 거면 시작도 하지 말라는 요상한 핑계를 들었다. 그런데 왠지 내가 하는 말인 것 같아 괜히 뜨끔했다. 이후 집이 나오면서 몇달 전에 시작했단 페인팅을 하다가 멈춘 현관문으로 주제가 바꼈다.&lt;/p&gt;
&lt;p&gt;나도 어릴 때 부터 완벽주의가 있었다.(물론 어디서 과학적으로 측정을하거나 테스트를 해 본건 아니지만) 사실 완벽주의라기 보다 강박이었을 수도 있는 것 같다. 양말 양쪽 끝의 높이를 정확히 맞춰서 올려 신느라 한참을 실랑이하고, 휴지를 접거나 종이를 접어도 항상 귀퉁이를 맞춰서 각잡고 접어야 하고, 가족들 다 보던 매직아이를 혼자만 못 본다는 사실에 잠도 안자고 밤새 눈을 모아서 책을 보던 이상한 강박을 가진 아이였다. 분명 긍정적인 영향도 있었을 거다. 뭘 하던 내가 만족할 때 까지, 남 보다 잘 할 때 까지, 끝을 볼 때 까지 해야하는 것도 내가 나를 힘들게 하는 성격이었지만 그래도 그 덕에 이만큼(?) 되지 않았을까 싶긴하다.&lt;/p&gt;
&lt;p&gt;마침 TV에 나왔던 페인팅을 나도 하고 있다. 처음엔 셀프 인테리어를 해보겠다며 맘을 먹고 역시나 잘해보겠다는 의지로 열심히 알아봤다. 그런데 준비를 하면 할 수록 모르는게 생기고 보기는 더 많아지고 그래서 뭘 해야하는지는 더 모르겠더라는게 문제였다. 아는건 더 많아지고 욕심은 더 커졌지만 막상 뭘 어떻게 시작할까, 그래서 뭘 할건데라는 질문에 쉽게 답을 할 수가 없었다. 중간중간 힘든 것도 있지만 이게 잘 된건지 아닌지도 판단할 수가 없었다. 계속해야 하나? 그만해야 하나를 수없이 고민했던 것 같다. 겨우 이정도까지 오는데 두 달이 넘는 시간이 걸렸다. 나머지의 대부분은 불안과 걱정, 생각에 들였을 시간이다.&lt;/p&gt;
&lt;p&gt;내가 생각하는 내 가장 큰 단점 중의 하나가 &lt;code&gt;실행력 부족&lt;/code&gt;이고, 그 이유로 들면서 나를 정의하던 것 중의 하나가 &lt;code&gt;불완전한 완벽주의자&lt;/code&gt;였다. 뭔가를 하면 정말 잘하고 싶고 뛰어나고 싶고 끝을 내고 싶어 한 없이 매달렸는데 시간이 지날수록 그렇게 하기가 점점 더 힘들다는 걸 깨달았다. 그리고 점점 더 잘 할 수 있을까, 어떻게 해야 잘할까를 오래 생각하게되고 그렇게 시간만 흐르다 시작을 못하게 된다.&lt;/p&gt;
&lt;p&gt;과연 완벽함이란 마치 영화 &lt;a href=&quot;https://page.kakao.com/home?seriesId=50504425&quot;&gt;위플래쉬&lt;/a&gt;에서 처럼 지독하게도 지향해야 하는 이상일까, 불완전함을 받아들이고 행복하기 위해 지양해야 하는 현실일까? 두 가지 입장(또는 해석)에 대한 책들도 많고 강의나 이야기들도 주변에서 쉽사리 들을 수 있다. 세상에 완전함은 없다는 생각으로 현실에 만족하자고 하지만 막상 내가 하는 일에 대해서는 완벽을 추구하는 모순적인 몹쓸 습관이 오히려 완벽함을 추구하는데 방해가 되고 있지 않은가 하는 생각이 든다.&lt;/p&gt;
&lt;p&gt;또 한편으로 완벽함이란 무엇인가를 고민해보게 된다. 그냥 단순하게 생각하면 완벽함이란 대부분 결과에 대한 정의로 보여진다. 하지만 완벽해지고 싶다는 것은 단순 어떤 사건의 결과만을 원하는 것이 아니라 완벽한 존재에 대한 추구일 것 이다. 즉 시점이 아닌 시간과 경험, 존재 자체에 대한 의미로 보는게 맞는 듯 싶다. 우리가 어떤 존재에 대해 닮고 싶어 하거나 부러워 하는 것은 그 사람이 보여준 하나의 특정 결과가 아닌 그 사람 자체가 되고 싶은 것이기 때문이다.&lt;/p&gt;
&lt;p&gt;결국 완벽함을 결과론적으로 이해하고 그 결과를 위한 수단으로 완벽함이 사용되는 완벽주의는 절대 완벽해질 수 없는 지양해야하는 대상이 되어야 하지 않을까 싶다. 완벽함을 추구해 나가는 과정들을 통해 그나마 우리는 완벽에 가까워 질 수 있고 불완전함을 받아들일 수 있지 않을까.&lt;/p&gt;
&lt;p&gt;이렇게 다시금 생각을 정리하고 마음을 다잡고, 결국 미뤄왔던 페인팅도 마무리하고 블로그 글도 하나 채웠다. 최종적으로 변화된 집이 아닌, 채워진 글의 갯수가 아닌 이 과정을 통해 내가 조금 더 완벽함에 가까워 지고 있는 걸거다. 조금 더 잘 쓰고 싶지만 피곤함에 글을 정리하면서… 떠오른 말로 마무리 한다. “우리 모두는 완벽하게 불완전하다”&lt;/p&gt;</content:encoded></item><item><title><![CDATA[첫마디를 행운에 맡기지 마라]]></title><description><![CDATA[대한민국 최초의 국제회의 통역, 그리고 역대 대통령…]]></description><link>https://nukeguys.github.io/book/firstword-9788901222035/</link><guid isPermaLink="false">https://nukeguys.github.io/book/firstword-9788901222035/</guid><pubDate>Sun, 14 Jul 2019 15:47:35 GMT</pubDate><content:encoded>&lt;p&gt;대한민국 최초의 국제회의 통역, 그리고 역대 대통령 5인의 통역을 총괄한 최정화 통역사의 저서이다.&lt;/p&gt;
&lt;p&gt;처음 이 책을 보게된 건, 우연히 서점에 가서 어떤 책을 읽을까 구경하던 중이었다. 심플한 표지에 그리고 제목에 이끌려서 잠깐 내용을 보다가 구매까지 하게 되었다. 말을 업으로 삼는 분의 글이라 그런지 책도 군더더기가 없이 깔끔했던 것 같다. 보이는 부분도 내용도.&lt;/p&gt;
&lt;p&gt;말에 대해 고민을 많이 하던 시기여서 더 읽어보고 싶기도 했고 내용도 읽다보니 계속 읽히게 되는 힘이 있는 것 같다.&lt;/p&gt;
&lt;p&gt;읽기 시작한지는 조금 지나서 앞 부분의 내용들이 자세히 기억나지는 않지만 책에서 전달하려고 하는 내용은 상당히 의미 있게 와닿았던 것 같다. 단지 말을 떠나 소통에 대해. 누군가를 대함에 있어 그 사람에 대한 말을 넘어 자세나 태도, 마음가짐까지 모든 것에 대해 말하는 것 같았다.&lt;/p&gt;
&lt;p&gt;말에는 그 만큼의 무게가 닮겨 있고, 말에도 언향이라는 향이 있으며, 말 하는 사람의 지식과 경험, 인품이 들어가기 때문에 ‘나’라는 사람을 비춘다는 말이 말의 중요성을 다시 한 번 느끼게 해준다.&lt;/p&gt;
&lt;p&gt;그리고 끝 부분에 와닿았던 문구가 있었다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“남보다 빨리 성공해서 오랜 시간에 걸쳐 내려오는 삶보다 평생에 걸쳐 천천히 성장의 계단을 오르는 삶이야말로 괜찮은 삶의 운영 방식일지도 모른다.”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;요즘 많이 고민하는 부분과 관련이 있어보여 더 와닿는게 컸던 것 같다. 책을 읽으면서 스스로 많이 반성도 하게 되었던 것 같고 여러모로 좋았던 책이다. 잊혀질 때 쯤 다시 한 번씩 꺼내서 읽어보면 좋을 것 같다.&lt;/p&gt;
&lt;p&gt;카카오페이지 : &lt;a href=&quot;https://page.kakao.com/home?seriesId=50951010&quot;&gt;https://page.kakao.com/home?seriesId=50951010&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[나는 달린다.]]></title><description><![CDATA[몇 달 전부터 준비하던 마라톤이 드디어 다가왔다. 피로는 좀 쌓여있었지만, 컨디션을 좋게 유지하기 위해 들었던 팁에 따라 전날 혼자 스파게티도 먹고 당일 아침엔 일어나자마자 에너지바와 포카리로 에너지를 미리 채웠다. 소집은…]]></description><link>https://nukeguys.github.io/life/i-run/</link><guid isPermaLink="false">https://nukeguys.github.io/life/i-run/</guid><pubDate>Sat, 02 Mar 2019 13:27:29 GMT</pubDate><content:encoded>&lt;p&gt;몇 달 전부터 준비하던 마라톤이 드디어 다가왔다.&lt;br&gt;
피로는 좀 쌓여있었지만, 컨디션을 좋게 유지하기 위해 들었던 팁에 따라 전날 혼자 스파게티도 먹고 당일 아침엔 일어나자마자 에너지바와 포카리로 에너지를 미리 채웠다.&lt;br&gt;
소집은 8시 였으나 행사 시간을 고려하고 날도 쌀쌀했기 때문에 어느정도 여유를 갖고 출발했다.&lt;br&gt;
도착해서 주변을 보니 참가자들이 엄청 많았고, 첫 참가라 그런지 살짝 들뜬 마음으로 동료들과 시작을 기다렸다.
순서대로 출발을 하는데 참가자에 비해 출발선이 비좁았고 통제가 잘 되지 않아서 인지 너무 혼잡했다.&lt;br&gt;
그래서 이미 출발 했어야 할 하프 주자들이 10km 출발 전에 비집고 들어와서 뛰기도 했는데 좀 더 신경을 써줬으면 좋겠다 싶었다.&lt;/p&gt;
&lt;p&gt;드디어 출발, 참가자가 가장 많은 코스인 만큼 출발이 쉽지가 않았다. 사방이 사람이라 피해서 나가느라 초반엔 좀 정신이 없기도 했다.&lt;br&gt;
폰도 두고 뛰었고 스포츠 워치도 없어서 페이스를 알 수가 없어 초반에는 동료들과 속도를 맞춰서 적당히 따라갔다.&lt;br&gt;
그러다 초반 3km 정도가 지나면서는 내 페이스를 잡아보려고 앞만 보고 속도를 조금 올려서 뛰기 시작했다. 아마 페이스를 알 수 있었으면 평소보다 빠르구나 싶어서 조절을 했을 수도 있을 것 같은데 느낌상으로만 뛰다보니 연습 때 속도로 뛰어도 실제 체감으로는 느리게 느껴졌다. 아마 기록이 예상보다 잘 나온 이유가 이래서이지 싶다.&lt;/p&gt;
&lt;p&gt;4km 이정표가 보이면서 이미 반환하고 6km를 뛰고 있는 선두 주자가 보였다. 이미 그만큼이나 뛰었는데도 엄청난 속도로 달려오고 있었다. 오히려 워낙 넘사벽이라 뭐 잘 뛰는구나 생각하고 그냥 지나쳤다.&lt;/p&gt;
&lt;p&gt;5km가 근접해 오면서 실제로 10km를 완주해 본 적이 없기 때문에 후반부에 체력이 떨어지는 상황에 걱정이 많이 됬었다. 그래서 나름 적당히 힘든 만큼만 유지하면서 반환점을 지나고 혼자 머릿속으로 마지막 2~3km에 속도를 내자 생각하고 달렸다.
개인적으로는 ‘습습후후’하고 끊어서 쉴 수 있으면 아직은 여유가 있는 시점인 듯 했다. 그러다 조금씩 힘이 들면 들숨의 간격이 모호해지고 결국은 ‘습~후후’나 ‘습~후~‘가 되는 것 같다. 그래서 중반까지는 습습후후를 유지할 만큼만 페이스를 유지했다.&lt;/p&gt;
&lt;p&gt;6km를 지나면서 부터는 힘들다는 생각이 들기 시작했다. 주변에 같이 달리는 사람들도 지친 모습이 조금씩 보이기 시작했고 이 와중에 속도를 내는 사람들도 있었다. 속도를 내기엔 아직 아닌 것 같아 느려지지만 말자는 생각으로 앞사람들을 따라갔다.&lt;/p&gt;
&lt;p&gt;어느정도 지나고 종합운동장이 보였고 완주는 하겠구나 싶었는데 남은 거리가 가늠이 되지 않았다. 속도를 내고 싶지만 숨은 차고 잘못하면 막판에 쳐질 것 같았다. 그러다 마침 앞에 뛰는 한 여성분이 적당히 비슷한 속도로 달리고 있었다. 그래서 따라가다 후반에 잡아보자는 생각으로 바짝 붙어 뛰었다. 그러다 서로 의식이 된건지 몇 번을 서로 앞으로 치고 나가기도 했다.&lt;/p&gt;
&lt;p&gt;그렇게 달리다 보니 운동장쪽으로 진입하는 터널이 보였다. 지나면 운동장이 바로 나오는 줄 알고 착각해서 잠시 속도를 올렸는데 아직 좀 남아있는데다 심장이 무리가 가는게 느껴져서 다시 속도를 늦췄다. 아직 다리는 멀쩡한데 더 빨리 뛸 수 없는게 좀 아쉬웠다.
그리고 좀 지나니 정말 운동장 입구가 보였고 입구를 지나치고 결승선이 보이자 마자 미친 듯이 달렸다. 그 때 따라잡은 사람들이 5~6명은 되는 것 같다. 한 분은 정말 쓰러지기 직전 모습으로 들어가고 있어서 안타깝기도 했지만 빠르게 옆을 지나쳐서 들어갔다.&lt;/p&gt;
&lt;p&gt;결승선을 통과하자 기록측정 소리가 삐하고 들렸고 바로 주저 앉아서 시계를 돌아봤다. 그 때가 아마 49분이 살짝 넘었던 것 같다. 그래서 조금만 더 뛰어서 48분대로 들어올 걸 아쉬운 마음으로 기록증을 받았는데, 기록은 출발선을 통과한 시점부터 측정이 되는지라 시계보다는 좀 더 빠르게 나왔고 최종기록은 48분 24초로 되어 있었다. 동료들과 얘기했던 55분 목표와 준비하면서 개인적으로 세웠던 50분 목표를 달성해서 만족스러우면서도 한편으로는 조금 만 더… 라는 아쉬움도 살짝 남았었다. 이 아쉬움이 다음 마라톤을 참가하게 되는 계기가 되지 않을까 싶다.&lt;/p&gt;
&lt;p&gt;이번 생에 첫 마라톤을 참가하면서 놀랐던 것은 생각보다 마라톤에 참가하는 사람들이 많다는 것, 그리고 잘 달리는 사람들도 많은데 그 중에 여자들의 비중이 적지 않다는 사실에 두번 놀랐다. 83세에 풀코스를 매 주 달리는 할아버지도 계시다고 하니 대단한 일이다.&lt;/p&gt;
&lt;p&gt;나름 준비한다고 매주 연습도하고 했는데 처음 치고는 결과도 만족스러워서 다행이기도 하고, 한 편으로는 연습 때 마다 느꼈지만 다리는 더 달릴 수 있는 상태였는데 그러지 못한게 아쉬웠다. 20대에는 다리가 저릴 때까지 뛰어 다녀도 그런 적은 없었는데… 헬스장 다니면서 다리 근력운동은 병행 했는데 너무 오랫동안 운동을 쉰 탓에 심폐지구력은 많이 떨어진 것 같다. 오랜만에 달리는 맛을 느껴봤고 마라톤에 대한 흥미도 생긴만큼 올해 목표는 10km 2번 참가였지만, 매달은 아니더라도 격달로라도 참가해 볼까 싶다. (이번 대회 100위가 43분인가 45분인가 였던 것 같은데 올 해 안에 45분을 목표로)&lt;/p&gt;
&lt;p&gt;그래서 앞으로도 나는 달릴 예정이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[[번역] TypeScript의 Do's and Don'ts]]></title><description><![CDATA[Do’s and Don’ts General Types Number, String, Boolean, and Oject Don’t
Number, String, Boolean 또는 Object 타입을 절대 사용하지 마라. 이 타입들은 JavaScript…]]></description><link>https://nukeguys.github.io/dev/ts-do-and-dont/</link><guid isPermaLink="false">https://nukeguys.github.io/dev/ts-do-and-dont/</guid><pubDate>Mon, 11 Feb 2019 13:52:55 GMT</pubDate><content:encoded>&lt;h1&gt;Do’s and Don’ts&lt;/h1&gt;
&lt;h2&gt;General Types&lt;/h2&gt;
&lt;h3&gt;Number, String, Boolean, and Oject&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Don’t&lt;/em&gt;&lt;/strong&gt;
&lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt; 또는 &lt;code&gt;Object&lt;/code&gt; 타입을 절대 사용하지 마라. 이 타입들은 JavaScript 코드에서 대부분 적절하지 않게 사용되는 non-primitive boxed object&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;들을 의미한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* WRONG */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;s&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; String&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Do&lt;/em&gt;&lt;/strong&gt;
&lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt; 그리고 &lt;code&gt;boolean&lt;/code&gt;을 사용하라.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* OK */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;s&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Object&lt;/code&gt; 대신 non-primitive인 &lt;code&gt;object&lt;/code&gt; 타입을 사용하라 (&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type&quot;&gt;TypeScript 2.2&lt;/a&gt;에 추가됨).&lt;/p&gt;
&lt;h4&gt;Generic&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Don’t&lt;/em&gt;&lt;/strong&gt;
타입 매개변수를 사용하지 않는 generic 타입을 사용하지 마라. 더 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---&quot;&gt;TypeScript FAQ page&lt;/a&gt;에서 확인.&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h2&gt;Callback Types&lt;/h2&gt;
&lt;h3&gt;Return Types of Callbacks&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Don’t&lt;/em&gt;&lt;/strong&gt;
값이 무시될 콜백의 리턴타입으로 &lt;code&gt;any&lt;/code&gt;를 사용하지 마라.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* WRONG */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Do&lt;/em&gt;&lt;/strong&gt;
값이 무시될 콜백의 리턴타입으로 &lt;code&gt;void&lt;/code&gt;를 사용하라.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* OK */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Why&lt;/em&gt;&lt;/strong&gt;
확인되지 않는 방법으로 &lt;code&gt;x&lt;/code&gt;의 리턴타입을 사용하는 실수를 방지해주기 때문에 &lt;code&gt;void&lt;/code&gt;를 사용하는 것이 더 안전하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; k &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// oops! meant to do something else&lt;/span&gt;
  k&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// error, but would be OK if the return type had been &apos;any&apos;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Optional Paameters in Callbacks&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Don’t&lt;/em&gt;&lt;/strong&gt;
의도한 경우를 제외하고는 선택적 매개변수를 사용하지 마라.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* WRONG */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Fetcher&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;getObject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;data&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elapsedTime&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이것은 매우 분명한 의미를 갖는다. : &lt;code&gt;done&lt;/code&gt; 콜백은 1개 또는 2개의 매개변수를 가지고 호출된다. 작성자는 아마 콜백이 &lt;code&gt;elapsedTime&lt;/code&gt; 매개변수에 대해 신경쓰지 않는다는 것을 의도했을 것이다. 그러나 그것을 위해 선택적 매개변수로 만들 필요는 없다. - 더 적은 매개변수를 받는 콜백을 전달하는 것은 언제나 적합하다.&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Do&lt;/em&gt;&lt;/strong&gt;
콜백의 파라미터를 필수(non-optional) 파라미터로 작성하라.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* OK */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Fetcher&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;getObject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;data&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elapsedTime&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Overloads and Callbacks&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Don’t&lt;/em&gt;&lt;/strong&gt;
콜백만 다른 별도의 타입 시그니처(overload)를 작성하지 마라.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* WRONG */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;beforeAll&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; timeout&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;beforeAll&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;done&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; DoneFn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  timeout&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Do&lt;/em&gt;&lt;/strong&gt;
모든 것을 포함하는 타입 시그니처 하나만 작성하라.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* OK */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;beforeAll&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;done&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; DoneFn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  timeout&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Why&lt;/em&gt;&lt;/strong&gt;
콜백에서 매개변수를 무시하는 것은 언제나 적합하다.(역자:&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;과 같은 의미이다.) 따라서 더 간단한 타입 시그니처는 필요하지 않다. 간단한 타입 시그니처를 제공하는 것은 타입이 잘못된 함수가 첫번째 함수 시그니처와 매칭되어 전달되는 것을 허용한다.&lt;sup id=&quot;fnref-4&quot;&gt;&lt;a href=&quot;#fn-4&quot; class=&quot;footnote-ref&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h3&gt;Function Overloads&lt;/h3&gt;
&lt;h4&gt;Ordering&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Don’t&lt;/em&gt;&lt;/strong&gt;
더 구체적인 시그니처 전에 일반적인 시그니처를 두지 마라.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* WRONG */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; HTMLElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; HTMLDivElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; myElem&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; HTMLDivElement&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;myElem&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// x: any, wat?&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Do&lt;/em&gt;&lt;/strong&gt;
더 구체적인 시그니처 다음에 일반적인 시그니처를 두도록 정렬하라.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* OK */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; HTMLDivElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; HTMLElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; myElem&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; HTMLDivElement&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;myElem&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// x: string, :)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Why&lt;/em&gt;&lt;/strong&gt;
TypeScript는 함수 호출을 결정할 때 처음 매칭되는 시그니처를 서낵한다. 먼저 나오는 시그니처가 뒤의 시그니처보다 더 일반적일 경우, 뒤에 나오는 것은 완벽히 가려지고 호출될 수 없다.&lt;/p&gt;
&lt;h3&gt;Use Optional Parameters&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Don’t&lt;/em&gt;&lt;/strong&gt;
뒤에 나오는 매개변수들만 다른 경우 여러 시그니처를 작성하지 마라.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* WRONG */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Example&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;diff&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;one&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;diff&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;one&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; two&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;diff&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;one&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; two&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; three&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;boolean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Do&lt;/em&gt;&lt;/strong&gt;
가능한 경우에는 선택적 매개변수를 사용하라.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* OK */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Example&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;diff&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;one&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; two&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; three&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;boolean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 방법은 모든 시그니처의 리턴타입이 같은 경우에만 가능하다는 것을 주의하라.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Why&lt;/em&gt;&lt;/strong&gt;
여기엔 두 가지 중요한 이유가 있다.&lt;/p&gt;
&lt;p&gt;TypeScript는 source의 매개변수로 target의 시그니처 호출할 수 있는지, 그리고 관련없는 매개변수가 허용되는지를 보고 시그니처 호환성을 결정한다. 예를 들어, 이 코드는 시그니처가 선택적 매개변수를 사용하여
정확히 작성된 경우에만 버그를 발생시킨다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; c&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Example&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 오버로딩으로 작성되어 있으면, OK -- 첫 번째 시그니처를 사용&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 선택적 매개변수로 작성되어 있으면, 에러&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;diff&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;두 번째 이유는 TypeScript의 &lt;code&gt;stric null checking&lt;/code&gt; 기능을 사용하는 경우이다. JavaScript에서 명시되지 않은 매개변수는 &lt;code&gt;undefined&lt;/code&gt;로 표현되기 때문에, 일반적으로 선택적 매개변수를 가진 함수에 &lt;code&gt;undefined&lt;/code&gt;를 명시적으로 전달하는 것이 좋다. 예를 들어 이 코드는 strict null을 사용하는 경우에도 문제없다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Example&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 오버로딩으로 작성되어 있으면, `undefined`를 `string` 타입으로 전달하기 때문에 에러&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 선택적 매개변수로 작성되어 있으면, 정상&lt;/span&gt;
x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;diff&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;something&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; undefined &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;hour&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Use Union Types&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Don’t&lt;/em&gt;&lt;/strong&gt;
오직 하나의 매개변수 타입이 다른 경우에는 오버로딩을 사용하지 마라.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* WRONG */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Moment&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;utcOffset&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;utcOffset&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Moment&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;utcOffset&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Moment&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Do&lt;/em&gt;&lt;/strong&gt;
가능한 경우에는 유니온 타입을 사용하라.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* OK */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Moment&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;utcOffset&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;utcOffset&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Moment&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;시그니처의 리턴타입이 다르기 때문에 &lt;code&gt;b&lt;/code&gt;를 선택적 매개변수로 하지 않은 것을 주의하라.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Why&lt;/em&gt;&lt;/strong&gt;
이것은 함수에 값을 그대로 전달하는 사람들에게 중요하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 오버로딩으로 작성되어 있으면, 에러&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 유니온 타입으로 작성되어 있으면, 정상&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;moment&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;utcOffset&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;primitive타입이 아닌 boxing된 object형 타입. 따라서 &lt;code&gt;Numer.MAX_VALUE&lt;/code&gt;나 &lt;code&gt;Number.isSafeInteger()&lt;/code&gt;등으로 사용가능하다.&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;generic으로 선언하고 내부에서 사용하지 않는 경우를 만들지 말라는 의미로, FAQ 페이지를 보면 해당 타입 매개변수를 사용하는 부분이 없으면 타입추론이 제대로 이루어지지 않는다고 한다.&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-3&quot;&gt;
&lt;p&gt;매개변수의 개수에 대한 함수의 타입 호환성에서 할당받는 함수의 매개변수가 더 많은 경우는 호환이 가능하기 때문이다. 자주 사용하는 &lt;code&gt;map()&lt;/code&gt;,&lt;code&gt;filter()&lt;/code&gt; 같은 함수에 매개변수 하나만 사용하는 콜백을 넘기는 경우를 생각하면 쉽다.&lt;/p&gt;
&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-4&quot;&gt;
&lt;p&gt;호출하는 쪽에서는 항상 정해진 수의 매개변수를 전달하고 콜백에서 필요한 만큼만 받아서 사용해야 하는데, 매개변수 개수가 적은 시그니처가 있으면 호출하는 쪽에서 매개변수를 적게 전달하는 실수가 허용된다.&lt;/p&gt;
&lt;a href=&quot;#fnref-4&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[말하는 대로 기록하는 대로, 2019년 목표]]></title><description><![CDATA[블로그를 만들어서 회고를 먼저 작성하고 싶었으나 늦어지는 바람에 건너 뛰었고, 새해 목표도 미루다 이제서야 정리를 한 번 해본다.
정말 다사다난 했던 201…]]></description><link>https://nukeguys.github.io/life/2019-as-what-i-say/</link><guid isPermaLink="false">https://nukeguys.github.io/life/2019-as-what-i-say/</guid><pubDate>Wed, 06 Feb 2019 10:30:25 GMT</pubDate><content:encoded>&lt;p&gt;블로그를 만들어서 회고를 먼저 작성하고 싶었으나 늦어지는 바람에 건너 뛰었고, 새해 목표도 미루다 이제서야 정리를 한 번 해본다.
정말 다사다난 했던 2018년 회고를 했으면 무슨 내용이 있었을까 싶지만 기록으로 남기지 않는 편이 좋은 것 같기도 하고…&lt;/p&gt;
&lt;p&gt;정작 조금만 지나면 잊어 버리고 일 년을 보내지만 매년 해가 바뀔 때 마다 큼직한 목표들을 세운다.
올 해는 크게 분류를 하고 분류마다 하위에 구체적은 목표를 정해봤다. 그리고 그 중에 반드시 해야 할 것들을 한 가지씩 선택해서 꼭 해보려고 한다. 계획이란 너무 빡빡하면 반드시 틀어지는 법이니, 나름 여유를 두기 위해서다.&lt;/p&gt;
&lt;p&gt;목표랄 것 도 없지만 일단 가장 처음 적어놨던 건 &lt;code&gt;이사하기&lt;/code&gt;.
나름 교통도 좋고 살기도 좋아서 능력만 되고 기회만 된다면 잠실에 터를 잡고 싶지만, 1시간이 넘게 버려지는 출퇴근 시간이 너무 싫다. 더구나 다른 조건 따질 필요 없는 혼자인 자취생에게는 가까운게 최고인 것 같다.
이미 이것저것 알아보느라 머리 아프지만 나름 지금껏 만족할 집들을 찾아 왔으니 이번에도 기대를 해 본다.&lt;/p&gt;
&lt;p&gt;나머지는 크게 &lt;code&gt;운동&lt;/code&gt;, &lt;code&gt;공부&lt;/code&gt;, &lt;code&gt;기타&lt;/code&gt; 세 분류로 나눠봤다.&lt;/p&gt;
&lt;p&gt;운동은 다시 &lt;code&gt;10km 마라톤 2회&lt;/code&gt;, &lt;code&gt;한라산 등반&lt;/code&gt;, &lt;code&gt;헬스&lt;/code&gt;로 잡았다.&lt;br&gt;
우연히 회사 동료들을 따라 3월 1일 10km 마라톤을 예약했고, 준비하다보니 나름 뛰는 재미가 있어 가을 쯤에 한 번 더 해보려고 한다. 한라산은 등산을 해보고 싶었는데 제주도도 갈 겸 좋다는 얘기도 들어서 겸사겸사 정했고, 헬스는 작년 연말부터 열심히 시작했다가 문을 닫는 바람에 다시 못하게 되버렸다. 대신 매일이 아니더라도 꾸준히 할 수 있는 운동을 하나 찾아서 해보려고 한다. 예를 들면 클라이밍이나 전에 배웠던 복싱이나 등등.&lt;/p&gt;
&lt;p&gt;두 번째 공부는 &lt;code&gt;블로그(1post/1week)&lt;/code&gt;, &lt;code&gt;독서(월 1권)&lt;/code&gt;, &lt;code&gt;개발 공부&lt;/code&gt;로 정해봤다.&lt;br&gt;
블로그는 나름 열심히 만들어서 시작한 만큼 유지하고 싶기도 하고 다른 목표들에 대한 기록도 할 겸 꾸준히 해보고 싶다. 그래서 일주일에 글 하나씩 써보자 싶었고, 이 목표를 달성하려면 다른 것들을 해야할 테니 시너지를 낼 수 있지 않을까 생각된다. 모를 일이지만… 그리고 지금의 내 생각들을 남겨 놓고 싶었다. 예전 티스토리에 썼던 몇 안되는 글이 다시 읽으니 감회가 새로웠다. 독서는 항상 넣어두는 목표지만 항상 실패했던… 그래서 장르불문 그냥 양으로 달성하는 것을 일단 목표로 잡았다. 개발은,,, 아직 두루뭉실하다. 해야할 게 너무나 많기 때문에. 일단은 일과 관련된 front-end 영역과 알고리즘 공부(python)를 생각해봤다. 평일에 헬스를 못하게 된 만큼 대신 공부 계획을 세워서 진행 해 볼까 싶다.&lt;/p&gt;
&lt;p&gt;마지막은 말그대로 기타 분류하기 애매한 것들을 모아서 정해봤다. &lt;code&gt;취미 1개&lt;/code&gt;, &lt;code&gt;카카오페이지 월 1작품 보기&lt;/code&gt;, &lt;code&gt;vim 익히기&lt;/code&gt;.&lt;br&gt;
뭔가 개발이 아닌 취미로 시작해서 제2의 직업까지 갈 수도 있지 않을까 싶은, 평소에 하고 싶었던 것들 중 하나를 취미로 시작해 볼까 한다. 예를 들면 가죽 공예, 보컬 트레이닝, 알콜(?)에 대한 공부 -맥주, 와인, 위스키 뭐 이런 것들-, 요리 자격증 같은 것이랄까. 뭘 할지는 아직 미정이다. 그 다음 페이지 월 1작품 보기는 사실 내가 안쓰는 서비스를 만드는 건 싫기도 하고 만드는 사람이 사용하는 사람보다 모른다는 게 좀 부끄럽다는 생각을 한다. 그래서 전부터 항상 일과 관련 된 제품이나 서비스는 틈나는 대로 쓰고 익히려고 했다. 그래서 여러모로 도움이 되지 않을까 싶어 덤으로 같이 넣었다. vim은 부가적인 목표랄까. 되면 좋고 아니면 마는 부담없이 도전해보기 위해 넣었다. 전에도 한 번 시도를 해봤으나 부담감을 가지고 하다보니 더 안되고 효율도 더 떨어진다. 그냥 일하면서 틈틈히 필요한 부분들만 익히고 어느정도 익숙해지면 연말에는 키보드를 HPHK으로 바꿔볼까 싶다.&lt;/p&gt;
&lt;p&gt;아직 뭔가 구체적이지 못한 부분이 많긴 하지만, 너무 빡빡하면 오히려 잘 안하게 되는걸 아는지라 일단은 여기까지하고 차차 다듬고 진행해 볼 생각이다. 연말 회고가 기대되는 건 기분 탓이겠지.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;2019 새해 목표&lt;/strong&gt;&lt;br&gt;
이사&lt;br&gt;
운동 - 10km 마라톤 2회, 한라산 등반, 지속적인 운동&lt;br&gt;
공부 - 주1회 블로그 포스팅, 월 1권 독서, 개발 공부&lt;br&gt;
기타 - 취미 1개, 카카오페이지 월 1작품 보기, vim 익히기&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[우리는 달빛에도 걸을 수 있다.]]></title><description><![CDATA[…]]></description><link>https://nukeguys.github.io/book/moonlight-1195538227/</link><guid isPermaLink="false">https://nukeguys.github.io/book/moonlight-1195538227/</guid><pubDate>Sun, 27 Jan 2019 03:15:44 GMT</pubDate><content:encoded>&lt;p&gt;읽기 시작한 지 거의 두 달이 넘어서 마지막 장을 덮었다. &lt;a href=&quot;https://brunch.co.kr/@daljasee#articles&quot;&gt;브런치&lt;/a&gt;에서 우연히 보게 된 작가의 글이 좋아 구독을 시작했다. 그러다 책이 출간했다는 소식을 접하고 얼마 후 서점에 들렀다.&lt;/p&gt;
&lt;p&gt;내가 한 때 많이 읽던 자기개발서들을 보지 않게 된건 언제부턴가 강요스럽고 상업적인 느낌을 받으면서 부터다. 뻔한 내용들로 성공한 사람들은 이렇게 살았으니 너희들도 이렇게 살아야 한다고 말하는 것 같았다. 그리고 이후엔 그냥 에세이 같은 글들이 좋았다. 주로 책보다는 블로그나 브런치를 통해 그런 짤막한 글 들을 읽었다.&lt;/p&gt;
&lt;p&gt;나와 별반 다르지 않은 주변의 사소하고도 평범한 일상, 그리고 그에 대한 작가만의 느낌이나 생각. 무언가를 기억하려고도 머릿속에 담으려 하지 않아도 되고 읽는 순간 순간 떠오르는 생각과 느낌을 공감하고 받아들이면 충분했다.&lt;/p&gt;
&lt;p&gt;이 작가의 글도 그랬다. 읽고 있으면 자연스레 미소가 나기도 슬퍼지기도 했다. 물론 작가가 그래야 한다라기보다 글을 읽으면서 내가 느끼는 자연스런 감정들이었다. 다 읽고나서 뭔가를 배웠습니다하고 정리할 필요 없이 그저 그렇게 책장을 덮으면 그만이나 책의 여운은 남아 기분 좋은 그런 책이었다.&lt;/p&gt;
&lt;p&gt;책을 덮기 전에 나온 글들을 적어본다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;… 어두운 게 나쁜 건 아니다. 우리가 부정적이라고 느끼는 우울함, 죽고 싶다는 마음 같은 것들은 유독 이상한 사람들의 전유물이 아니다. 살아가는 누구나 한 번쯤은 어둠에 홀리고, 죽음을 떠올리기도 한다. 어둠은 해가 지면 찾아오는 짙은 밤처럼 당연하고도 자연스러운 삶의 일부분이다. 우리는 언제라도 어둠 속에 머무를 수 있고, 원한다면 그곳에서 내내 깊은 잠을 잘 수도 있다.&lt;br&gt;
예전의 나처럼, 그리고 청년처럼, 어둠 속에 머물러 있는 사람이 있다면 말해주고 싶다. 괜찮다고. 다만 잠시만 그곳에 머무르라고. 어둠 속을 걷다보면 어딘가에서 당신을 이끌어 줄 빛을 만날 거라고.&lt;br&gt;
어둠 속이 너무도 희미해 잘 보이지 않는다고 걱정할 필요는 없다.&lt;br&gt;
우리는 달빛에도 걸을 수가 있으니까. - 달빛에도 걸을 수 있다 -&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;… 그대로 지하철 역사 안을 걸었다. 지나가는 사람들, 서성이는 사람들, 누구가를 기다리는 사람들, 무언가를 파는 사람들, 멍하게 서 있는 사람들. 많은 사람을 바라보는데 묘한 기분이 들었다. 이들도 저마다의 사연과 삶이 있겠지. 모두가 착하지 않아도, 모두가 친절하지 않아도 괜찮았다. 꼭 보이는 얼굴이 전부는 아니니까. 무표정으로 종종걸음을 걸으며, 적당한 거리를 유지한 채 서로 스쳐 가는 타인들에게 나는 무한한 애정을 느꼈다. 경이로움도 함께.&lt;br&gt;
아마도 우린 이렇게 우주를 만드는 걸까. 혼자라도 좋았다. 무수한 사람들 속에 포함된 하찮은 존재라도 좋았다. 나는 작고 작은 우주 알갱이가 되어 두둥실, 무중력으로 걷는 기분이 들었다. 글을 쓰기 시작하고 나서는 이런 기분을 거의 매일 느끼고 있다. 정말 감사한 일이다. - 우리는 이렇게 살아가고 있었다 -&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[[TIL] GoAccess로 nginx access 로그 분석 겉핥기]]></title><description><![CDATA[MS에서도 엣지에 크로미움을 사용한다고 발표한 상황에서, 팀에서도 IE10을 더이상 지원하지 않기 위한 근거로 서비스 접속 대한 브라우저 통계가 필요했다. 가이드를 통해 nginx의 access 로그와 GoAccess…]]></description><link>https://nukeguys.github.io/dev/goaccess-analyzer/</link><guid isPermaLink="false">https://nukeguys.github.io/dev/goaccess-analyzer/</guid><pubDate>Thu, 24 Jan 2019 13:50:41 GMT</pubDate><content:encoded>&lt;p&gt;MS에서도 엣지에 크로미움을 사용한다고 발표한 상황에서, 팀에서도 IE10을 더이상 지원하지 않기 위한 근거로 서비스 접속 대한 브라우저 통계가 필요했다.&lt;br&gt;
가이드를 통해 nginx의 access 로그와 &lt;a href=&quot;https://goaccess.io/&quot;&gt;GoAccess&lt;/a&gt;에 대해 알게 되었고 이를 사용하여 간단하게 로그 분석을 해봤다.
단순하게 사용만 해본 터라 깊이는 없지만 오랜만에 사용해본 쉘 명령어도 되짚어 볼 겸 간단하게 정리해 본다.&lt;/p&gt;
&lt;p&gt;우선 서버에서 원격으로 접근 가능한 위치에 받아올 로그 파일을 미리 복사해 두고 scp를 통해 내려 받아 압축을 해제한다. (회사에서는 일주일 단위로 로그를 압축하여 백업하고 있었고, 실 서비스 서버이므로 로컬 PC로 로그파일을 내려 받아서 진행했다.)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# scp로 로그파일 내려받기&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;scp&lt;/span&gt; 계정@호스트:파일경로 저장할파일이름   &lt;span class=&quot;token comment&quot;&gt;# 원하는 파일만&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;scp&lt;/span&gt; -r 계정@호스트:폴더경로 ./ &lt;span class=&quot;token comment&quot;&gt;# 폴더 통째로&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;# gzip/gunzip으로 압축 해제하기&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;gzip&lt;/span&gt; -d access.log-xxxxxxxx.gz &lt;span class=&quot;token comment&quot;&gt;# (gunzip access.log-xxxxxxxx.gz) 원하는 파일만&lt;/span&gt;
gunzip -r ./accesslog &lt;span class=&quot;token comment&quot;&gt;# 폴더의 압축파일들을 한 번에 해제&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;로그파일이 준비됐으니 GoAccess를 설치한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;brew &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; goaccess&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GoAccess로 분석을 하기위해 로그파일의 포맷을 설정파일에 명시해야 한다. &lt;code&gt;time-format&lt;/code&gt;, &lt;code&gt;date-format&lt;/code&gt;, &lt;code&gt;log-format&lt;/code&gt; 세 가지만 설정 해주고, 로그가 표준화된 형식일 경우 실행시에 옵션으로 넣어줘도 되는 듯 하다.&lt;br&gt;
미리 정의된 형식이 주석으로 있으니 해제하여 사용하거나 없으면 맞게 작성해주면 된다. 내 PC의 설정파일의 위치는 &lt;code&gt;/usr/local/Cellar/goaccess/1.2_1/etc/goaccess.conf&lt;/code&gt;였다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;######################################&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# Time Format Options (required)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;######################################&lt;/span&gt;
time-format %H:%M:%S

&lt;span class=&quot;token comment&quot;&gt;######################################&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# Date Format Options (required)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;######################################&lt;/span&gt;
date-format %d/%b/%Y

&lt;span class=&quot;token comment&quot;&gt;######################################&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# Log Format Options (required)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;######################################&lt;/span&gt;
log-format %h - %^ &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;%d:%t %^&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;token string&quot;&gt;&quot;%r&quot;&lt;/span&gt; %s %b &lt;span class=&quot;token string&quot;&gt;&quot;%R&quot;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;%u&quot;&lt;/span&gt; %T &lt;span class=&quot;token string&quot;&gt;&quot;%^&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GoAccess를 사용하기 전에 필요한 로그를 가공 할 필요가 있었다.
&lt;a href=&quot;https://page.kakao.com&quot;&gt;카카오페이지 웹&lt;/a&gt;의 경우 PC와 모바일 버전이 다르고(당연히), 모바일의 경우 앱 내에서 호출하는 경우가 있어 제외시켜야 했다. 추가로 리다이렉션(응답코드 30X) 되는 경우도 로그가 중복이기 때문에 제외 시켰다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# 앱에서 호출하는 경우 userAgent에 KakaoPage가 포함된다.&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;sed&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;/KaKaoPage/d&apos;&lt;/span&gt; access.log-xxxxxxxx &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; 1_only_web
&lt;span class=&quot;token comment&quot;&gt;# 응답코드 30X인 레코드를 제외시킨다.(더 정확하게 할 수 있겠지만 이 정도만 해도 충분했다.)&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;sed&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;/&quot; 30. /d&apos;&lt;/span&gt; 1_only_web &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; 2_delete_redirect&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GoAccess를 실행시켜 로그 파일을 분석하고 결과를 html파일로 만든다. (결과 화면은 &lt;a href=&quot;https://goaccess.io/&quot;&gt;https://goaccess.io/&lt;/a&gt;를 참고)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;goaccess 2_delete_redirect -a -o 2_delete_redirect.html&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;결과를 대략 정리해 보면 크롬이 대부분을 차지했고, IE와 엣지는 통틀어 3%가 되지 않았다. IE10은 약 20명 내외였으며 서버 수를 고려한다 해도 절대치가 미미한 수준이었다. 아마도 이제 IE10 지원에 대한 고민은 하지 않아도 될 듯 하다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[시작]]></title><description><![CDATA[…]]></description><link>https://nukeguys.github.io/life/hello-world/</link><guid isPermaLink="false">https://nukeguys.github.io/life/hello-world/</guid><pubDate>Wed, 09 Jan 2019 14:49:39 GMT</pubDate><content:encoded>&lt;p&gt;드디어 오랫동안 만지작거리던 블로그를 완성했다.&lt;br&gt;
좀 더 마음에 들게 만들고 첫 글도 각 잡고 앉아서 쓰고 올리고 싶었으나,
지금까지 시도만 여러번으로 일단 시작하자는 생각에 글을 보여줄 수 있는 정도까지만 만들고 나서 올리려다보니 글이 없으면 에러가 나는 바람에 결국 급하게 글을 작성하고 있다.&lt;/p&gt;
&lt;p&gt;평소에 글을 써보고 싶었으나 맘처럼 안되고 주로 정리하는 내용들이다 보니 기술 블로그 비슷한 것도 하나 해보고 싶어서 네이버부터 티스토리, 미디엄, 브런치, &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt; 그리고 &lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;gatsby&lt;/a&gt;까지 시도만 수십 번을 했었다.&lt;br&gt;
결국 제대로 돌아가고 있는건 없고 그나마 유입이 되는건 &lt;a href=&quot;http://nukeguys.tistory.com/&quot;&gt;티스토리(http://nukeguys.tistory.com/)&lt;/a&gt; 정도인 것 같다. 그래봤자 하루에 1~20명 정도지만…&lt;/p&gt;
&lt;p&gt;아직 갈 길은 멀지만 그래도 이렇게 글을 써서 올린다는 것 만으로도 나름 뿌듯한 감이 있다.
이전에는 혼자 시도를 하다보니 지속이 안됐던 것 같은데, 지금은 주변에 블로그를 하시는 분들이 있다보니 같이 힘을 받는 것 같다. 아직은 허접하지만 천천히 하나씩 만들고 채우고 가다보면 그럴 듯 해 지는 날이 오겠지.&lt;/p&gt;
&lt;p&gt;이 글이 블로그의 시작이 되고, 블로그가 올해 목표의 출발점이 되어 앞으로 더 많은 시작을 할 수 있기를 바란다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“끝까지 도달하는 것이 결말을 의미하지는 않는다. 여러 번, 나는 뭔가를 끝내는 것이, 단순히 새로운 길의 시작에 불과한 것인지, 스스로 궁금하다고 생각한다. 그리고 그 질문은, 나를 처음부터 다시 시작하도록 격려해준다.” - 파블로 알보란 -&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6&gt;참고한 블로그들&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ahnheejong.name/&quot;&gt;https://ahnheejong.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.cometkim.kr/&quot;&gt;https://blog.cometkim.kr/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://adhrinae.github.io/&quot;&gt;https://adhrinae.github.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blueshw.github.io/&quot;&gt;https://blueshw.github.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.hax0r.info/&quot;&gt;https://blog.hax0r.info/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h6&gt;Thanks to&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;gatsby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bulma.io/&quot;&gt;bulma&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/&quot;&gt;github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://fonts.google.com&quot;&gt;google font&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item></channel></rss>