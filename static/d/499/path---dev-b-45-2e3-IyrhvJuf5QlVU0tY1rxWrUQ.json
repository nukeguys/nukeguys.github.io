{"data":{"site":{"siteMetadata":{"title":"nukeguys blog","description":"about development, life and something.","siteUrl":"https://nukeguys.github.io/"}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"개요… 기존에 페이지 웹에서 이미지 로딩은 휴리스틱한 방식 -화면에 먼저 나타날 것 같은 부분에 대해서 delayedLoad라는 props를 통해 바로 바로 로딩하거나,…","html":"<h1>개요…</h1>\n<p>기존에 페이지 웹에서 이미지 로딩은 휴리스틱한 방식 -화면에 먼저 나타날 것 같은 부분에 대해서 delayedLoad라는 props를 통해 바로 바로 로딩하거나, 1초 정도 지연시키거나- 으로 처리하고 있었다.\n그러다 최근에 관련된 이슈가 나오면서 delayedLoad를 임시로 모두 처리하지 않도록 했고, 제대로 바꿔야겠다 맘 먹고 있던 참에 기회가 되서 작업을 시작했다.</p>\n<h1>조사…</h1>\n<p>실제로 화면에 나타날 때 이미지를 로딩시켜야 하기 때문에 화면에 보이는지를 판단하는게 중요한 부분이다. </p>\n<h2></h2>\n<h2>intersection observer</h2>\n<h1>참고</h1>","fields":{"slug":"/dev/lazyloading-via-intersection-observer/"},"frontmatter":{"date":"2019/03/31","title":"react용 lazyloading 이미지 컴포넌트 만들기","description":"intersectionObserver로 이미지에 lazyloading 적용하기","tags":["react","lazy-loading","intersection-obsever"]}}},{"node":{"excerpt":"Do’s and Don’ts General Types Number, String, Boolean, and Oject Don’t \n Number ,  String ,  Boolean  또는  Object…","html":"<h1>Do’s and Don’ts</h1>\n<h2>General Types</h2>\n<h3>Number, String, Boolean, and Oject</h3>\n<p><strong><em>Don’t</em></strong>\n<code>Number</code>, <code>String</code>, <code>Boolean</code> 또는 <code>Object</code> 타입을 절대 사용하지 마라. 이 타입들은 JavaScript 코드에서 대부분 적절하지 않게 사용되는 non-primitive boxed object<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>들을 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* WRONG */\nfunction reverse(s: String): String;</code></pre></div>\n<p><strong><em>Do</em></strong>\n<code>number</code>, <code>string</code> 그리고 <code>boolean</code>을 사용하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* OK */\nfunction reverse(s: string): string;</code></pre></div>\n<p><code>Object</code> 대신 non-primitive인 <code>object</code> 타입을 사용하라 (<a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type\">TypeScript 2.2</a>에 추가됨).</p>\n<h4>Generic</h4>\n<p><strong><em>Don’t</em></strong>\n타입 매개변수를 사용하지 않는 generic 타입을 사용하지 마라. 더 자세한 내용은 <a href=\"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---\">TypeScript FAQ page</a>에서 확인.<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></p>\n<h2>Callback Types</h2>\n<h3>Return Types of Callbacks</h3>\n<p><strong><em>Don’t</em></strong>\n값이 무시될 콜백의 리턴타입으로 <code>any</code>를 사용하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* WRONG */\nfunction fn(x: () =&gt; any) {\n  x();\n}</code></pre></div>\n<p><strong><em>Do</em></strong>\n값이 무시될 콜백의 리턴타입으로 <code>void</code>를 사용하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* OK */\nfunction fn(x: () =&gt; void) {\n  x();\n}</code></pre></div>\n<p><strong><em>Why</em></strong>\n확인되지 않는 방법으로 <code>x</code>의 리턴타입을 사용하는 실수를 방지해주기 때문에 <code>void</code>를 사용하는 것이 더 안전하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">function fn(x: () =&gt; void) {\n  var k = x(); // oops! meant to do something else\n  k.doSomething(); // error, but would be OK if the return type had been &#39;any&#39;\n}</code></pre></div>\n<h3>Optional Paameters in Callbacks</h3>\n<p><strong><em>Don’t</em></strong>\n의도한 경우를 제외하고는 선택적 매개변수를 사용하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* WRONG */\ninterface Fetcher {\n  getObject(done: (data: any, elapsedTime?: number) =&gt; void): void;\n}</code></pre></div>\n<p>이것은 매우 분명한 의미를 갖는다. : <code>done</code> 콜백은 1개 또는 2개의 매개변수를 가지고 호출된다. 작성자는 아마 콜백이 <code>elapsedTime</code> 매개변수에 대해 신경쓰지 않는다는 것을 의도했을 것이다. 그러나 그것을 위해 선택적 매개변수로 만들 필요는 없다. - 더 적은 매개변수를 받는 콜백을 전달하는 것은 언제나 적합하다.<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup></p>\n<p><strong><em>Do</em></strong>\n콜백의 파라미터를 필수(non-optional) 파라미터로 작성하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* OK */\ninterface Fetcher {\n  getObject(done: (data: any, elapsedTime: number) =&gt; void): void;\n}</code></pre></div>\n<h3>Overloads and Callbacks</h3>\n<p><strong><em>Don’t</em></strong>\n콜백만 다른 별도의 타입 시그니처(overload)를 작성하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* WRONG */\ndeclare function beforeAll(action: () =&gt; void, timeout?: number): void;\ndeclare function beforeAll(\n  action: (done: DoneFn) =&gt; void,\n  timeout?: number\n): void;</code></pre></div>\n<p><strong><em>Do</em></strong>\n모든 것을 포함하는 타입 시그니처 하나만 작성하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* OK */\ndeclare function beforeAll(\n  action: (done: DoneFn) =&gt; void,\n  timeout?: number\n): void;</code></pre></div>\n<p><strong><em>Why</em></strong>\n콜백에서 매개변수를 무시하는 것은 언제나 적합하다.(역자:<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>과 같은 의미이다.) 따라서 더 간단한 타입 시그니처는 필요하지 않다. 간단한 타입 시그니처를 제공하는 것은 타입이 잘못된 함수가 첫번째 함수 시그니처와 매칭되어 전달되는 것을 허용한다.<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup></p>\n<h3>Function Overloads</h3>\n<h4>Ordering</h4>\n<p><strong><em>Don’t</em></strong>\n더 구체적인 시그니처 전에 일반적인 시그니처를 두지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* WRONG */\ndeclare function fn(x: any): any;\ndeclare function fn(x: HTMLElement): number;\ndeclare function fn(x: HTMLDivElement): string;\n\nvar myElem: HTMLDivElement;\nvar x = fn(myElem); // x: any, wat?</code></pre></div>\n<p><strong><em>Do</em></strong>\n더 구체적인 시그니처 다음에 일반적인 시그니처를 두도록 정렬하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* OK */\ndeclare function fn(x: HTMLDivElement): string;\ndeclare function fn(x: HTMLElement): number;\ndeclare function fn(x: any): any;\n\nvar myElem: HTMLDivElement;\nvar x = fn(myElem); // x: string, :)</code></pre></div>\n<p><strong><em>Why</em></strong>\nTypeScript는 함수 호출을 결정할 때 처음 매칭되는 시그니처를 서낵한다. 먼저 나오는 시그니처가 뒤의 시그니처보다 더 일반적일 경우, 뒤에 나오는 것은 완벽히 가려지고 호출될 수 없다.</p>\n<h3>Use Optional Parameters</h3>\n<p><strong><em>Don’t</em></strong>\n뒤에 나오는 매개변수들만 다른 경우 여러 시그니처를 작성하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* WRONG */\ninterface Example {\n  diff(one: string): number;\n  diff(one: string, two: string): number;\n  diff(one: string, two: string, three: boolean): number;\n}</code></pre></div>\n<p><strong><em>Do</em></strong>\n가능한 경우에는 선택적 매개변수를 사용하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* OK */\ninterface Example {\n  diff(one: string, two?: string, three?: boolean): number;\n}</code></pre></div>\n<p>이 방법은 모든 시그니처의 리턴타입이 같은 경우에만 가능하다는 것을 주의하라.</p>\n<p><strong><em>Why</em></strong>\n여기엔 두 가지 중요한 이유가 있다.</p>\n<p>TypeScript는 source의 매개변수로 target의 시그니처 호출할 수 있는지, 그리고 관련없는 매개변수가 허용되는지를 보고 시그니처 호환성을 결정한다. 예를 들어, 이 코드는 시그니처가 선택적 매개변수를 사용하여\n정확히 작성된 경우에만 버그를 발생시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">function fn(x: (a: string, b: number, c: number) =&gt; void) {}\nvar x: Example;\n// 오버로딩으로 작성되어 있으면, OK -- 첫 번째 시그니처를 사용\n// 선택적 매개변수로 작성되어 있으면, 에러\nfn(x.diff);</code></pre></div>\n<p>두 번째 이유는 TypeScript의 <code>stric null checking</code> 기능을 사용하는 경우이다. JavaScript에서 명시되지 않은 매개변수는 <code>undefined</code>로 표현되기 때문에, 일반적으로 선택적 매개변수를 가진 함수에 <code>undefined</code>를 명시적으로 전달하는 것이 좋다. 예를 들어 이 코드는 strict null을 사용하는 경우에도 문제없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">var x: Example;\n// 오버로딩으로 작성되어 있으면, `undefined`를 `string` 타입으로 전달하기 때문에 에러\n// 선택적 매개변수로 작성되어 있으면, 정상\nx.diff(&#39;something&#39;, true ? undefined : &#39;hour&#39;);</code></pre></div>\n<h3>Use Union Types</h3>\n<p><strong><em>Don’t</em></strong>\n오직 하나의 매개변수 타입이 다른 경우에는 오버로딩을 사용하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* WRONG */\ninterface Moment {\n  utcOffset(): number;\n  utcOffset(b: number): Moment;\n  utcOffset(b: string): Moment;\n}</code></pre></div>\n<p><strong><em>Do</em></strong>\n가능한 경우에는 유니온 타입을 사용하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* OK */\ninterface Moment {\n  utcOffset(): number;\n  utcOffset(b: number | string): Moment;\n}</code></pre></div>\n<p>시그니처의 리턴타입이 다르기 때문에 <code>b</code>를 선택적 매개변수로 하지 않은 것을 주의하라.</p>\n<p><strong><em>Why</em></strong>\n이것은 함수에 값을 그대로 전달하는 사람들에게 중요하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">function fn(x: string): void;\nfunction fn(x: number): void;\nfunction fn(x: number | string) {\n  // 오버로딩으로 작성되어 있으면, 에러\n  // 유니온 타입으로 작성되어 있으면, 정상\n  return moment().utcOffset(x);\n}</code></pre></div>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>primitive타입이 아닌 boxing된 object형 타입. 따라서 <code>Numer.MAX_VALUE</code>나 <code>Number.isSafeInteger()</code>등으로 사용가능하다.</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p>generic으로 선언하고 내부에서 사용하지 않는 경우를 만들지 말라는 의미로, FAQ 페이지를 보면 해당 타입 매개변수를 사용하는 부분이 없으면 타입추론이 제대로 이루어지지 않는다고 한다.</p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p>매개변수의 개수에 대한 함수의 타입 호환성에서 할당받는 함수의 매개변수가 더 많은 경우는 호환이 가능하기 때문이다. 자주 사용하는 <code>map()</code>,<code>filter()</code> 같은 함수에 매개변수 하나만 사용하는 콜백을 넘기는 경우를 생각하면 쉽다.</p>\n<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-4\">\n<p>호출하는 쪽에서는 항상 정해진 수의 매개변수를 전달하고 콜백에서 필요한 만큼만 받아서 사용해야 하는데, 매개변수 개수가 적은 시그니처가 있으면 호출하는 쪽에서 매개변수를 적게 전달하는 실수가 허용된다.</p>\n<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","fields":{"slug":"/dev/ts-do-and-dont/"},"frontmatter":{"date":"2019/02/11","title":"[번역] TypeScript의 Do's and Don'ts","description":"TypeScript 공식 documentation의 Do's and Don'ts를 번역해 보았다.","tags":["TIL","typscript"]}}},{"node":{"excerpt":"MS에서도 엣지에 크로미움을 사용한다고 발표한 상황에서, 팀에서도 IE10을 더이상 지원하지 않기 위한 근거로 서비스 접속 대한 브라우저 통계가 필요했다. 가이드를 통해 nginx의 access 로그와  GoAccess…","html":"<p>MS에서도 엣지에 크로미움을 사용한다고 발표한 상황에서, 팀에서도 IE10을 더이상 지원하지 않기 위한 근거로 서비스 접속 대한 브라우저 통계가 필요했다.<br>\n가이드를 통해 nginx의 access 로그와 <a href=\"https://goaccess.io/\">GoAccess</a>에 대해 알게 되었고 이를 사용하여 간단하게 로그 분석을 해봤다.\n단순하게 사용만 해본 터라 깊이는 없지만 오랜만에 사용해본 쉘 명령어도 되짚어 볼 겸 간단하게 정리해 본다.</p>\n<p>우선 서버에서 원격으로 접근 가능한 위치에 받아올 로그 파일을 미리 복사해 두고 scp를 통해 내려 받아 압축을 해제한다. (회사에서는 일주일 단위로 로그를 압축하여 백업하고 있었고, 실 서비스 서버이므로 로컬 PC로 로그파일을 내려 받아서 진행했다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># scp로 로그파일 내려받기</span>\n<span class=\"token function\">scp</span> 계정@호스트:파일경로 저장할파일이름   <span class=\"token comment\"># 원하는 파일만</span>\n<span class=\"token function\">scp</span> -r 계정@호스트:폴더경로 ./ <span class=\"token comment\"># 폴더 통째로</span>\n\n<span class=\"token comment\"># gzip/gunzip으로 압축 해제하기</span>\n<span class=\"token function\">gzip</span> -d access.log-xxxxxxxx.gz <span class=\"token comment\"># (gunzip access.log-xxxxxxxx.gz) 원하는 파일만</span>\ngunzip -r ./accesslog <span class=\"token comment\"># 폴더의 압축파일들을 한 번에 해제</span></code></pre></div>\n<p>로그파일이 준비됐으니 GoAccess를 설치한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">brew <span class=\"token function\">install</span> goaccess</code></pre></div>\n<p>GoAccess로 분석을 하기위해 로그파일의 포맷을 설정파일에 명시해야 한다. <code>time-format</code>, <code>date-format</code>, <code>log-format</code> 세 가지만 설정 해주고, 로그가 표준화된 형식일 경우 실행시에 옵션으로 넣어줘도 되는 듯 하다.<br>\n미리 정의된 형식이 주석으로 있으니 해제하여 사용하거나 없으면 맞게 작성해주면 된다. 내 PC의 설정파일의 위치는 <code>/usr/local/Cellar/goaccess/1.2_1/etc/goaccess.conf</code>였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\">######################################</span>\n<span class=\"token comment\"># Time Format Options (required)</span>\n<span class=\"token comment\">######################################</span>\ntime-format %H:%M:%S\n\n<span class=\"token comment\">######################################</span>\n<span class=\"token comment\"># Date Format Options (required)</span>\n<span class=\"token comment\">######################################</span>\ndate-format %d/%b/%Y\n\n<span class=\"token comment\">######################################</span>\n<span class=\"token comment\"># Log Format Options (required)</span>\n<span class=\"token comment\">######################################</span>\nlog-format %h - %^ <span class=\"token punctuation\">[</span>%d:%t %^<span class=\"token punctuation\">]</span>  <span class=\"token string\">\"%r\"</span> %s %b <span class=\"token string\">\"%R\"</span> <span class=\"token string\">\"%u\"</span> %T <span class=\"token string\">\"%^\"</span></code></pre></div>\n<p>GoAccess를 사용하기 전에 필요한 로그를 가공 할 필요가 있었다.\n<a href=\"https://page.kakao.com\">카카오페이지 웹</a>의 경우 PC와 모바일 버전이 다르고(당연히), 모바일의 경우 앱 내에서 호출하는 경우가 있어 제외시켜야 했다. 추가로 리다이렉션(응답코드 30X) 되는 경우도 로그가 중복이기 때문에 제외 시켰다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 앱에서 호출하는 경우 userAgent에 KakaoPage가 포함된다.</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/KaKaoPage/d'</span> access.log-xxxxxxxx <span class=\"token operator\">></span> 1_only_web\n<span class=\"token comment\"># 응답코드 30X인 레코드를 제외시킨다.(더 정확하게 할 수 있겠지만 이 정도만 해도 충분했다.)</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/\" 30. /d'</span> 1_only_web <span class=\"token operator\">></span> 2_delete_redirect</code></pre></div>\n<p>GoAccess를 실행시켜 로그 파일을 분석하고 결과를 html파일로 만든다. (결과 화면은 <a href=\"https://goaccess.io/\">https://goaccess.io/</a>를 참고)</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">goaccess 2_delete_redirect -a -o 2_delete_redirect.html</code></pre></div>\n<p>결과를 대략 정리해 보면 크롬이 대부분을 차지했고, IE와 엣지는 통틀어 3%가 되지 않았다. IE10은 약 20명 내외였으며 서버 수를 고려한다 해도 절대치가 미미한 수준이었다. 아마도 이제 IE10 지원에 대한 고민은 하지 않아도 될 듯 하다.</p>","fields":{"slug":"/dev/goaccess-analyzer/"},"frontmatter":{"date":"2019/01/24","title":"[TIL] GoAccess로 nginx access 로그 분석 겉핥기","description":"브라우저별 접속 통계 확인을 위한 GoAccess 사용기","tags":["TIL","GoAccess","nginx","IE10"]}}}]}},"pageContext":{}}