{"data":{"site":{"siteMetadata":{"title":"nukeguys blog","author":"nukeguys"}},"markdownRemark":{"id":"0cb77a3e-bd1f-596d-a718-9807f212e1fb","excerpt":"program(=binary) 실행가능한 코드 or 파일 process vs thread 싱글 프로세스는 프로세스가 곧 스레드. 둘 다 cpu 스케쥴링 단위이며, 프로세스는 독립된 자원(메모리 등)을 갖고 스레드는 공유한다는 점이 차이 process 실행중인(memory…","html":"<h2>program(=binary)</h2>\n<p>실행가능한 코드 or 파일</p>\n<h2>process vs thread</h2>\n<p>싱글 프로세스는 프로세스가 곧 스레드. 둘 다 cpu 스케쥴링 단위이며, 프로세스는 독립된 자원(메모리 등)을 갖고 스레드는 공유한다는 점이 차이</p>\n<h2>process</h2>\n<p>실행중인(memory<sup id=\"fnref-memory\"><a href=\"#fn-memory\" class=\"footnote-ref\">memory</a></sup>에 적재된) 프로그램</p>\n<p>메모리에 적재된 바이너리 이미지와 가상화 된 메모리 인스턴스, 열린 파일 같은 커널 리소스, 관련된 사용자 정보와 같은 보안 정보와 하나 이상의 스레드를 포함</p>\n<p>프로세스는 fork로 생성되어 execve로 실행 되며 exit로 종료하고 wait로 소멸</p>\n<h3>cow(copy-on-write)</h3>\n<p>fork()를 통해 프로세스를 생성하면 메모리의 복사를 수행하는데, 이 때 fork() 직 후에 모든 메모리를 복사하지 않고 실제 해당 메모리<sup id=\"fnref-memory\"><a href=\"#fn-memory\" class=\"footnote-ref\">memory</a></sup>에 write작업 발생하는 경우에 복사를 수행하는 지연 최적화(lazy optimizatino)</p>\n<p>fork() 이후 자식 프로세스가 새로운 바이너리를 실행하면 이전의 주소 공간은 불필요해지고 copy on write는 이런 경우를 최적화</p>\n<h3>orphaned vs zombie process</h3>\n<p>orpahaned(고아) process : 자식 프로세스가 종료하기 전에 부모 프로세스가 수행을 마친 경우의 자식 프로세스, 커널은 자식 프로세스를 찾아 init프로세스<sup id=\"fnref-init\"><a href=\"#fn-init\" class=\"footnote-ref\">init</a></sup>의 자식이 되도록 설정</p>\n<p>zombie(좀비) process : 종료했으나 부모 프로세스에서 종료코드를 읽어가지 않은(wait()을 호출하지 않은) 프로세스, init 프로세스는 차례대로 주기적으로 자식 프로세스에 대해 wait() 호출을 통해 지속적인 좀비 상태를 방지</p>\n<h3>process 그룹</h3>\n<p>하나 이상의 프로세스들의 집합으로 일관된 작업을 하는 프로세스들</p>\n<p>프로세스 그룹 리더의 pid가 그룹 ID, 리더는 그룹 내의 프로세스를 생성, 종료 가능</p>\n<p>프로세스 그룹의 마지막 프로세스가 그룹을 떠날 때 까지 그룹 유지</p>\n<h3>process 세션</h3>\n<p>하나 이상의 프로세스 그룹들의 집합으로 보통 동일한 터미널에서 수행되고 있는 프로세스 그룹들</p>\n<p>세션 리더의 pid가 세션 ID</p>\n<h3>병행성 vs 병렬성</h3>\n<p>병행성(multiprogramming) : 하나의 core에 여러 프로세스가 실행 됨(scheduling)</p>\n<p>병렬성(multiprocessing) : 두 개 이상의 core에서 프로세스가 실행 됨</p>\n<h3>scheduling(linux)</h3>\n<p>1세대(round robin) : 리스트 기반으로 우선순위가 높은 프로세스를 찾는데 O(n) 성능</p>\n<p>2세대(bitmap) : Bitmap과 hash를 이용 우선순위가 높은 프로세스를 찾는데 O(1) 성능을 보이지만 공정하지 않음</p>\n<p>3세대(CFS) : time slice대신 CPU시간을 할당해서 공정하게 스케줄링</p>\n<h3>IPC</h3>\n<p>프로세스간 resource와 information을 공유</p>\n<p><strong>signal</strong></p>\n<p>비동기 이벤트 처리를 위한 메커니즘을 제공하는 소프트웨어 인터럽트</p>\n<p><strong>pipe</strong></p>\n<p>프로세스간 단 방향 통신 방법</p>\n<p>한 프로세스의 표준 출력을 다른 프로세스의 표준 입력에 연결</p>\n<p><strong>message queue</strong></p>\n<p>메시지 큐를 이용한 메시지 전달</p>\n<p><strong>semaphore</strong></p>\n<p>프로세스간 동기화에 사용</p>\n<p>mutext와 비슷하나 갯수가 하나 이상일 수 있다는 점이 차이</p>\n<p><strong>shared memory</strong></p>\n<p>대용량이며 빠른 메시지 전달</p>\n<h2>thread(=LWP)</h2>\n<p>프로세스 내 실행 단위, 가상 메모리를 공유하는 프로세스(parent의 가상 메모리 맵을 공유)</p>\n<p>각각의 스레드는 저마다의 가상화된 프로세스를 가지고 있으며 여기에는 스택과 레지스터, 명령어 포인터 같은 프로세서의 상태가 포함</p>\n<h3>race condition</h3>\n<p>공유 리소스에 동기화되지 않은 둘 이상의 스레드가 접근하여 프로그램의 오동작을 유발하는 상황</p>\n<h3>critical section</h3>\n<p>race condition이 발생할 수 있기 때문에 동기화가 되어야 하는 영역</p>\n<h3>동기화</h3>\n<p><strong>mutex</strong></p>\n<p>lock을 이용해 상호 배제(mutual exclusion)를 구현. critical sectin 진입시 한 번에 하나의 스레드만 락을 걸 수 있고 실행이 끝나면 해제, 나머지 스레드는 얻을 때 까지 대기.(=binary semaphore)</p>\n<p><strong>deadlock</strong></p>\n<p>두 스레드가 서로 상대방이 끝나기를 기다리고 있어 결국 둘 다 끝나지 못하는 상태</p>\n<p>아래 4가지 조건을 모두 만족해야 발생</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">상호 배제(Mutual Exclusion) : 자원은 한 번에 한 프로세스만 사용 가능\n점유 대기(Hold and Wait) : 최소한 하나의 자원을 점유하고 있으면서, 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함\n비선점 (No Preemption) : 다른 프로세스에 할당된 자원은 사용이 끝날 때 까지 강제로 빼앗을 수 없다.\n순환 대기(Circular Wait) : 프로세스의 집합 P0...Pn에서 p(n-1)은 pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야 한다.</code></pre></div>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-memory\">\n<p>text(code), data(전역/정적 변수), heap, stack, bss(초기화되지 않은 전역변수)</p>\n<a href=\"#fnref-memory\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-init\">\n<p>pid가 1인 system에서 가장 먼저 실행되는 프로세스</p>\n<a href=\"#fnref-init\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"Tech Interview - OS","date":"2018/12/04(Wed) 22:07","tags":["interview","os"],"description":"기술 면접대비 - OS"}}},"pageContext":{"slug":"/Tech-Interview-OS/","previous":{"fields":{"slug":"/Python-Study/"},"frontmatter":{"title":"Python Study"}},"next":{"fields":{"slug":"/면접에서-물어봐야-할-질문/"},"frontmatter":{"title":"면접에서 물어봐야 할 질문"}}}}