{"data":{"site":{"siteMetadata":{"title":"nukeguys blog","author":"nukeguys","google_ad_client":"ca-pub-3962171616803555"}},"markdownRemark":{"id":"26c4be79-cc8a-5a59-8eec-53e7e912f9a2","excerpt":"Do’s and Don’ts General Types Number, String, Boolean, and Oject Don’t \n Number ,  String ,  Boolean  또는  Object  타입을 절대 사용하지 마라. 이 타입들은 JavaScript…","html":"<h1>Do’s and Don’ts</h1>\n<h2>General Types</h2>\n<h3>Number, String, Boolean, and Oject</h3>\n<p><strong><em>Don’t</em></strong>\n<code>Number</code>, <code>String</code>, <code>Boolean</code> 또는 <code>Object</code> 타입을 절대 사용하지 마라. 이 타입들은 JavaScript 코드에서 대부분 적절하지 않게 사용되는 non-primitive boxed object<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>들을 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* WRONG */\nfunction reverse(s: String): String;</code></pre></div>\n<p><strong><em>Do</em></strong>\n<code>number</code>, <code>string</code> 그리고 <code>boolean</code>을 사용하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* OK */\nfunction reverse(s: string): string;</code></pre></div>\n<p><code>Object</code> 대신 non-primitive인 <code>object</code> 타입을 사용하라 (<a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type\">TypeScript 2.2</a>에 추가됨).</p>\n<h4>Generic</h4>\n<p><strong><em>Don’t</em></strong>\n타입 매개변수를 사용하지 않는 generic 타입을 사용하지 마라. 더 자세한 내용은 <a href=\"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---\">TypeScript FAQ page</a>에서 확인.<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></p>\n<h2>Callback Types</h2>\n<h3>Return Types of Callbacks</h3>\n<p><strong><em>Don’t</em></strong>\n값이 무시될 콜백의 리턴타입으로 <code>any</code>를 사용하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* WRONG */\nfunction fn(x: () =&gt; any) {\n  x();\n}</code></pre></div>\n<p><strong><em>Do</em></strong>\n값이 무시될 콜백의 리턴타입으로 <code>void</code>를 사용하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* OK */\nfunction fn(x: () =&gt; void) {\n  x();\n}</code></pre></div>\n<p><strong><em>Why</em></strong>\n확인되지 않는 방법으로 <code>x</code>의 리턴타입을 사용하는 실수를 방지해주기 때문에 <code>void</code>를 사용하는 것이 더 안전하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">function fn(x: () =&gt; void) {\n  var k = x(); // oops! meant to do something else\n  k.doSomething(); // error, but would be OK if the return type had been &#39;any&#39;\n}</code></pre></div>\n<h3>Optional Paameters in Callbacks</h3>\n<p><strong><em>Don’t</em></strong>\n의도한 경우를 제외하고는 선택적 매개변수를 사용하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* WRONG */\ninterface Fetcher {\n  getObject(done: (data: any, elapsedTime?: number) =&gt; void): void;\n}</code></pre></div>\n<p>이것은 매우 분명한 의미를 갖는다. : <code>done</code> 콜백은 1개 또는 2개의 매개변수를 가지고 호출된다. 작성자는 아마 콜백이 <code>elapsedTime</code> 매개변수에 대해 신경쓰지 않는다는 것을 의도했을 것이다. 그러나 그것을 위해 선택적 매개변수로 만들 필요는 없다. - 더 적은 매개변수를 받는 콜백을 전달하는 것은 언제나 적합하다.<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup></p>\n<p><strong><em>Do</em></strong>\n콜백의 파라미터를 필수(non-optional) 파라미터로 작성하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* OK */\ninterface Fetcher {\n  getObject(done: (data: any, elapsedTime: number) =&gt; void): void;\n}</code></pre></div>\n<h3>Overloads and Callbacks</h3>\n<p><strong><em>Don’t</em></strong>\n콜백만 다른 별도의 타입 시그니처(overload)를 작성하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* WRONG */\ndeclare function beforeAll(action: () =&gt; void, timeout?: number): void;\ndeclare function beforeAll(\n  action: (done: DoneFn) =&gt; void,\n  timeout?: number\n): void;</code></pre></div>\n<p><strong><em>Do</em></strong>\n모든 것을 포함하는 타입 시그니처 하나만 작성하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* OK */\ndeclare function beforeAll(\n  action: (done: DoneFn) =&gt; void,\n  timeout?: number\n): void;</code></pre></div>\n<p><strong><em>Why</em></strong>\n콜백에서 매개변수를 무시하는 것은 언제나 적합하다.(역자:<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>과 같은 의미이다.) 따라서 더 간단한 타입 시그니처는 필요하지 않다. 간단한 타입 시그니처를 제공하는 것은 타입이 잘못된 함수가 첫번째 함수 시그니처와 매칭되어 전달되는 것을 허용한다.<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup></p>\n<h3>Function Overloads</h3>\n<h4>Ordering</h4>\n<p><strong><em>Don’t</em></strong>\n더 구체적인 시그니처 전에 일반적인 시그니처를 두지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* WRONG */\ndeclare function fn(x: any): any;\ndeclare function fn(x: HTMLElement): number;\ndeclare function fn(x: HTMLDivElement): string;\n\nvar myElem: HTMLDivElement;\nvar x = fn(myElem); // x: any, wat?</code></pre></div>\n<p><strong><em>Do</em></strong>\n더 구체적인 시그니처 다음에 일반적인 시그니처를 두도록 정렬하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* OK */\ndeclare function fn(x: HTMLDivElement): string;\ndeclare function fn(x: HTMLElement): number;\ndeclare function fn(x: any): any;\n\nvar myElem: HTMLDivElement;\nvar x = fn(myElem); // x: string, :)</code></pre></div>\n<p><strong><em>Why</em></strong>\nTypeScript는 함수 호출시 처음 매칭되는 시그니처를 서낵한다. 먼저 나오는 시그니처가 뒤의 시그니처보다 더 일반적일 경우, 뒤에 나오는 것은 완벽히 가려지고 호출될 수 없다.</p>\n<h3>Use Optional Parameters</h3>\n<p><strong><em>Don’t</em></strong>\n뒤에 나오는 매개변수들만 다른 경우 여러 시그니처를 작성하지 마라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* WRONG */\ninterface Example {\n  diff(one: string): number;\n  diff(one: string, two: string): number;\n  diff(one: string, two: string, three: boolean): number;\n}</code></pre></div>\n<p><strong><em>Do</em></strong>\n가능하다면 선택적 매개변수를 사용하라.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">/* OK */\ninterface Example {\n  diff(one: string, two?: string, three?: boolean): number;\n}</code></pre></div>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>primitive타입이 아닌 boxing된 object형 타입. 따라서 <code>Numer.MAX_VALUE</code>나 <code>Number.isSafeInteger()</code>등으로 사용가능하다.</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p>generic으로 선언하고 내부에서 사용하지 않는 경우를 만들지 말라는 의미로, FAQ 페이지를 보면 해당 타입 매개변수를 사용하는 부분이 없으면 타입추론이 제대로 이루어지지 않는다고 한다.</p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p>매개변수의 개수에 대한 함수의 타입 호환성에서 할당받는 함수의 매개변수가 더 많은 경우는 호환이 가능하기 때문이다. 자주 사용하는 <code>map()</code>,<code>filter()</code> 같은 함수에 매개변수 하나만 사용하는 콜백을 넘기는 경우를 생각하면 쉽다.</p>\n<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-4\">\n<p>호출하는 쪽에서는 항상 정해진 수의 매개변수를 전달하고 콜백에서 필요한 만큼만 받아서 사용해야 하는데, 매개변수 개수가 적은 시그니처가 있으면 호출하는 쪽에서 매개변수를 적게 전달하는 실수가 허용된다.</p>\n<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"[번역] TypeScript의 Do's and Don'ts","date":"2019/02/11 22:52","tags":["TIL","typscript"],"description":"TypeScript 공식 documentation의 Do's and Don'ts를 번역해 보았다."}}},"pageContext":{"slug":"/dev/ts-do-and-dont/","previous":{"fields":{"slug":"/life/2019-as-what-i-say/"},"frontmatter":{"title":"말하는 대로 기록하는 대로, 2019년 목표"}},"next":null}}